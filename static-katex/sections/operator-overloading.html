<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marat Akhin" />
  <meta name="author" content="Mikhail Belyaev" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../resources/css/main.css">
  <link rel="stylesheet" href="../resources/js/katex/katex.min.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script data-main="resources/js/main" src="https://requirejs.org/docs/release/2.3.6/minified/require.js"></script>
  <script>
      requirejs.config({
          waitSeconds: 10000
      });
  </script>
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
<p class="author">Marat Akhin</p>
<p class="author">Mikhail Belyaev</p>
</header>



























<span style="visibility: hidden; counter-reset: chapter 8;"></span>
<h2 id="operator-overloading">Operator overloading</h2>
<div class="paragraph">
<p><span class="sentence">Some syntax forms in Kotlin are <em>defined by convention</em>, meaning that their semantics are defined through syntactic expansion of one syntax form into another syntax form.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Particular cases of definition by convention include:</span></p>
</div>
<ul>
<li><span class="sentence">Arithmetic and comparison operators;</span></li>
<li><span class="sentence"><code>invoke</code> convention;</span></li>
<li><span class="sentence">Operator-form <a href="statements.html#assignments">assignments</a>;</span></li>
<li><span class="sentence"><a href="statements.html#for-loop-statement">For-loop statements</a>;</span></li>
<li><span class="sentence"><a href="declarations.html#delegated-property-declaration">Delegated properties</a>;</span></li>
<li><span class="sentence"><a href="operator-overloading.html#destructuring-declarations">Destructuring declarations</a>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: another case of definition by convention is <a href="expressions.html#navigation-operators">safe navigation</a>, which is covered in more detail in its respective section.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">There are several points shared among all the syntax forms defined using definition by convention:</span></p>
</div>
<ul>
<li><span class="sentence">The expansions are hygienic: if they introduce new identifiers that were not present in original syntax, all such identifiers are not accessible outside the expansion and cannot clash with any other declarations in the program;</span></li>
<li><span class="sentence">The expressions captured by an expansion are using <em>call-by-need</em> evaluation strategy, meaning that they are evaluated only once during first usage specified in the expansion even if the expansion itself has more than one usage of such an expression;</span></li>
<li><span class="sentence">An expansion may lead to another expansion, following the same rules;</span></li>
<li><span class="sentence">All call expressions that are produced by expansion are only allowed to use operator functions.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This expansion of a particular syntax form to a different piece of code is usually defined in the terms of <em>operator</em> functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Operator functions are function which are <a href="declarations.html#function-declaration">declared</a> with a special keyword <code>operator</code> and are not different from regular functions when called via <a href="expressions.html#function-calls-and-property-access">function calls</a>. </span><span class="sentence">However, operator functions can also be used in definition by convention.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: different platforms may add additional criteria on whether a function may be considered a suitable candidate for operator convention.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The details of individual expansions are available in the sections of their respective operators, here we would like to describe how they <em>interoperate</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For example, take the following declarations:</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> <span class="dt">A</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">inc</span><span class="op">():</span> <span class="dt">A</span> <span class="op">{</span> ... <span class="op">}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">object</span> <span class="dt">B</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span>(i: <span class="kw">Int</span>): A <span class="op">{</span> ... <span class="op">}</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">set</span>(i: <span class="kw">Int</span>, value: A) <span class="op">{</span> ... <span class="op">}</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">object</span> <span class="dt">C</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span>(i: <span class="kw">Int</span>): B <span class="op">{</span> ... <span class="op">}</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="op">}</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The expression <code>C[0][0]++</code> is expanded (see the <a href="control--and-data-flow-analysis.html#expressions-1">Expressions</a> section for details) using the following rules:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">The operations are expanded in order of their priority <span><span class="TODO">(TODO(Where and how to specify this priority?))</span><span class="TODO-marker">*</span></span>.</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">First, the <a href="expressions.html#postfix-increment-expression">increment operator</a> is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1">C[<span class="dv">0</span>][<span class="dv">0</span>] = C[<span class="dv">0</span>][<span class="dv">0</span>].inc()</a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">Second, the <a href="statements.html#assignments">assignment</a> to an indexing expression (produced by the previous expansion) is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1">C[<span class="dv">0</span>].<span class="kw">set</span><span class="op">(</span><span class="va">C</span>[<span class="va">0</span>][<span class="va">0</span>].<span class="va">inc</span>(<span class="op">)</span>)</a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">Third, the <a href="expressions.html#indexing-expressions">indexing expressions</a> are expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1">C.<span class="kw">get</span><span class="op">(</span><span class="va">0</span><span class="op">).</span><span class="kw">set</span>(C.<span class="kw">get</span><span class="op">(</span><span class="va">0</span><span class="op">).</span><span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Specify when we run the overload resolution to know what we’re expanding to)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: although the resulting expression contains several instances of the subexpression <code>C.get(0)</code>, as all these instances were created from the same original syntax form, the subexpression is evaluated only once, making this code roughly equivalent to:</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">val</span> $<span class="va">tmp</span> <span class="op">=</span> C.<span class="kw">get</span><span class="op">(</span><span class="va">0</span><span class="op">)</span></a>
<a class="sourceLine" id="cb5-2" title="2">$<span class="fu">tmp</span><span class="op">.</span><span class="kw">set</span>($tmp.<span class="kw">get</span><span class="op">(</span><span class="va">0</span><span class="op">).</span><span class="fu">inc</span><span class="op">()</span>)</a></code></pre></div>
</blockquote>
<h3 id="destructuring-declarations">Destructuring declarations</h3>
<div class="paragraph">
<p><span class="sentence">A special case of definition by convention is the destructuring declaration of properties, which is available for <a href="declarations.html#local-property-declaration">local properties</a>, parameters of <a href="expressions.html#lambda-literals">lambda literals</a> and the iteration variable of <a href="statements.html#for-loop-statement">for-loops</a>. </span><span class="sentence">See the corresponding sections for particular syntax.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This convention allows to introduce a number (one or more) of properties in the place of one by immediately <em>destructuring</em> the property during construction. </span><span class="sentence">The immediate value (that is, the initializing expression of the local property, the value acquired from the operator convention of a for-loop statement, or an argument passed into a lambda body) is assigned to a number of placeholders <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>p</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">p_0, \ldots, p_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>

 where each placeholder is either an identifier or a special ignoring placeholder <code>_</code> (note that <code>_</code> is not a valid identifier in Kotlin). </span><span class="sentence">For each identifier the corresponding operator function <code>componentK</code> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>

 being equal to the position of the placeholder in the declaration (<strong>starting from 1</strong>) is called without arguments and the result is assigned to a fresh value referred to as the identifier used. </span><span class="sentence">For each ignoring placeholder, no calls are performed and nothing is assigned. </span><span class="sentence">Each placeholder may be provided with an optional type signature <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">T_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>

 which is used in <a href="type-inference.html#type-inference">type inference</a> as any property type would. </span><span class="sentence">Note that an ignoring placeholder may also be provided with a type signature, in which case although the call to corresponding <code>componentM</code> function is not performed, it still must be checked for function applicability during type inference.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">val</span> <span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">A</span><span class="op">,</span> <span class="va">_</span><span class="op">,</span> <span class="va">z</span><span class="op">)</span> <span class="op">=</span> f()</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is expanded to</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">val</span> $<span class="va">tmp</span> <span class="op">=</span> f()</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">val</span> <span class="va">x</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> $tmp.component1()</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">val</span> <span class="va">z</span> <span class="op">=</span> $tmp.component3()</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>component1</code> and <code>component3</code> are suitable operator functions available on the value returned by <code>f()</code></span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="cf">for</span>((x: A, _, z) <span class="kw">in</span> f()) <span class="op">{</span> ... <span class="op">}</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is expanded to (as per for-loop expansion)</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="cf">when</span>(<span class="kw">val</span> $<span class="va">iterator</span> <span class="op">=</span> f().iterator()) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="cf">else</span> -&gt; <span class="cf">while</span> ($iterator.hasNext()) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-3" title="3">                <span class="kw">val</span> $<span class="va">tmp</span> <span class="op">=</span> $iterator.next()</a>
<a class="sourceLine" id="cb9-4" title="4">                <span class="kw">val</span> <span class="va">x</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> $tmp.component1()</a>
<a class="sourceLine" id="cb9-5" title="5">                <span class="kw">val</span> <span class="va">z</span> <span class="op">=</span> $tmp.component3()</a>
<a class="sourceLine" id="cb9-6" title="6">                ...</a>
<a class="sourceLine" id="cb9-7" title="7">            <span class="op">}</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="op">}</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>iterator()</code>, <code>next()</code>, <code>hasNext()</code>, <code>component1()</code> and <code>component3</code> are all suitable operator functions available on their respective receivers.</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1">foo <span class="op">{</span> (x: A, _, z) -&gt; ... <span class="op">}</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is expanded to</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1">foo <span class="op">{</span> $tmp -&gt;</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="kw">val</span> <span class="va">x</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> $tmp.component1()</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">val</span> <span class="va">z</span> <span class="op">=</span> $tmp.component3()</a>
<a class="sourceLine" id="cb11-4" title="4">    ...</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="op">}</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>component1()</code> and <code>component3</code> are all suitable operator functions available on the value of lambda argument.</span></p>
</div>
</blockquote>
</body>
</html>
