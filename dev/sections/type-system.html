<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/css/main.css">
  <script src="../assets/js/katex/katex.min.js"></script><script src="../assets/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="../assets/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>


















<h2 id="type-system">Type system</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add examples)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add grammar snippets?)</span></p>
</div>
</div>
<h3 id="glossary-1">Glossary</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Cleanup)</span></p>
</div>
</div>
<dl>
<dt><span class="math inline">\(T\)</span></dt>
<dd><span class="sentence">Type</span>
</dd>
<dt><span class="math inline">\(T!!\)</span></dt>
<dd><span class="sentence">Non-nullable type</span>
</dd>
<dt><span class="math inline">\(T?\)</span></dt>
<dd><span class="sentence">Nullable type</span>
</dd>
<dt><span class="math inline">\(\{T!!\}\)</span></dt>
<dd><span class="sentence">Universe of non-nullable types</span>
</dd>
<dt><span class="math inline">\(\{T?\}\)</span></dt>
<dd><span class="sentence">Universe of nullable types</span>
</dd>
<dt><span class="math inline">\(\Gamma\)</span></dt>
<dd><span class="sentence">Type context</span>
</dd>
<dt><span class="math inline">\(T\lbrack S_1, \ldots, S_n\rbrack\)</span></dt>
<dd><span class="sentence">The result of type argument substitution for type <span class="math inline">\(T\)</span> with types <span class="math inline">\(S_i\)</span></span>
</dd>
<dt>Type parameter</dt>
<dd><span class="sentence">Formal type argument of parameterized type</span>
</dd>
<dt>Type argument</dt>
<dd><span class="sentence">Actual type argument in parameterized type constructor application</span>
</dd>
<dt>PACT</dt>
<dd><span class="sentence">Parameterized abstract classifier type</span>
</dd>
<dt>iPACT</dt>
<dd><span class="sentence">Instantiated parameterized concrete classifier type</span>
</dd>
</dl>
<h3 id="introduction-1">Introduction</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin has a type system with the following main properties.</span></p>
</div>
<ul>
<li><span class="sentence">Hybrid static and gradual type checking</span></li>
<li><span class="sentence">Null safety</span></li>
<li><span class="sentence">No unsafe implicit conversions</span></li>
<li><span class="sentence">Unified root type</span></li>
<li><span class="sentence">Nominal subtyping with bounded parametric polymorphism and mixed-site variance</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(static type checking, gradual type checking)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Null safety is enforced by having two type universes — <em>nullable</em> (with nullable types <span class="math inline">\(T?\)</span>) and <em>non-nullable</em> (with non-nullable types <span class="math inline">\(T!!\)</span>). </span><span class="sentence">All operations within the non-nullable type universe are safe, i.e., should never cause a runtime null pointer error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <a href="expressions-1.html#cast-expression-1">explicit cast</a>. </span><span class="sentence">However, Kotlin also supports smart casts — a special kind of implicit conversions which are safe w.r.t. program control- and data-flow, which are covered in more detail <a href="overload-resolution.html#smart-casts">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The unified supertype type for all types in Kotlin is <code>kotlin.Any?</code>, a nullable version of <a href="type-system.html#kotlin.any">kotlin.Any</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as <a href="type-system.html#generics">generics</a> via <a href="type-system.html#parameterized-classifier-types">parameterized types</a>. </span><span class="sentence">Subtyping between these parameterized types is defined through <a href="type-system.html#mixed-site-variance">mixed-site variance</a>.</span></p>
</div>
<h3 id="type-kinds">Type kinds</h3>
<div class="paragraph">
<p><span class="sentence">For the purposes of this section, we establish the following type kinds — different flavours of types which exist in the Kotlin type system.</span></p>
</div>
<ul>
<li><span class="sentence"><a href="type-system.html#built-in-types">Built-in types</a></span></li>
<li><span class="sentence"><a href="type-system.html#classifier-types">Classifier types</a></span></li>
<li><span class="sentence"><a href="type-system.html#function-types">Function types</a></span></li>
<li><span class="sentence"><a href="type-system.html#array-types">Array types</a></span></li>
<li><span class="sentence"><a href="type-system.html#flexible-types">Flexible types</a></span></li>
<li><span class="sentence"><a href="type-system.html#nullable-types">Nullable types</a></span></li>
<li><div class="TODO">
<span class="sentence">TODO(Intersection and union types)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(Error / invalid types)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">We distinguish between <em>concrete</em> and <em>abstract</em> types. </span><span class="sentence">Concrete types are types which are assignable to values; abstract types either need to be instantiated as concrete types before they can be used as value types, or are used internally by the type system and are not directly denotable.</span></p>
</div>
<h4 id="built-in-types">Built-in types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).</span></p>
</div>
<h5 id="kotlin.any"><code>kotlin.Any</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Any</code> is the unified supertype (<span class="math inline">\(\top\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., all non-nullable types are subtypes of <code>kotlin.Any</code>, either explicitly, implicitly, or by subtyping relation.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>kotlin.Any</code> members?)</span></p>
</div>
</div>
<h5 id="kotlin.nothing"><code>kotlin.Nothing</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Nothing</code> is the unified subtype (<span class="math inline">\(\bot\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., <code>kotlin.Nothing</code> is a subtype of all non-nullable types, including user-defined ones. </span><span class="sentence">This makes it an uninhabited type (as it is impossible for anything to be, for example, a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of <code>kotlin.Nothing</code> in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As the evaluation of an expression with <code>kotlin.Nothing</code> type can never complete normally, it is used to mark special situations, such as:</span></p>
</div>
<ul>
<li><span class="sentence">non-terminating expressions</span></li>
<li><span class="sentence">exceptional control flow</span></li>
<li><span class="sentence">control flow transfer</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Additional details about how <code>kotlin.Nothing</code> should be processed are available [here][Control- and data-flow analysis].</span></p>
</div>
<h5 id="kotlin.unit"><code>kotlin.Unit</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Unit</code> is a unit type, i.e., a type with only one value <code>kotlin.Unit</code>; all values of type <code>kotlin.Unit</code> should reference the same underlying <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Compare to <code>void</code>?)</span></p>
</div>
</div>
<h4 id="classifier-types">Classifier types</h4>
<div class="paragraph">
<p><span class="sentence">Classifier types represent regular types which are declared as [classes][Classes], [interfaces][Interfaces] or [objects][Objects]. </span><span class="sentence">As Kotlin supports <a href="type-system.html#generics">generics</a>, there are two variants of classifier types: simple and parameterized.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(No objects as supertypes?)</span></p>
</div>
</div>
<h5 id="simple-classifier-types">Simple classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A simple concrete classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid simple concrete classifier type, <span class="math inline">\(T : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,m]: S_i\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<h5 id="parameterized-classifier-types">Parameterized classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A parameterized abstract classifier type (PACT)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T(F_1, \ldots, F_n) : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type constructor <span class="math inline">\(T\)</span> which takes type arguments and returns an instantiated type</span></li>
<li><span class="sentence">type parameters <span class="math inline">\(F_1, \ldots, F_n\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid PACT, <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: F_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">[unbounded type parameter][Unbounded type parameters]</span></li>
<li><span class="sentence">[projected type parameter][Projected type parameters]</span></li>
<li><span class="sentence"><a href="type-system.html#bounded-type-parameters">bounded type parameter</a></span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(\forall j \in [1,m]: S_j[F_1, \ldots, F_n]\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An instantiated parameterized concrete classifier type (iPACT)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T[A_1, \ldots, A_n]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type arguments <span class="math inline">\(A_1, \ldots, A_n\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid iPACT, <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid PACT with <span class="math inline">\(n\)</span> type parameters</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">valid concrete type</span></li>
<li><span class="sentence">valid projected type</span></li>
<li><span class="sentence">type parameter available in the current type context <span class="math inline">\(\Gamma\)</span><br />
TODO(What is a type context?)<br />
TODO(Inner vs nested contexts)</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i &lt;: F_i\)</span> where <span class="math inline">\(F_i\)</span> is the respective type parameter of <span class="math inline">\(T\)</span></span></li>
</ul>
<h5 id="type-parameters">Type parameters</h5>
<div class="paragraph">
<p><span class="sentence">Type parameters are a special kind of abstract types, which are introduced by PACTs. </span><span class="sentence">They are valid only in the context of their declaring PACT.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When creating an iPACT from PACT, type parameters with their respective type arguments go through <a href="type-system.html#type-capturing">capturing</a> and create <em>captured</em> type arguments, which follow special rules described in more detail below.</span></p>
</div>
<h6 id="bounded-type-parameters">Bounded type parameters</h6>
<div class="paragraph">
<p><span class="sentence">A bounded type parameter is an abstract type which is used to specify upper type bounds for type parameters and is defined as <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span>, where <span class="math inline">\(B_i\)</span> is an i-th upper bound on type parameter <span class="math inline">\(F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid bounded type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: B_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Single generic bound allowed)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Only one class bound allowed)</span></p>
</div>
</div>
<h6 id="mixed-site-variance">Mixed-site variance</h6>
<div class="paragraph">
<p><span class="sentence">To implement subtyping between parameterized types, Kotlin uses <em>mixed-site variance</em> — a combination of declaration- and use-site variance, which is easier to understand and reason about, compared to wildcards from Java. </span><span class="sentence">Mixed-site variance means you can specify, whether you want your parameterized type to be co-, contra- or invariant on some type parameter, both in type parameter (declaration-site) and type argument (use-site). </span><span class="sentence">For more practical discussion about mixed-site variance, we readdress you to <a href="type-system.html#generics">generics</a>.</span></p>
</div>
<h6 id="declaration-site-variance">Declaration-site variance</h6>
<div class="paragraph">
<p><span class="sentence">An invariant type parameter <span class="math inline">\(F\)</span> is an abstract type which may capture any valid type (see <a href="type-system.html#subtyping">subtyping</a> for more details on variance); if one needs co- or contravariant type parameter, they need to use projected type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid invariant type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Projected type parameters are abstract types which are used to declare a type parameter as <em>covariant</em> or <em>contravariant</em>. </span><span class="sentence">The variance information is used by <a href="type-system.html#subtyping">subtyping</a> and for checking allowed operations on values of co- and contravariant type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid covariant type parameter <span class="math inline">\(\triangleleft F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid contravariant type parameter <span class="math inline">\(\triangleright F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(type projections are not allowed on functions and properties)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(no type projections on supertype type arguments)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(conflicting projections)</span></p>
</div>
</div>
<h6 id="use-site-variance">Use-site variance</h6>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports use-site variance, by specifying the variance for type arguments. </span><span class="sentence">Just like with projected type parameters, one can have projected type arguments being co-, contra- or invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid invariant type argument of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid covariant type argument <span class="math inline">\(\triangleleft A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid contravariant type argument <span class="math inline">\(\triangleright A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In case one cannot specify any valid type argument, but still needs to use PACT in a type-safe way, one may use <em>star-projected</em> type argument, which is roughly equivalent to a combination of <span class="math inline">\(\triangleleft \texttt{kotlin.Any?}\)</span> and <span class="math inline">\(\triangleright \texttt{kotlin.Nothing}\)</span> (for further details, see <a href="type-system.html#generics">here</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clean-up this mess)</span></p>
</div>
</div>
<h5 id="type-capturing">Type capturing</h5>
<div class="paragraph">
<p><span class="sentence">Type capturing (similarly to Java capturing conversion) is used when instantiating parameterized types; it creates <em>captured</em> types based on the type information of both type parameters and arguments, which present a unified view on the resulting types and simplifies further reasoning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For a given PACT <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span>, its iPACT <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> uses the following rules to create captured type <span class="math inline">\(C_i\)</span> from the type parameter <span class="math inline">\(F_i\)</span> and type argument <span class="math inline">\(A_i\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Does this set describe a type universe?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Blah-blah about existential types?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">NB: A captured type <span class="math inline">\(C\)</span> may be viewed as a set of its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence"><strong>All</strong> applicable rules are used to create the resulting constraint set.</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">If <span class="math inline">\(\triangleleft F_i\)</span> is a covariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, covariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i &lt;: A_i\)</span>.</span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleright F_i\)</span> is a contravariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, contravariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i :&gt; A_i\)</span>.</span></li>
<li><span class="sentence">If <span class="math inline">\(F_i &lt;: B_1, \ldots, B_n\)</span> is a bounded type parameter, <span class="math inline">\(C_i &lt;: B_i[C_1, \ldots, C_n]\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleleft A_i\)</span> is a covariant type argument, <span class="math inline">\(C_i &lt;: A_i\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleright A_i\)</span> is a contravariant type argument, <span class="math inline">\(C_i :&gt; A_i\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\star A_i\)</span> is a star-projected type argument, <span class="math inline">\(kotlin.Nothing &lt;: C_i &lt;: kotlin.Any?\)</span></span></li>
<li><span class="sentence">Otherwise, <span class="math inline">\(C_i = A_i\)</span></span></li>
</ul>
<h4 id="function-types">Function types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Everything…)</span></p>
</div>
</div>
<h4 id="array-types">Array types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Everything…)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Primitive type array coercion)</span></p>
</div>
</div>
<h4 id="flexible-types">Flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin, being a multi-platform language, needs to support transparent interoperability with platform-dependent code. </span><span class="sentence">However, this presents a problem in that some platforms may not support null safety the way Kotlin does. </span><span class="sentence">To deal with this, Kotlin supports <em>gradual typing</em> in the form of flexible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A flexible type represents a range of possible types between type <span class="math inline">\(L\)</span> (lower bound) and type <span class="math inline">\(U\)</span> (upper bound), written as <span class="math inline">\((L..U)\)</span>. </span><span class="sentence">One should note flexible types are abstract and <em>non-denotable</em>, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid flexible type, <span class="math inline">\((L..U)\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are valid concrete types</span></li>
<li><span class="sentence"><span class="math inline">\(L &lt;: U\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\neg (L &lt;: U)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are <strong>not</strong> flexible types (but may contains other flexible types as part of their type signature)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As the name suggests, flexible types are flexible — a value of type <span class="math inline">\((L..U)\)</span> can be used in any context, where one of the possible types between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> is needed (for more details, see <a href="type-system.html#subtyping">subtyping rules for flexible types</a>). </span><span class="sentence">However, the actual type will be a specific type between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>, thus making the substitution possibly unsafe, which is why Kotlin generates dynamic assertions, when it is impossible to prove statically the safety of flexible type use.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Details of assertion generation?)</span></p>
</div>
</div>
<h5 id="platform-types">Platform types</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Platform types as flexible types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Reference for different platforms)</span></p>
</div>
</div>
<h4 id="nullable-types">Nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports null safety by having two type universes — nullable and non-nullable. </span><span class="sentence">All classifier type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold <code>null</code> value at runtime.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a nullable version of type <code>T</code>, one needs to use <code>T?</code> as a type. </span><span class="sentence">Redundant nullability specifiers are ignored — <code>T???</code> is equivalent to <code>T?</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally, question mark means “<span class="math inline">\(T?\)</span> may hold values of type <span class="math inline">\(T\)</span> or value <code>null</code>”</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">To represent a valid nullable type, <span class="math inline">\(T?\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If an operation is safe regardless of absence or presence of <code>null</code>, i.e., assignment of one nullable value to another, it can be used as-is for nullable types. </span><span class="sentence">For operations on <span class="math inline">\(T?\)</span> which may violate null safety, one has the following null-safe options:</span></p>
</div>
<ol type="1">
<li><span class="sentence">Use safe operations</span>
<ul>
<li><span class="sentence"><a href="expressions-1.html#safe-call-expression-1">safe call</a></span></li>
</ul></li>
<li><span class="sentence">Downcast from <span class="math inline">\(T?\)</span> to <span class="math inline">\(T!!\)</span></span>
<ul>
<li><span class="sentence"><a href="expressions-1.html#cast-expression-1">unsafe cast</a></span></li>
<li><span class="sentence"><a href="expressions-1.html#type-check-expression-1">type check</a> combined with <a href="overload-resolution.html#smart-casts">smart casts</a></span></li>
<li><span class="sentence">null check combined with <a href="overload-resolution.html#smart-casts">smart casts</a></span></li>
<li><span class="sentence">[not-null assertion operator][Not-null assertion operator expression]</span></li>
</ul></li>
<li><span class="sentence">Supply a default value to use instead of <code>null</code></span>
<ul>
<li><span class="sentence"><a href="expressions-1.html#elvis-operator-expression-1">elvis operator</a></span></li>
</ul></li>
</ol>
<h3 id="subtyping">Subtyping</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin uses the classic notion of <em>subtyping</em> as <em>substitutability</em> — if <span class="math inline">\(S\)</span> is a subtype of <span class="math inline">\(T\)</span> (denoted as <span class="math inline">\(S &lt;: T\)</span>), values of type <span class="math inline">\(S\)</span> can be safely used where values of type <span class="math inline">\(T\)</span> are expected. </span><span class="sentence">The subtyping relation <span class="math inline">\(&lt;:\)</span> is:</span></p>
</div>
<ul>
<li><span class="sentence">reflexive (<span class="math inline">\(A &lt;: A\)</span>)</span></li>
<li><span class="sentence">transitive (<span class="math inline">\(A &lt;: B \land B &lt;: C \Rightarrow A &lt;: C\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equivalent</em> (<span class="math inline">\(A \equiv B\)</span>), iff <span class="math inline">\(A &lt;: B \land B &lt;: A\)</span>. </span><span class="sentence">Due to the presence of flexible types, this relation is <strong>not</strong> transitive (see <a href="type-system.html#subtyping-for-flexible-types">here</a> for more details).</span></p>
</div>
<h4 id="subtyping-rules">Subtyping rules</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, concrete types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any simple classifier type <span class="math inline">\(T : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: T &lt;: S_i\)</span></span></li>
<li><span class="sentence">For any iPACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n)[A_1, \ldots, A_n] : S_1, \ldots, S_m\)</span> with captured type arguments <span class="math inline">\(C_1, \ldots, C_n\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i[C_1, \ldots, C_n]\)</span></span></li>
<li><span class="sentence">For any two iPACTs <span class="math inline">\(\widehat{T}\)</span> and <span class="math inline">\(\widehat{T^\prime}\)</span> with captured type arguments <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: C_i &lt;: C_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, abstract types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any PACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Subtyping for type parameters)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, captured types uses rules of different kind, as captured type <span class="math inline">\(C\)</span> describes not one, but a set of types which satisfy its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence">Therefore, we use the following subtyping rules for captured types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall C : \text{kotlin.Nothing} &lt;: C &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any two captured types <span class="math inline">\(C\)</span> and <span class="math inline">\(C^\prime\)</span>, <span class="math inline">\(C &lt;: C^\prime\)</span> if <span class="math inline">\(\forall T : \mathbb{C}(T) \Rightarrow \mathbb{C^\prime}(T)\)</span> (i.e., a set of types for <span class="math inline">\(C\)</span> is a subset of a set of types for <span class="math inline">\(C^\prime\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for nullable types is checked separately and uses a special set of rules which are described <a href="type-system.html#subtyping-for-nullable-types">here</a>.</span></p>
</div>
<h4 id="subtyping-for-flexible-types">Subtyping for flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Flexible types (being flexible) follow a simple subtyping relation with other inflexible types. </span><span class="sentence">Let <span class="math inline">\(T, A, B, L, U\)</span> be inflexible types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: T \Rightarrow (L..U) &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(T &lt;: U \Rightarrow T &lt;: (L..U)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This captures the notion of flexible type <span class="math inline">\((L..U)\)</span> as something which may be used in place of any type in between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>. </span><span class="sentence">If we are to extend this idea to subtyping between <em>two</em> flexible types, we get the following definition.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: B \Rightarrow (L..U) &lt;: (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This is the most extensive definition possible, which, unfortunately, makes the type equivalence relation non-transitive. </span><span class="sentence">Let <span class="math inline">\(A, B\)</span> be two <em>different</em> types, for which <span class="math inline">\(A &lt;: B\)</span>. </span><span class="sentence">The following relations hold:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A &lt;: (A..B) \land (A..B) &lt;: A \Rightarrow A \equiv (A..B)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: (A..B) \land (A..B) &lt;: B \Rightarrow B \equiv (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, <span class="math inline">\(A \not \equiv B\)</span>.</span></p>
</div>
<h4 id="subtyping-for-nullable-types">Subtyping for nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is defined via <em>two</em> relations, both of which must hold.</span></p>
</div>
<ul>
<li><span class="sentence">Regular subtyping <span class="math inline">\(&lt;:\)</span> for non-nullable types <span class="math inline">\(A!!\)</span> and <span class="math inline">\(B!!\)</span></span></li>
<li><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span> for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A!! \stackrel{null}{&lt;:}B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\exists T!! : A &lt;: T!!\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B?\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\not \exists T!! : B &lt;: T!!\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(How the existence check works)</span></p>
</div>
</div>
<h3 id="generics">Generics</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Here be a lot of dragons…)</span></p>
</div>
</div>
<h3 id="references">References</h3>
<ol type="1">
<li><span class="sentence">Tate, Ross. </span><span class="sentence">“Mixed-site variance.” FOOL, 2013. </span><span class="sentence">## Declarations</span></li>
</ol>
<h3 id="glossary-2">Glossary</h3>
<dl>
<dt>Entity</dt>
<dd><span class="sentence">A distinguishable part of a program</span>
</dd>
</dl>
<h3 id="introduction-2">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e. they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] (<code>class</code> | <code>interface</code>) {<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <em>typeParameters</em>] [{<em>NL</em>} <em>primaryConstructor</em>]<br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>classBody</em> | {<em>NL</em>} <em>enumClassBody</em>]</span>
</dd>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] <code>object</code><br />
{<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>classBody</em>]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Classifier declarations introduce new types to the program, of the forms described <a href="type-system.html#classifier-types">here</a>. </span><span class="sentence">There are three kinds of classifier declarations:</span></p>
</div>
<ul>
<li><span class="sentence">class declarations</span></li>
<li><span class="sentence">interface declarations</span></li>
<li><span class="sentence">object declarations</span></li>
</ul>
<h4 id="class-declaration">Class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A simple class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a simple classifier type <span class="math inline">\(c : S_1, \ldots, S_s\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Supertype specifiers are used to create inheritance relation between the declared type and the specified supertype. </span><span class="sentence">You can use classes and interfaces as supertypes, but not objects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is allowed to inherit from a single class only, i.e., multiple class inheritance is not supported. </span><span class="sentence">Multiple interface inheritance is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Instance initialization block describes a block of code which should be executed during <a href="type-system.html#classifier-initialization">object creation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Property and function declarations in the class body introduce their respective entities in this class’ scope, meaning they are available only on an entity of the corresponding class.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Companion object declaration <code>companion object CO { ... }</code> for class <code>C</code> introduces an object, which is available under this class’ name or under the reference <code>C.CO</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Nested classifier declaraions)</span></p>
</div>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="al">TODO(Examples)</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">A parameterized class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple class declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="type-system.html#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h5 id="constructor-declaration">Constructor declaration</h5>
<div class="paragraph">
<p><span class="sentence">There are two types of class constructors in Kotlin: primary and secondary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary constructor is a concise way of describing class properties together with constructor parameters, and has the following form</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[ptor : (p_1, \ldots, p_n)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where each of <span class="math inline">\(p_i\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">regular constructor parameter <span class="math inline">\(name: type\)</span></span></li>
<li><span class="sentence">read-only property constructor parameter <span class="math inline">\(val name: type\)</span></span></li>
<li><span class="sentence">mutable property constructor parameter <span class="math inline">\(var name: type\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Property constructor parameters, together with being regular constructor parameters, also declare class properties of the same name and type. </span><span class="sentence">One can consider them to have the following syntactic expansion.</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">d</span>: <span class="dt">Double</span>, <span class="kw">var</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d</span>, <span class="va">s</span>) {}</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">class</span> FooEx(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">d_</span>: <span class="dt">Double</span>, <span class="va">s_</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d_</span>, <span class="va">s_</span>) {</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">val</span> <span class="va">d</span> = d_</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">var</span> <span class="va">s</span> = s_</a>
<a class="sourceLine" id="cb2-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">When accessing property constructor parameters inside the class body, one works with their corresponding properties; however, when accessing them in the supertype specifier list (e.g., as an argument to a superclass constructor invocation), we see them as actual parameters, which cannot be changed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class declaration has a primary constructor and also includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A secondary constructor describes an alternative way of creating a class instance and has only regular constructor parameters. </span><span class="sentence">If a class has a primary constructor, any secondary constructor must delegate to either the primary constructor or to another secondary constructor via <code>this(...)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have a primary constructor, its secondary constructors must delegate to either the superclass constructor via <code>super(...)</code> (if the superclass is present in the supertype specifier list) or to another secondary constructor via <code>this(...)</code>. </span><span class="sentence">If the only superclass is <code>Any</code>, delegation is optional.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In all cases, it is forbidden if two or more secondary constructors form a delegation loop.</span></p>
</div>
<h5 id="nested-and-inner-classes">Nested and inner classes</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h5 id="inheritance-delegation">Inheritance delegation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="data-class-declaration">Data class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A data class <span class="math inline">\(dataClass\)</span> is a special kind of class, which represents a product type constructed from a number of data properties <span class="math inline">\((dp_1, \ldots, dp_m)\)</span>, described in its primary constructor. </span><span class="sentence">As such, it allows Kotlin to reduce the boilerplate and generate a number of additional data-relevant functions.</span></p>
</div>
<ul>
<li><span class="sentence"><code>equals() / hashCode() / toString()</code> functions compliant with their contracts</span></li>
<li><span class="sentence">A <code>copy()</code> function for shallow object copying</span></li>
<li><span class="sentence">A number of <code>componentN()</code> functions for destructive declaration</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All these functions consider only data properties <span class="math inline">\(\{dp_i\}\)</span>; e.g., your data class may include regular property declarations in its body, however, they will <em>not</em> be considered in the <code>equals()</code> implementation or have a <code>componentN()</code> generated for them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To support these features, data classes have the following restrictions.</span></p>
</div>
<ul>
<li><span class="sentence">Data classes are final and cannot be inherited from</span></li>
<li><span class="sentence">Data classes must have a primary constructor with only property constructor parameters, which become data properties for the data class</span></li>
</ul>
<h5 id="data-class-generation">Data class generation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(A more detailed explaination)</span></p>
</div>
</div>
<h4 id="enum-class-declaration">Enum class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="annotation-class-declaration">Annotation class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="interface-declaration">Interface declaration</h4>
<div class="paragraph">
<p><span class="sentence">Interfaces differ from classes in that they cannot be directly instantiated in the program, they are meant as a way of describing a contract which should be satisfied by the interface’s subtypes. </span><span class="sentence">In other aspects they are similar to classes, therefore we shall specify their declarations by specifying their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An interface cannot have a class as its supertype</span></li>
<li><span class="sentence">An interface cannot have a constructor</span></li>
<li><span class="sentence">Interface properties cannot have initializers</span></li>
<li><span class="sentence">All interface members must be public</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="object-declaration">Object declaration</h4>
<div class="paragraph">
<p><span class="sentence">Object declarations are used to support a singleton pattern and, thus, do two things at the same time. </span><span class="sentence">One, they (just like class declarations) introduce a new type to the program. </span><span class="sentence">Two, they create a singleton-like object of that type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Similarly to interfaces, we shall specify object declarations by highlighting their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An object type cannot be used as a supertype for other types</span></li>
<li><span class="sentence">An object cannot have a constructor</span></li>
<li><span class="sentence">An object cannot be parameterized, i.e., cannot have type parameters</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="anonymous-object-declaration">Anonymous object declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h4 id="classifier-initialization">Classifier initialization</h4>
<div class="paragraph">
<p><span class="sentence">When creating a class or object instance via one of its constructors <span class="math inline">\(ctor\)</span>, it is initialized in a particular order, which we describe here.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">First, a supertype constructor corresponding to <span class="math inline">\(ctor\)</span> is called with its respective parameters.</span></p>
</div>
<ul>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a primary constructor, a corresponding supertype constructor is the one from the supertype specifier list</span></li>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a secondary constructor, a corresponding supertype constructor is the one ending the constructor delegation chain of <span class="math inline">\(ctor\)</span></span></li>
<li><span class="sentence">If an explicit supertype constructor is not available, <code>Any()</code> is implicitly used</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">After the supertype initialization is done, we continue the initialization by processing each inner declaration in its body, <em>in the order of their inclusion in the body</em>. </span><span class="sentence">If any initialization step creates a loop, it is considered an undefined behavior.</span></p>
</div>
<h3 id="function-declaration">Function declaration</h3>
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>]<br />
<code>fun</code><br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>] ({<em>NL</em>} <em>simpleIdentifier</em>)<br />
{<em>NL</em>} <em>functionValueParameters</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>functionBody</em>]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Function declarations assign names to such entities as functions — blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail <a href="type-system.html#function-types">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A simple function declaration consists of four main parts</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a function type <span class="math inline">\(f : (P_1, \ldots, P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span> describes function parameters — inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>; therefore, parameters are final and cannot be changed inside the function. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> should be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Return type <span class="math inline">\(R\)</span> is optional, if function body <span class="math inline">\(b\)</span> is present and may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv kotlin.Nothing\)</span>, in which case <span class="math inline">\(R \equiv B\)</span>. </span><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> must be specified explicitly.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As type <span class="math inline">\(kotlin.Nothing\)</span> has a <a href="type-system.html#kotlin.nothing">special meaning</a> in Kotlin type system, it must be specified explicitly, to avoid spurious <span class="math inline">\(kotlin.Nothing\)</span> function return types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is ommited, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="type-system.html#classifier-declaration">abstract classifier declaration</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized function declaration consists of five main parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple function declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="type-system.html#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h4 id="named-positional-and-default-parameters">Named, positional and default parameters</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>named</em> parameters out-of-the-box, meaning one can bind an argument to a parameter in function invocation not by its position, but by its name, which is equal to the argument name.</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Double</span>, <span class="va">s</span>: <span class="dt">String</span>): <span class="dt">Double</span> = a + b + s.toDouble()</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb3-4" title="4">    println(bar(b = <span class="fl">42.0</span>, a = <span class="dv">5</span>, s = <span class="st">&quot;13&quot;</span>))</a>
<a class="sourceLine" id="cb3-5" title="5">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Argument names are resolved in compile time)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If one wants to mix named and positional arguments, the argument list must conform to the following form: <span class="math inline">\(P_1, \ldots, P_M, N_1, \ldots, N_Q\)</span>, where <span class="math inline">\(P_i\)</span> is a positional argument, <span class="math inline">\(N_j\)</span> is a named argument; i.e., positional arguments must precede all of the named ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports <em>default</em> parameters — parameters which have a default value used in function invocation, if the corresponding argument is missing. </span><span class="sentence">Note that default parameters cannot be used to provide a value for positional argument <em>in the middle</em> of the positional argument list; allowing this would create an ambiguity of which argument for position <span class="math inline">\(i\)</span> is the correct one: explicit one provided by the developer or implicit one from the default value.</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span> = 1, <span class="va">b</span>: <span class="dt">Double</span> = 42.0, <span class="va">s</span>: <span class="dt">String</span> = <span class="st">&quot;Hello&quot;</span>): <span class="dt">Double</span> =</a>
<a class="sourceLine" id="cb4-2" title="2">    a + b + s.toDouble()</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="co">// Valid call, all default parameters used</span></a>
<a class="sourceLine" id="cb4-6" title="6">    println(bar())</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="co">// Valid call, defaults for `b` and `s` used</span></a>
<a class="sourceLine" id="cb4-8" title="8">    println(bar(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="co">// Valid call, default for `b` used</span></a>
<a class="sourceLine" id="cb4-10" title="10">    println(bar(<span class="dv">2</span>, s = <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="co">// Invalid call, default for `b` cannot be used</span></a>
<a class="sourceLine" id="cb4-13" title="13">    println(bar(<span class="dv">2</span>, <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb4-14" title="14">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">In summary, argument list should have the following form:</span></p>
</div>
<ul>
<li><span class="sentence">Zero or more positional arguments</span></li>
<li><span class="sentence">Zero or more named arguments</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Missing arguments are bound to their default values.</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
<p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as an <a href="type-system.html#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments. </span><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to an <a href="type-system.html#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An array of type <span class="math inline">\(Q &lt;: P_i\)</span> may be <em>unpacked</em> to a variable length parameter in function invocation using <a href="expressions-1.html#spread-operator-1">spread operator</a>; in this case array elements are considered to be separate arguments in the variable length parameter position. </span><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="function-type-parameters">Function type parameters</h4>
<div class="paragraph">
<p><span class="sentence">Some parameters may have <a href="type-system.html#function-types">function types</a>, as Kotlin supports first-class functions. </span><span class="sentence">Function type parameters do not have any special treatment on the function declaration side, however, there are some special cases on the invocation side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Function type parameter may bind to an argument of the following kinds - [callable reference][Callable references] - <a href="expressions-1.html#anonymous-function-declarations-1">anonymous function</a> - <a href="expressions-1.html#lambda-literals-1">lambda literal</a> Iff we use a lambda literal for the <strong>last</strong> parameter in the parameter list, it can be written outside the argument list, as in this example.</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Int</span>, <span class="va">f</span>: (<span class="dt">Int</span>, <span class="dt">Int</span>) -&gt; <span class="dt">String</span>): <span class="dt">String</span> = f(a, b)</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Int</span>) = foo(a, b) { a, b -&gt; <span class="st">&quot;${a + b}&quot;</span> }</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Describe possible ambiguities?)</span></p>
</div>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h4 id="anonymous-function-declaration">Anonymous function declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="property-declaration">Property declaration</h3>
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] (<code>val</code> | <code>var</code>)<br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>]<br />
({<em>NL</em>} (<em>multiVariableDeclaration</em> | <em>variableDeclaration</em>))<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} (<code>by</code> | <code>=</code>) {<em>NL</em>} <em>expression</em>]<br />
[NL+ <code>;</code>] {<em>NL</em>} [[<em>getter</em>] ({<em>NL</em>} [<em>semi</em>] <em>setter</em>] | [<em>setter</em>] [{<em>NL</em>} [<em>semi</em>] <em>getter</em>])</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter — functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>. </span><span class="sentence">Both the right-hand value <code>e</code> and the type <code>T</code> are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if the type of <code>e</code> cannot be [inferred][Type inference], the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see <a href="type-system.html#subtyping">subtyping</a> for more details).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration may include a custom <a href="type-system.html#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation.</span></p>
</div>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration may include a custom <a href="type-system.html#getters-and-setters">getter</a> and/or custom <a href="type-system.html#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code>. </span><span class="sentence">One may view these properties as regular properties with a special <em>delegating</em> <a href="type-system.html#getters-and-setters">getters</a>. </span><span class="sentence">TODO(Type is optional if inferred?)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In case of a delegated read-only property, access to <code>x</code> is replaced with the call to a special function <code>getValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">getValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>): <span class="dt">R</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
<ul>
<li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
<li><span class="sentence">is <code>null</code> for <a href="type-system.html#local-property-declaration">local properties</a></span></li>
</ul></li>
<li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
<ul>
<li><span class="sentence"><code>property.name</code> holds the property name</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This convention implies the following requirements on the <code>getValue</code> function</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
<li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="type-system.html#getters-and-setters">getters and setters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read access is handeled using the same <code>getValue</code> function as for a delegated read-only property. </span><span class="sentence">Write access is processed using a special function <code>setValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">setValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>, <span class="va">value</span>: <span class="dt">R</span>): <span class="dt">U</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
<ul>
<li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
<li><span class="sentence">is <code>null</code> for <a href="type-system.html#local-property-declaration">local properties</a></span></li>
</ul></li>
<li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
<ul>
<li><span class="sentence"><code>property.name</code> holds the property name</span></li>
</ul></li>
<li><span class="sentence"><code>value: R</code> is the new property value</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This convention implies the following requirements on the <code>setValue</code> function</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
<li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(U\)</span> is ignored</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The delegated property is expanded as follows.</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co"> * Actual code</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="kw">var</span> <span class="va">prop</span>: Type <span class="kw">by</span> DelegateExpression</a>
<a class="sourceLine" id="cb10-6" title="6">}</a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">/*</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="co"> * Expanded code</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb10-12" title="12">    <span class="kw">private</span> <span class="kw">val</span> <span class="va">prop</span>$delegate = DelegateExpression</a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="kw">var</span> <span class="va">prop</span>: Type</a>
<a class="sourceLine" id="cb10-14" title="14">        <span class="kw">get</span>() = prop$delegate.getValue(<span class="kw">this</span>, <span class="kw">this</span>::prop)</a>
<a class="sourceLine" id="cb10-15" title="15">        <span class="kw">set</span>(value: Type) = prop$delegate.setValue(<span class="kw">this</span>, <span class="kw">this</span>::prop, value)</a>
<a class="sourceLine" id="cb10-16" title="16">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(provideDelegate)</span></p>
</div>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
<p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Local property declarations also support <em>destructive</em> declaration in the form of</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">which is a syntactic sygar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb12-4" title="4">...</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Each individual component property follows the rules for regular local property declaration.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
<p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">set</span>(anyValidArgumentName: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">Both <span class="math inline">\(TG\)</span> and <span class="math inline">\(TG\)</span> types are optional and may be omitted from the declaration</span></p>
</div></li>
<li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter</span></li>
<li><div class="paragraph">
<p><span class="sentence">Mutable properties may have any combination of a cusom getter and a custom setter</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Setter argument may have any valid argument name</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can also ommit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the property’s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
<li><span class="sentence">For a property declaration of type <code>T</code>, field<code>has the same type</code>T`</span></li>
<li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
<li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
<li><span class="sentence">A property has no custom accessors</span></li>
<li><span class="sentence">A property has a default accessor</span></li>
<li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property</span></li>
<li><span class="sentence">A mutable property has a custom getter or setter, but not both</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In all other cases a property has no backing field.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
<p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail [here][Control- and data-flow analysis].</span></p>
</div>
<h3 id="type-alias">Type alias</h3>
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] <code>typealias</code> {<em>NL</em>} <em>simpleIdentifier</em> [{<em>NL</em>} <em>typeParameters</em>] {<em>NL</em>} <code>=</code> {<em>NL</em>} <em>type</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be <a href="type-system.html#type-parameters">unbounded</a>. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden — the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its <a href="visibility.html#visibility"><em>visibility modifiers</em></a>.</span></p>
</div>
<h3 id="declarations-with-type-parameters">Declarations with type parameters</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="declaration-modifiers">Declaration modifiers</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(declaration scope)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(open)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(abstract)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(lateinit)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(const) ## Inheritance</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…) ## Scopes and identifiers</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">All the program code in Kotlin is logically divided into <em>scopes</em>. </span><span class="sentence">A scope is a syntactically-delimited region of code that constitutes a context in which entities and their names can be introduced. </span><span class="sentence">Scopes are nested, with entities introduced in outer scopes also available in the inner scopes. </span><span class="sentence">The top level of a Kotlin file is also a scope, containing all the scopes within the file.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All the scopes are divided into two categories: declaration scopes and statement scopes. </span><span class="sentence">These two kinds of scopes differ in how the identifiers in code refer to the values definied in the scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declaration scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a normal Kotlin file (not script file);</span></li>
<li><span class="sentence">The bodies of <a href="type-system.html#classifier-declaration">classifier declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="expressions-1.html#object-literals-1">object literals</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Statement scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a Kotlin script file;</span></li>
<li><span class="sentence">Various scopes produced by control structure bodies of different <a href="expressions-1.html#expressions-1">expressions</a>;</span></li>
<li><span class="sentence">The bodies of <a href="type-system.html#function-declaration">function declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="expressions-1.html#anonymous-function-declarations-1">anonymous function literals</a>;</span></li>
<li><span class="sentence">The bodies of getters and setters of <a href="type-system.html#property-declaration">properties</a>;</span></li>
<li><span class="sentence">The bodies of <a href="type-system.html#constructor-declaration">constructors</a>;</span></li>
<li><span class="sentence">The bodies of instance initialization blocks in <a href="type-system.html#class-declaration">class declarations</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All the declarations in a particular scope introduce new <em>bindings</em> of identifiers in this scope to their respective entities in the program. </span><span class="sentence">These entities may be types or values, where values may refer to objects, functions or properties (that may be delegated). </span><span class="sentence">Top-level scopes additionally allow to introduce such bindings using <a href="packages-and-imports.html#packages-and-imports"><code>import</code> directive</a> from other top-level scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In most situations, it is not allowed to bind several values to the same identifier in the same scope, but it is allowed to bind a value to an identifier already available in the scope through outer scopes or imports. </span><span class="sentence">An exception to this rule are function declarations, that, in addition to identifier bound to, also may differ by signature <span><span class="TODO">(TODO: what’s a signature?)</span><span class="TODO-marker">*</span></span> and allow definining several functions with the same name in the same scope. </span><span class="sentence">When <a href="expressions-1.html#call-and-property-access-expressions-1">calling functions</a> a process called <a href="overload-resolution.html#overload-resolution">overloading resolution</a> takes places that allows differentiating such functions. </span><span class="sentence">Overloading resolution also applies to properties if they are used as functions through <code>invoke</code>-convention, but it does not mean several properties with the same name may be defined in the same scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between declaration scopes and statement scopes is that names in the statement scope are bound in the order their declarations appear in it. </span><span class="sentence">It is not allowed to access a value through an identifier in the code that (syntactically) precedes the binding itself. </span><span class="sentence">On the contrary, in declaration scopes it is fully allowed, although initialization cycles may occur and need to be detected by the compiler. </span><span class="sentence">It also means that the statement scopes nested inside declaration scopes may access values declared after itself in the declaration scopes, but any values defined inside the statement scope must be accessed only after they are declared.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">In declaration scope:</span></p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" title="1">    <span class="co">// x refers to the property defined below even if there is another property</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="co">// called x in outer scope or imported</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">In statement scope:</span></p>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" title="1">    <span class="co">// x either refers to other property defined in some outer scope or imported</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="co">// or it is a compile-time error</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: please note that all the above is primarily applied to declarations, because declaration scopes do not allow standalone statements to appear in them</span></p>
</div>
</blockquote>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(qualified names?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(extensions?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(receivers)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(rewrite expressions and statements as references to this part)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(identifier lifetime &amp; such)</span>
</div></li>
</ul>
</body>
</html>
