<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/css/main.css">
  <script src="../assets/js/katex/katex.min.js"></script><script src="../assets/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="../assets/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>


















<h2 id="overload-resolution">Overload resolution</h2>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>function overloading</em>, that is, the ability for several functions of the same name to coexist in the same scope, with the compiler picking the most suitable one when such a function is called. </span><span class="sentence">This section describes this mechanism in detail.</span></p>
</div>
<h3 id="intro">Intro</h3>
<div class="paragraph">
<p><span class="sentence">Unlike other object-oriented languages, Kotlin does not only have object methods, but also top-level functions, local functions, extension functions and function-like values, which complicates the overloading process quite a lot. </span><span class="sentence">Kotlin also has infix functions, operator and property overloading which all work in a similar but rather different way.</span></p>
</div>
<h3 id="receivers">Receivers</h3>
<div class="paragraph">
<p><span class="sentence">Every function or property that is defined as a method or an extension has one or more special parameters called <em>receiver</em> parameters. </span><span class="sentence">When calling such a callable using navigation operators (<code>.</code> or <code>?.</code>) the left hand side parameter is called an <em>explicit receiver</em> or this particular call. </span><span class="sentence">In addition to the explicit receiver, each such call may indirectly access zero or more <em>implicit receivers</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit receivers are available in some syntactic scope according to the following rules:</span></p>
</div>
<ul>
<li><span class="sentence">All receivers available in outer scope are also available in all nested scopes;</span></li>
<li><span class="sentence">In the scope of a classifier definition, the following receivers are available:</span>
<ul>
<li><span class="sentence">The implicit <code>this</code> object of the defined type;</span></li>
<li><span class="sentence">The companion object (if one exist) of this class;</span></li>
<li><span class="sentence">The companion objects (if any exists) of all its superclasses;</span></li>
</ul></li>
<li><span class="sentence">If a function or a property is an extension, the <code>this</code> parameter of the extension is also available inside the extension definition;</span></li>
<li><span class="sentence">The scope of a lambda expression if it has an extension function type contains the <code>this</code> argument of this lambda expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The available receivers are prioritized in the following way:</span></p>
</div>
<ul>
<li><span class="sentence">The receivers provided in most inner scope have higher priority;</span></li>
<li><span class="sentence">In a classifier body, the implicit <code>this</code> reference has higher priority than the companion object receiver;</span></li>
<li><span class="sentence">Current class companion object receiver has higher priority than any of the base classes.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The implicit receiver having the highest priority is also called the <em>default implicit receiver</em>. </span><span class="sentence">The default implicit receiver is available in the scope as <code>this</code>. </span><span class="sentence">Other available receivers may be accessed using <a href="expressions.html#this-expressions-1">this-expressions</a> of different form.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If an implicit receiver is available in some scope, it may be used to call functions implicitely without using the navigation operator.</span></p>
</div>
<h3 id="the-forms-of-call-expression">The forms of call-expression</h3>
<div class="paragraph">
<p><span class="sentence">Any function in Kotlin may be called in several different ways:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified call: <code>package.foo()</code>;</span></li>
<li><span class="sentence">A call with an explicit receiver: <code>a.foo()</code>;</span></li>
<li><span class="sentence">An infix function call: <code>a foo b</code>;</span></li>
<li><span class="sentence">An overloaded operator call: <code>a + b</code>;</span></li>
<li><span class="sentence">A call without an explicit receiver: <code>foo()</code>;</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For each of these cases, a compiler should first pick a number of <em>overload candidates</em> which is a set of callables that may be the intended callees and then <em>choose the most specific function</em> to call based on the types of the function and the call operands. </span><span class="sentence">Please note that the overload candidates are picked <strong>before</strong> the most specific function is chosen.</span></p>
</div>
<h3 id="callables-and-invoke-convention">Callables and invoke convention</h3>
<div class="paragraph">
<p><span class="sentence">A <em>callable</em> <span class="math inline">\(X\)</span> for the purpose of this document is one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">A function named <span class="math inline">\(X\)</span> at declaration site;</span></li>
<li><span class="sentence">A property named <span class="math inline">\(X\)</span> at declaration site with an operator function called <code>invoke</code> that is available as member or extension in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In the latter case a call <span class="math inline">\(X\)</span><code>(</code><span class="math inline">\(Y_0\)</span><code>,</code><span class="math inline">\(Y_1\)</span><code>,...,</code><span class="math inline">\(Y_N\)</span><code>)</code> is an overloadable operator which is expanded to <span class="math inline">\(X\)</span><code>.invoke(</code><span class="math inline">\(Y_0\)</span><code>,</code><span class="math inline">\(Y_1\)</span><code>,...,</code><span class="math inline">\(Y_N\)</span><code>)</code>. </span><span class="sentence">The call may contain type parameters, named parameters, variable argument parameter expansion and trailing lambda parameters, all of which are forwarded as-is to the corresponding <code>invoke</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>member callable</em> is either a member function or a member property with member operator <code>invoke</code>. </span><span class="sentence">An <em>extension callable</em> is either an extension function, a member property with an extension operator <code>invoke</code> or an extension property with an extension operator <code>invoke</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When calculating overload resolution sets, member callables produce the following separate sets (ordered by priority, bigger priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Member functions;</span></li>
<li><span class="sentence">Member properties.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Extension callables produce the following separate sets (ordered by priority, bigger priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Extension functions;</span></li>
<li><span class="sentence">Member properties with extension invoke;</span></li>
<li><span class="sentence">Extension properties with member invoke;</span></li>
<li><span class="sentence">Extension properties with extension invoke.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This division is more granular than all other means of dividing resolution candidates into sets, meaning that it is performed the last.</span></p>
</div>
<h3 id="overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</h3>
<div class="paragraph">
<p><span class="sentence">If the callable name is fully-qualified (that is, contains full package path), then the overloading candidate set simply contains all the callables with the same name in the same package. </span><span class="sentence">As a package name may never clash with any other declared entity, after performing division of callables, these are the only sets available.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">package</span> <span class="im">a.b.c</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>) {}</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Double</span>) {}</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">List</span>&lt;<span class="va">Char</span>&gt;) {}</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">val</span> <span class="va">foo</span> = {}</a>
<a class="sourceLine" id="cb1-7" title="7">. . .</a>
<a class="sourceLine" id="cb1-8" title="8">a.b.c.foo()</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here the overload candidates set contains all the callables named <code>foo</code> from the package <code>a.b.c</code>.</span></p>
</div>
<h3 id="a-call-with-an-explicit-receiver">A call with an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">If a function call is done using a navigation operator (<code>.</code> or <code>?.</code>, not to be confused with a <a href="overload-resolution.html#overload-resolution-for-a-fully-qualified-call">fully-qualified call</a>), then the left hand side operand of this operator is the explicit receiver of this call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A call of callable <code>f</code> with explicit receiver <code>e</code> is correct if one (or more) of the following holds:</span></p>
</div>
<ol type="1">
<li><span class="sentence"><code>f</code> is a member callable of the classifier type of <code>e</code> or any of its supertypes;</span></li>
<li><span class="sentence"><code>f</code> is an extension callable for the classifier type of <code>e</code> or any of its supertypes, including local and imported extensions.</span></li>
</ol>
<div class="paragraph">
<p><span class="sentence">Please note that callables functions for case 2 not only include top-level declared extension callables, but also extension callables available in any of the available implicit receivers. </span><span class="sentence">For example, if a class contains a member extension function for another class and an object of this class is available as an implicit receiver, this extension function may be used for the call if it has a suitable type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Then for a callable named <code>f</code> the following sets are looked upon (in this order):</span></p>
</div>
<ol type="1">
<li><span class="sentence">The sets of non-extension member callables named <code>f</code> of the receiver type;</span></li>
<li><span class="sentence">The sets of local extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type, in all declaration scopes containing the current declaration scope, ordered by the size of the scope (smallest first), excluding the package scope;</span></li>
<li><span class="sentence">The sets of explicitly imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type;</span></li>
<li><span class="sentence">The sets of extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type, declared in the current package;</span></li>
<li><span class="sentence">The sets of star-imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type;</span></li>
<li><span class="sentence">The sets of implicitly imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type.</span></li>
</ol>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() : all this X-imported things need to be defined somewhere</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">When looked upon these sets, the first set that contains <strong>any</strong> callable with the corresponding name and conforming types is picked. </span><span class="sentence">This means, among other things, that if the set constructed during step 2 contains a more suitable candidate function, but the set constructed in step 1 is not empty, the function from set 1 is picked even it is a less suitable candidate.</span></p>
</div>
<h3 id="infix-function-calls">Infix function calls</h3>
<div class="paragraph">
<p><span class="sentence">In reality, infix function calls are a special case of function calls with an explicit receiver using the left hand operand as the receiver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There is a slight difference though: during the overload candidate set selection the only functions considered for inclusion are the ones with the <code>infix</code> modifier. </span><span class="sentence">All other functions (and all properties) are not even considered for inclusion. </span><span class="sentence">Aside from this small difference, candidates are selected using the same rules as for normal calls with explicit receiver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions deemed valid candidates for inclusion as infix functions.</span></p>
</div>
<h3 id="operator-calls">Operator calls</h3>
<div class="paragraph">
<p><span class="sentence">According to TODO(), some operator expressions in Kotlin can be overloaded using specially-named functions. </span><span class="sentence">This makes operator expressions semantically equivalent to function calls with explicit receiver, where the receiver expression is selected according to operator form (see TODO()). </span><span class="sentence">The selection of an exact function that is called in each particular case is based on the same rules as for function calls with explicit receivers, the only difference being that only functions with <code>operator</code> modifier are considered for inclusion when building overload candidate sets. </span><span class="sentence">Properties are never considered for inclusion for operator calls.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions deemed valid candidates for inclusion as operator functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Please note that this is valid not only for dedicated operator expressions, but also for <code>for</code>-loops iteration process and property delegates.</span></p>
</div>
<h3 id="a-call-without-an-explicit-receiver">A call without an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">A call that is performed with unqualified function name and without using a navigation operator is a call without an explicit receiver. </span><span class="sentence">It may in fact have one or more implicit receivers or be a top-level function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As with function calls with explicit receiver, a valid implementation should first pick a valid overload candidate set and then search this set for the <em>most specific function</em> to match the call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Than for a function named <code>f</code> the following sets are looked upon (in this order):</span></p>
</div>
<ol type="1">
<li><span class="sentence">The sets of local non-extension functions named <code>f</code> available in current scope, in order of the scope they are declared in, smallest scope first;</span></li>
<li><span class="sentence">The overload candidate sets for each implicit receiver and <code>f</code>, calculated as if it was the explicit receiver, in the order of the receiver priority (see previous section);</span></li>
<li><span class="sentence">Top-level non-extension functions named <code>f</code>, in this order:</span>
<ol type="a">
<li><span class="sentence">Functions explicitely imported into current file;</span></li>
<li><span class="sentence">Functions declared in the same package;</span></li>
<li><span class="sentence">Functions star-imported into current file;</span></li>
<li><span class="sentence">Implicitly imported functions (kotlin standard library or platform-specific);</span></li>
</ol></li>
</ol>
<div class="paragraph">
<p><span class="sentence">When looked upon these sets, the first set that contains <strong>any</strong> function with the corresponding name and conforming types is picked.</span></p>
</div>
<h3 id="calls-with-named-parameters">Calls with named parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most of the call forms listed above may use named parameters in call expressions, for example, <code>f(a = 2)</code>, where <code>a</code> is a named formal parameter specified in the declaration of <code>f</code>. </span><span class="sentence">Such calls are treated the same way as normal calls, but the overload resolution sets are filtered to only contain callables that actually have formal parameters for all the corresponding names.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">For properties called through invoke-convention, the named parameters must be present in the declaration of the <code>invoke</code> operator function</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike positional arguments, named arguments specify directly which of the formal parameters of the function the argument corresponds to. </span><span class="sentence">The matching of formal parameters and arguments is performed separately for each function candidate and while the number of defaults ( see <a href="overload-resolution.html#choosing-the-most-specific-function-from-the-overload-candidate-set">the MSC definition process</a>) does affect resolution process, the fact that some argument was mapped using named or positional argument does not affect is in any way.</span></p>
</div>
<h3 id="calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</h3>
<div class="paragraph">
<p><span class="sentence">Most of the call forms listed above may have a single lambda expression presented outside of the parentheses or replacing them (see [Call expression]). </span><span class="sentence">This has no effect on overload resolution process, aside from argument reordering that may happen due to variable argument parameters or parameters with defaults between the arguments.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This means that calls <code>f(1,2){ g() }</code> and <code>f(1,2, body = { g() })</code> are completely equivalent from the overload resolution standpoint, assuming that <code>body</code> is the name of the last formal parameter of <code>f</code></span></p>
</div>
</blockquote>
<h3 id="calls-with-specified-type-parameters">Calls with specified type parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most of the call forms listed above may have a list of type arguments that precedes the list of value arguments of the call. </span><span class="sentence">In this case, all the potential overload sets only include callables that contain an exactly same number of formal type arguments at declaration site. </span><span class="sentence">In the case of property callable through <code>invoke</code> convention, the type parameters must be present at the <code>invoke</code> operator function declaration.</span></p>
</div>
<h3 id="determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</h3>
<h4 id="rationale">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">A function is <em>applicable</em> for a specific call if and only if the function type parameters may be assigned the values of the arguments specified in the call and all the type constraints of the function still hold.</span></p>
</div>
<h4 id="description">Description</h4>
<div class="paragraph">
<p><span class="sentence">Determining function applicability for a specific call is a [type constraint][Type constraints] problem. </span><span class="sentence">First, for every argument of the function supplied in the call, the type inference is performed. </span><span class="sentence">This excludes lambda arguments, as the inference of the specific type for them needs the results of overloading to finish.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">After that the following constraint system is built:</span></p>
</div>
<ul>
<li><span class="sentence">For every parameter of the call (excluding lambda parameters) inferred to have type <span class="math inline">\(T_i\)</span>, corresponding to function argument of type <span class="math inline">\(U_j\)</span>, a constraint <span class="math inline">\(T_i &lt;: U_j\)</span> is constructed;</span></li>
<li><span class="sentence">All the declaration-site type constraints for the function are also added to the system;</span></li>
<li><span class="sentence">For each lambda parameter with the number of lambda arguments known to be <span class="math inline">\(K\)</span>, a constraint and corresponding to function argument of type <span class="math inline">\(U_m\)</span>, an artificial constraint is added in the form <span class="math inline">\(R(L_1,...,L_K) &lt;: U_m\)</span>, where <span class="math inline">\(R, L_1, ..., L_K\)</span> are all fresh variables;</span></li>
<li><span class="sentence">For each lambda parameter with the number of lambda arguments not known (that is, being equal to 0 or 1), an artificial constraint is added in the form <span class="math inline">\(kotlin.Function &lt;: U_m\)</span>, where <span class="math inline">\(kotlin.Function\)</span> is the common base of all functional types; TODO(): what’s the name???</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If this constraint system is sound, the function is applicable for the call. </span><span class="sentence">Only applicable functions are considered for the next step: finding the most specific overload candidate from the candidate set.</span></p>
</div>
<h3 id="choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</h3>
<h4 id="rationale-1">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">The main rationale behind choosing the most specific function from a candidate set is that the function chosen could be easily forwarded to by all the other functions in the set, while the reverse is not true. </span><span class="sentence">If there are several functions with this property, none of them is the most specific and an ambiguity error should be reported by the compiler.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Let’s look at an example with two functions:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {}        <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {} <span class="co">// (2)</span></a>
<a class="sourceLine" id="cb2-3" title="3">...</a>
<a class="sourceLine" id="cb2-4" title="4">f(<span class="dv">2</span>, <span class="st">&quot;Hello&quot;</span>)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here both functions are applicable for the call, but also function (1) could easily call function (2) by forwarding both arguments into it, but the reverse is impossible. </span><span class="sentence">As a result, function (1) is more specific of the two. </span><span class="sentence">Let’s rename the functions to make it more clear:</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">fun</span> <span class="fu">f1</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {</a>
<a class="sourceLine" id="cb3-2" title="2">    f2(arg, arg2) <span class="co">// perfectly valid</span></a>
<a class="sourceLine" id="cb3-3" title="3">}</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">fun</span> <span class="fu">f2</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {</a>
<a class="sourceLine" id="cb3-5" title="5">    f1(arg, arg2) <span class="co">// invalid: function f1 is not appicable</span></a>
<a class="sourceLine" id="cb3-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The rest of this section will try to clarify this mechanism a little more.</span></p>
</div>
<h4 id="description-1">Description</h4>
<div class="paragraph">
<p><span class="sentence">When an overload resolution set is picked up and contains more than one callable, the next step is to find the most appropriate candidate from these callables.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Firts, the appicable set is divided into two sub-sets: the callables that employ type parameters (generic callables) and the callables that don’t (non-generic callables). </span><span class="sentence">If there are any non-generic applicable candidates, the choise is limited only to non-generic subset. </span><span class="sentence">Otherwise, all canidates (of generic callables) is considered.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This process employs the usage of [type constraint][Type constraints] system of Kotlin, similar to the process of <a href="overload-resolution.html#determining-function-applicability-for-a-specific-call">determining function applicability</a>. </span><span class="sentence">For every two members of the candidate set (let’s call them <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span>), the following constraint system is constructed and solved:</span></p>
</div>
<ul>
<li><span class="sentence">For every non-default argument of the call the corresponding value parameters’ types <span class="math inline">\(X_1, X_2, X_3 ... X_N\)</span> of <span class="math inline">\(F_1\)</span> and value parameters’ types <span class="math inline">\(Y_1, Y_2, Y_3 ... Y_N\)</span> of <span class="math inline">\(F_2\)</span> a type constraint <span class="math inline">\(X_K &lt;: Y_K\)</span> is built. </span><span class="sentence">During construction of these constraints, all the type parameters of <span class="math inline">\(F_1\)</span> are considered bound and all the type parameters of <span class="math inline">\(F_2\)</span> are considered free;</span></li>
<li><span class="sentence">All the declaration-site type constraints of <span class="math inline">\(X_1, X_2, X_3 ... X_N\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3 ... Y_N\)</span> are also added to the system.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If this constraint system is sound, it means that <span class="math inline">\(F_1\)</span> is equally or more applicable as an overload candidate. </span><span class="sentence">After that the check is repeated with <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span> swapped. </span><span class="sentence">If <span class="math inline">\(F_1\)</span> is equally or more applicable than <span class="math inline">\(F_2\)</span> and <span class="math inline">\(F_2\)</span> is equally or more applicable than <span class="math inline">\(F_1\)</span>, this means that the two callables are equally applicable and an additional decision procedure needs to be invoked.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All the members of the overload candidate set are sorted according to the criteria of applicability, determining the most applicable callable. </span><span class="sentence">If there are several callables which are both more applicable than other candidates and equally applicable to each other, an additional step is performed:</span></p>
</div>
<ul>
<li><span class="sentence">For each candidate, the number of default parameters not specified in the call is counted;</span></li>
<li><span class="sentence">The candidate with the least default parameters is a more specific candidate;</span></li>
<li><span class="sentence">If the number of defaulted parameters is equal for several candidates, the candidate having any variable-argument parameters is less specific than any candidate without them.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If, even after this additional step, there are several candidates that are equally applicable for the call, there is an <strong>overload ambiguity</strong> that must be reported as a compiler error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">NOTE: Please note that, unlike the applicability test, the candidate comparison constraint system is <strong>not</strong> based on the actuall call, meaning that when comparing two candidates, only constraints visible at declaration site apply.</span></p>
</div>
</blockquote>
<h3 id="about-type-inference">About type inference</h3>
<div class="paragraph">
<p><span class="sentence">[Type inference][Type inference] in Kotlin is a pretty complicated process, which is performed after resolving all the overload candidates. </span><span class="sentence">Due to the complexity of the process, type inference may not affect the way overload resolution candidate is picked up.</span></p>
</div>
<h4 id="todo-1">TODO:</h4>
<ul>
<li><span class="sentence">Properties business</span></li>
<li><span class="sentence">Function types (type system section???)</span></li>
<li><span class="sentence">Definition of “applicable function”</span></li>
<li><span class="sentence">Definition of “type parameter level”</span></li>
<li><span class="sentence">Calls with named parameters <code>f(x = 2)</code></span></li>
<li><span class="sentence">Calls with trailing lambda without parameter type</span>
<ul>
<li><span class="sentence">Lambdas with parameter types seem to be covered, <strong>nope, they are not</strong></span></li>
</ul></li>
<li><span class="sentence">Calls with specified type parameters <code>f&lt;Double&gt;(3)</code> ## Control- and data-flow analysis</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() ## Kotlin type constraints</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Some complex tasks that need to be solved when compiling Kotlin code are formulated best using <em>constraint systems</em> on Kotlin types. </span><span class="sentence">These are solved using constraint solvers.</span></p>
</div>
<h3 id="type-constraint-definition">Type constraint definition</h3>
<div class="paragraph">
<p><span class="sentence">A <em>type constraint</em> in general is an inequation of the following form: <span class="math inline">\(T &lt;: U\)</span> where <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> are Kotlin types (see <a href="type-system.html#type-system">type system</a>). </span><span class="sentence">It is important, however, that Kotlin has parameterized types and type parameters of <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> (or type parameters of their parameters, or <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> themselves) may be <em>type variables</em>, that are unknown types that may be substituted by any other type in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Please note that, in general, type variables of the constraint system are not the same as type parameters of a type or a callable. </span><span class="sentence">Some type parameters may be <em>bound</em> in the constraint system, meaning that, although they are not known yet in Kotlin code, they are not type variables and are not to be substituted.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When such an ambiguity arises, we will use the notation <span class="math inline">\(T_i\)</span> for a type variable and <span class="math inline">\(\tilde{T_i}\)</span> for a bound type parameter. </span><span class="sentence">The main difference between bound parameters and concrete types is that different concrete types may not be equal, but a bound parameter may be equal to another bound parameter or a concrete type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Several examples of valid type constraints:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: \mathtt{List}\left&lt;\mathtt{List}\left&lt;\mathtt{Int}\right&gt;\right&gt;\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\widetilde{X} &lt;: Y\)</span></span></li>
</ul>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Every constraint system has implicit constraints <span class="math inline">\(\mathtt{Any} &lt;: T_j\)</span> and <span class="math inline">\(T_j &lt;: \mathtt{Nothing?}\)</span> for every type <span class="math inline">\(T_j\)</span> mentioned in constraint, including type variables.</span></p>
</div>
<h3 id="type-constraint-solving">Type constraint solving</h3>
<div class="paragraph">
<p><span class="sentence">There are two tasks that a type constraint solver may perform: checking constraint system for soundness and solving the system, e.g. inferring values for all the type variables that have themselves no type variables in them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Checking a constraint system for soundness can be viewed as a simpler case of solving a constraint, as if there is a solution, than the system is sound. </span><span class="sentence">It is, however, a much simpler task with only two possible outcomes. </span><span class="sentence">Solving a constraint system, on the other hand, may have several different results as there may be several valid solutions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Constraint examples that are sound yet no relevant solutions exist:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(X &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;X\right&gt; &lt;: \mathtt{Collection}\left&lt;X\right&gt;\)</span></span></li>
</ul>
</blockquote>
<h4 id="checking-constraint-system-soundness">Checking constraint system soundness</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO?</span></p>
</div>
</div>
<h4 id="finding-optimal-solution">Finding optimal solution</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO? </span><span class="sentence">## Type inference</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin has a concept of <em>type inference</em> for compile-time type information, meaning that some type information in the code may be omitted, to be inferred by the compiler. </span><span class="sentence">Type inference is a [type constraint][Kotlin type constraints] problem, solved by the type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two kinds of type inference supported by kotlin:</span></p>
</div>
<ul>
<li><span class="sentence">Local type inference, inferring types of expressions locally, in statement scope;</span></li>
<li><span class="sentence">Function signature type inference, inferring types for function return values and/or parameters.</span></li>
</ul>
<h3 id="smart-casts">Smart casts</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin introduces a limited form of flow-dependent typing called <em>smart casting</em>. </span><span class="sentence">Flow-dependent typing means that some statements in the program may introduce changes to the compile-time types of properties. </span><span class="sentence">This allows to avoid unnecessary casting of these values in cases where the runtime types are guaranteed to conform to expected compile-time types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casting is dependent on the <em>smart cast conditions</em> that are boolean predicates about program values. </span><span class="sentence">If some condition involving a program value <em>dominates</em> some program scope, the type of this value is mutated inside that scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two kinds of smart cast conditions: nullity conditions and type conditions. </span><span class="sentence">Nullity conditions signify that some value is not nullable, e.g. it’s value is guaranteed to not be <code>null</code>. </span><span class="sentence">Type conditions signify that some value’s runtime type conforms to a constraint of <span class="math inline">\(RT &lt;: T\)</span> where <span class="math inline">\(T\)</span> is the assumed type and <span class="math inline">\(RT\)</span> is the runtime type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Nullity conditions may be viewed as a subcase of type conditions with assumed type <code>kotlin.Any</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">There are also negated forms of both conditions that do not affect the typing in any way, but may be negated again to introduce non-negated forms of the same conditions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The actual compile type of a value that is subject of smart casting (see below) for any purpose (including, but not limited to, function overloading and further type inference of other values) if it is dominated by a smart casting condition, is, for every condition:</span></p>
</div>
<ul>
<li><span class="sentence">If the condition is a nullability condition, the intersection of the type it had before (including the results of smart casting performed for other conditions) and type <code>kotlin.Any</code>;</span></li>
<li><span class="sentence">If the condition is a type condition, the intersection of the type it had before (including the results of smart casting performed for other conditions) and the assumed type of the condition.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The following values are subject to smart casting:</span></p>
</div>
<ul>
<li><span class="sentence">Immutable local or classifier-scope properties without delegation or custom getters;</span></li>
<li><span class="sentence">Immutable properties of other such properties that too do not have delegation or custom getters;</span></li>
<li><span class="sentence">Mutable local properties without delegation or custom getters as soon as the compiler can prove that they cannot be mutated by external means:</span>
<ul>
<li><span class="sentence">Any properties that are captured in non-inlining lambda expressions or anonymous objects are not applicable.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): the rest is really shaky</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casting conditions are introduced by:</span></p>
</div>
<ul>
<li><span class="sentence">Conditional expressions (<code>if</code> and <code>when</code>):</span>
<ul>
<li><span class="sentence">Smart cast conditions derived from expression condition are active inside the positive branch scope;</span></li>
<li><span class="sentence">Smart cast conditions derived from negated expression condition are active inside the negative branch scope;</span></li>
<li><span class="sentence">If all the branches except one are unreachable, that branch’s condition is also propagated over to the scope containing the conditional expression, after the conditional expression;</span></li>
</ul></li>
<li><span class="sentence">Elvis operator (operator <code>?:</code>): if the right-hand branch of elvis operator is unreachable, a nullability condition for the left-hand side expression (if applicable) is introduced for the rest of the containing scope;</span></li>
<li><span class="sentence">Logical conjunction expressions (operator <code>&amp;&amp;</code>): all conditions derived from left-hand expression are applied to the right-hand expression;</span></li>
<li><span class="sentence">Logical disjunction expressions (operator <code>||</code>): all condtions derived from left-hand expression are applied negated to the right-hand expression;</span></li>
<li><span class="sentence">Not-null assertion expressions (operator <code>!!</code>): the left-hand side value (if applicable) introduces a nullability condtion for the rest of the scope the expression is contained in;</span></li>
<li><span class="sentence">Direct casting expression (operator <code>as</code>): the left-hand side expression (if applicable) introduces a type condition for the rest of the scope the expression is contained in with the assumed type being the same as the right-hand side type of the casting expression;</span></li>
<li><span class="sentence">Direct assignments: if both sides of the assignment are applicable expressions, all the conditions currently applying to the right-hand side are also applied to the left-hand side of the assignment for the rest of the containing scope;</span></li>
<li><span class="sentence">Platform-specific cases: different platforms may add other kinds of expressions that introduce smart-casting conditions.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Property declarations are not listed here because their types are naturally derived from initializers</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Smart cast conditions are derived from boolean expressions in the following way:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>is</code><span class="math inline">\(T\)</span> where <span class="math inline">\(x\)</span> is an applicable expression implies a type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>!is</code><span class="math inline">\(T\)</span> where <span class="math inline">\(x\)</span> is an applicable expression implies a negated type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>== null</code> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression implies a a nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>!= null</code> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression implies a a negated nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>!</code><span class="math inline">\(x\)</span> where <span class="math inline">\(x\)</span> implies all the conditions implied by <span class="math inline">\(x\)</span>, but in negated form;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>&amp;&amp;</code><span class="math inline">\(y\)</span> implies all the non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all the negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>||</code><span class="math inline">\(y\)</span> implies all the negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all the non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>==</code><span class="math inline">\(y\)</span> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is a known non-nullable value (that is, has a non-nullable compile-time type) implies the nullability condition for <span class="math inline">\(x\)</span>.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): is there more than that?</span></p>
</div>
</div>
<h3 id="local-type-inference">Local type inference</h3>
<div class="paragraph">
<p><span class="sentence">Local type inference in Kotlin is the process of deducing the compile-time types of expressions, lambda expression parameters and properties. </span><span class="sentence">As already mentioned above, type inference is a [type constraint][Kotlin type constraints] problem, solved by the type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In addition to the types of intermediate expressions, local type inference also must perform deduction and substitution for generic type parameters of functions and types involved in every expression. </span><span class="sentence">You can use the <a href="expressions.html#expressions">expressions</a> part of this document as a reference point on how the types for different expressions are constructed (please note the effects of <a href="overload-resolution.html#smart-casts">smart casting</a> that are not mentioned in that part).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It does, however, need some clarification as those types are given as definitions, not as type constraints:</span></p>
</div>
<ul>
<li><span class="sentence">If the type <span class="math inline">\(T\)</span> is described as the least upper bound of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, it gets promoted to a pair of constraints: <span class="math inline">\(A &lt;: T\)</span> and <span class="math inline">\(B &lt;: T\)</span>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO: are there other cases?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Type inference in kotlin is also a bidirectional process, meaning that types of expressions may not only be derived from their arguments, but their usage as well. </span><span class="sentence">Please note that, albeit bidirectional, this process is still local, meaning that it processes one statement at a time, in the order of appearance in a scope, so a type of property in statement <span class="math inline">\(S_1\)</span> that goes before statement <span class="math inline">\(S_2\)</span> cannot be inferred based on usage information from <span class="math inline">\(S_2\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Unlike checking satisfiability for a type constraint system, actually solving it is not a definite process, as there may be more than one valid solution (see <a href="overload-resolution.html#type-constraint-solving">type constraint solving</a>). </span><span class="sentence">This means, among other things, that type inference in general may have several valid solutions as well. </span><span class="sentence">In particular, one may always derive a system <span class="math inline">\(A &lt;: T &lt;: B\)</span> for every type variable <span class="math inline">\(T\)</span> where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are both valid solution types. </span><span class="sentence">One of these types is always the solution in Kotlin (although from the constraint viewpoint, there are usually more solutions available), but choosing between them is done according to special rules:</span></p>
</div>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(): What are the rules?)</span>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note that this is valid even if <span class="math inline">\(T\)</span> is a variable without any constraints, as every type in kotlin has an implicit constraint <span class="math inline">\(\mathtt{kotlin.Nothing} &lt;: T &lt;: \mathtt{kotlin.Any?}\)</span>.</span></p>
</div>
</blockquote>
<h3 id="todo-2">TODO</h3>
<ul>
<li><span class="sentence">Type approximation for public usage</span></li>
<li><span class="sentence">Ordering of lambdas (and ordering of overloading vs TI in general) ## Runtime type information</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The <em>runtime type information</em> (RTTI) is the information about Kotlin types of values available from these values at runtime. </span><span class="sentence">RTTI affects the semantics of certain expressions, changing their evaluation depending on the amount of RTTI available for particular values, implementation, and platform:</span></p>
</div>
<ul>
<li><span class="sentence"><a href="expressions.html#type-checking-expression-1">The type checking operator</a></span></li>
<li><span class="sentence"><a href="expressions.html#cast-expression-1">The cast expression</a>, expecially the <code>as?</code> operator</span></li>
<li><span class="sentence">[Class literals][class literal] and the values they evaluate to</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><em>Runtime types</em> are particular instances of RTTI for a particular value at runtime. </span><span class="sentence">These model a subset of the Kotlin <a href="type-system.html#type-system">type system</a>. </span><span class="sentence">Namely, the runtime types are limited to <a href="type-system.html#classifier-types">classifier types</a>, <a href="type-system.html#function-types">function types</a> and a special case of <code>kotlin.Nothing?</code> which is the type of <a href="expressions.html#null-literal-1"><code>null</code> reference</a> and the only nullable runtime type. </span><span class="sentence">This includes the classifier types created by <a href="expressions.html#object-literals-1">anonymous object literals</a>. </span><span class="sentence">There is a slight distinction between a Kotlin type system type and its runtime counterpart:</span></p>
</div>
<ul>
<li><span class="sentence">On some platforms, some particular types may have the same runtime type representation. </span><span class="sentence">This means that checking or casting values of these types works the same way as if they were the same type</span></li>
<li><span class="sentence">Generic types with the same classifier are not required to have different runtime representations. </span><span class="sentence">One cannot generally rely on them having the same representation outside of a particular platform. </span><span class="sentence">Platform specifications must clarify whether some or all types on these platforms have this feature.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">RTTI is also the source of information for platform-specific <em>reflection</em> facilities in the standard library.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The types actual values may have are limited to <a href="type-system.html#classifier-types">class and object types</a> and <a href="type-system.html#function-types">function types</a> as well as <code>kotlin.Nothing?</code> for the <code>null</code> reference. </span><span class="sentence"><code>kotlin.Nothing</code> (not to be confused with its nullable variant <code>kotlin.Nothing?</code>) is special in the way that this type is never encountered as a runtime type even though it may have a platform-specific representation. </span><span class="sentence">The reason for this is that this type is used to signify non-existent values.</span></p>
</div>
<h3 id="runtime-available-types">Runtime-available types</h3>
<div class="paragraph">
<p><span class="sentence"><em>Runtime-available types</em> are the types that can be guaranteed (during compilation) to have a concrete <em>runtime</em> counterpart. </span><span class="sentence">These include all the runtime types, their nullable variants as well as [<code>reified</code> type parameters][Reified type parameters], that are guaranteed to inline to a runtime type during type parameter substitution. </span><span class="sentence">Only runtime-available types may be passed (implicitly or explicitly) as substitutions to reified type paramters, used for type checks and safe casts. </span><span class="sentence">During these operations, the nullability of the type is checked using reference-equality to <code>null</code>, while the rest is performed by accessing the runtime type of a value and comparing it to the supplied runtime-available type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For all generic types that are not expected to have RTTI for their generic arguments, only “raw” variants of generic types (denoted in code using the star-projected type notation or a special parameter-less notation <span><span class="TODO">(TODO: link?)</span><span class="TODO-marker">*</span></span>) are runtime-available.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may say that classifier generics are <em>partially</em> runtime available due to them having information about only the classifier part of the type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">[Exception types][Exceptions] must be runtime-available to enable type checks that the <code>catch</code> clause of <a href="expressions.html#try-expression-1"><code>try</code>-expression</a> performs.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Only non-nullable runtime types may be used in <code>class</code> literal expressions. </span><span class="sentence">These include reified type parameters with non-nullable upper bounds, as well as all classifier and function types.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Anything else?)</span></p>
</div>
</div>
</body>
</html>
