<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/css/main.css">
  <script src="../assets/js/katex/katex.min.js"></script><script src="../assets/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="../assets/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>


















<h2 id="statements">Statements</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
</dd>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em>labelDefinition</em>}<br />
( <em>declaration</em><br />
| <em>assignment</em><br />
| <em>loopStatement</em><br />
| <em>expression</em>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin statements include bare expressions and declarations. </span><span class="sentence">This section is focused on those statements that are <em>not</em> expressions or declarations. </span><span class="sentence">For information about expressions and declarations please refer to the corresponding sections of this document.</span></p>
</div>
<h3 id="assignments">Assignments</h3>
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence"><em>directlyAssignableExpression</em> <code>=</code> {<em>NL</em>} <em>expression</em><br />
| <em>assignableExpression</em> <em>assignmentAndOperator</em> {<em>NL</em>} <em>expression</em></span>
</dd>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>+=</code><br />
| <code>-=</code><br />
| <code>*=</code><br />
| <code>/=</code><br />
| <code>%=</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">An <em>assignment</em> is a statement that writes a new value to some location, denoted by its left hand side. </span><span class="sentence">Both left-hand and right-hand sides of an assignment are expressions, although there are several restrictions for the expression on the left hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For an expression to be <em>assignable</em>, i.e. be allowed to occur on the left-hand side of an assignment, it <strong>must</strong> be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">An identifier referring to a mutable property;</span></li>
<li><span class="sentence">A navigation expression referring to a mutable property;</span></li>
<li><span class="sentence">An [indexing expression][Indexing expression], see details below.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin assignments <strong>are not</strong> expressions and cannot be used as such.</span></p>
</div>
<h4 id="simple-assignment">Simple assignment</h4>
<div class="paragraph">
<p><span class="sentence">A <em>simple assigment</em> is the assignment form employing the assign operator <code>=</code>. </span><span class="sentence">If the left-hand side of the assignment refers to a mutable property, a mutation of that property is performed when the assignment is evaluated:</span></p>
</div>
<ul>
<li><span class="sentence">If the property is [delegated][Property delegation], the corresponding operator function <code>setValue</code> is called using the right-hand side expression value as value argument;</span></li>
<li><span class="sentence">If the property has a setter, it is called using the right-hand side expression value as value argument;</span></li>
<li><span class="sentence">If the property is just a variable without delegation or setter, it’s value is directly changed to the value of the right-hand side expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the left-hand side of the assignment is an indexing expression, the whole statement is treated as an overloaded operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,…,<span class="math inline">\(B_N\)</span><code>] =</code><span class="math inline">\(C\)</span> is exactly the same as calling <span class="math inline">\(A\)</span><code>.set(</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,…,<span class="math inline">\(B_N\)</span>,<span class="math inline">\(C\)</span><code>)</code> where <code>set</code> is a sutable <code>operator</code> function.</span></p>
</div>
<h4 id="operator-assignments">Operator assignments</h4>
<div class="paragraph">
<p><span class="sentence">An <em>operator assignment</em> is a combined-form assignment that involves one of the following operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>. </span><span class="sentence">All these are overloadable operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.plusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.minusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.timesAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>timesAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>times</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.divAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>divAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>div</code> operator function exists and is available;</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.remAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>remAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>rem</code> operator function exists and is available.</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The expanded simple assignment is then proceeded as described in the previous section.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Although for most real-world usecases operators <code>++</code> and <code>--</code> are very similar to operator assignments, in Kotlin they are actually expressions and are described as such in the <a href="expressions.html#expressions">corresponding section</a> of this document.</span></p>
</div>
</blockquote>
<h3 id="loop-statements">Loop statements</h3>
<div class="paragraph">
<p><span class="sentence">Loop statements are constructs that repeat evaluating a certain number of statements until a <em>loop exit condition</em> applies.</span></p>
</div>
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em>forStatement</em><br />
| <em>whileStatement</em><br />
| <em>doWhileStatement</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Loops are closely related to the semantics of several <a href="expressions.html#jump-expressions-1">jump expressions</a>, as these expressions, namely <code>break</code> and <code>continue</code>, are only allowed in the body of a loop. </span><span class="sentence">Please refer to the corresponding section for details.</span></p>
</div>
<h4 id="while-loop">While loop</h4>
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <em>controlStructureBody</em><br />
| <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <code>;</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence"><em>While loop statement</em> is very similar to an <a href="expressions.html#conditional-expression-1"><code>if</code> expression</a> in the way that it contains a condition expression and a body consisting of one or more statements. </span><span class="sentence">While loop repeats evaluating its body for as long as the condition expression evaluates to true or a <a href="expressions.html#jump-expressions-1">jump expression</a> is evaluated to finish the loop.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that the condition expression is evaluated before every evaluation of the body, including the first one.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="do-while-loop">Do-while loop</h4>
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>do</code> {<em>NL</em>} [<em>controlStructureBody</em>] {<em>NL</em>} <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>do-while statement</em> is very similar to the while statement, but with a few differences. </span><span class="sentence">First, it has a different syntax. </span><span class="sentence">Second, it evaluates the loop condition expression <strong>after</strong> evaluating the loop body.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that the body is always evaluated at least once</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="for-loop">For loop</h4>
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>for</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} (variableDeclaration | <em>multiVariableDeclaration</em>) <code>in</code> <em>expression</em> <code>)</code> {<em>NL</em>} [<em>controlStructureBody</em>]</span>
</dd>
</dl>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike other languages, Kotlin does not have a free-form condition-based for loops. </span><span class="sentence">The only form of for-loop available in Kotlin is (what it’s called in other languages) “the foreach loop”, iterating over arrays and other datastructures</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>for statement</em> is a special kind of loop statements that is used to iterate over data structures containing a number of elements. </span><span class="sentence">The for loop consists of a loop body, a <strong>container expression</strong> and the <strong>iteration variable declaration</strong>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The for loop is actually an [overloadable][Overloadable operators] syntax form with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>for(</code><span class="math inline">\(VarDecl\)</span><code>) in</code><span class="math inline">\(C\)</span><code>) $Body$</code> is exactly the same as</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">val</span> <span class="va">__iterator</span> = C.iterator()</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="cf">while</span>(__iterator.hasNext()) {</a>
<a class="sourceLine" id="cb1-3" title="3">    VarDecl = __iterator.next()</a>
<a class="sourceLine" id="cb1-4" title="4">    &lt;... all the statements from Body&gt;</a>
<a class="sourceLine" id="cb1-5" title="5">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>iterator</code>, <code>hasNext</code>, <code>next</code> are all acceptable operator functions available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Please note that expansions are hygenic, meaning the generated iterator variable never clashes with any other values in the program and cannot be accessed outside the expansion</span></p>
</div>
</blockquote>
<h3 id="code-blocks">Code blocks</h3>
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
</dd>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>code block</em> is a series of statements between curly braces separated by newlines or/and semicolons. </span><span class="sentence">A code block may be empty. </span><span class="sentence">Evaluating a code block means evaluating all its statements in the order they are given inside it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <em>last expression</em> of a code block is the last statement in the block (if any) if and only if this statement is also an expression. </span><span class="sentence">The last expressions are important when defining functions and control structure expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The code block is said to contain no last expression if it does not contain any statements of the last statement is not an expression (e.g. it is an assignment, a loop or a declaration).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This usually means that a synthetic last expression with no runtime semantics and with type <code>kotlin.Unit</code> is introduced instead</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>control structure body</em> is either a single statement or a code block. </span><span class="sentence">The <em>last expression</em> of a control structure body is either the last expression of the code block (if it is a code block) or the single statement itself if it is an expression. </span><span class="sentence">If the control structure body is not a code block or an expression, it has no last expression.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This is usually equivalent to wrapping the single statement in a new synthetic code block</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In some contexts, a control structure body is expected to have a value and/or a type. </span><span class="sentence">The value of a control structure body is:</span></p>
</div>
<ul>
<li><span class="sentence">The value of its last expression if it exists;</span></li>
<li><span class="sentence">The singleton <code>kotlin.Unit</code> object otherwise.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The <em>type of a control structure body</em> is the type of its value.</span></p>
</div>
<h3 id="todo">TODO</h3>
<ul>
<li><span class="sentence">Are declarations statements or not?</span>
<ul>
<li><span class="sentence">In the current grammar, they are</span></li>
</ul></li>
<li><span class="sentence">Wording</span></li>
<li><span class="sentence">Mutable vs immutable properties</span></li>
<li><span class="sentence">How expansions with new variables actually work ## Expressions</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An expression may be <em>used as a statement</em> or <em>used as an expression</em> depending on the context. </span><span class="sentence">As all expressions are valid statements <a href="statements.html#statements">see the statements section</a>, free expressions may be used as single statements or inside code blocks.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An expression is used as an expression if it is encountered at any position where a statement is not allowed, for example, as an operand to an operator or as an immediate argument for a function call. </span><span class="sentence">An expression is used as a statement if it is encountered at any position where a statement is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Some expressions are only allowed to be used as statements unless certain restrictions are met and this may affect the semantics, the compile-type type information and the safety of these expressions. </span><span class="sentence">All expressions are allowed to be used as statements.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="constant-literals">Constant literals</h3>
<div class="paragraph">
<p><span class="sentence">Constant literals are expressions that correspond to constant, non-changing values. </span><span class="sentence">Every constant literal is defined to have a single standard library type, whichever it is defined to be on current platform.</span></p>
</div>
<h4 id="boolean-literals">Boolean literals</h4>
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>true</code> | <code>false</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Keywords <code>true</code> and <code>false</code> denote boolean literals of corresponding values. </span><span class="sentence">These are two strong keywords and as such cannot be used as identifiers unless [escaped][Escaped identifiers]. </span><span class="sentence">Values <code>true</code> and <code>false</code> always have type <code>kotlin.Bool</code>.</span></p>
</div>
<h4 id="integer-literals">Integer literals</h4>
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
</dd>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
</dd>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
</dd>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
<h5 id="decimal-integer-literals">Decimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of decimal digit symbols (<code>0</code> though <code>9</code>) is a decimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one. </span><span class="sentence">Please note that unlike other languages Kotlin does not support octal literals. </span><span class="sentence">Even more, any decimal literal starting with digit <code>0</code> and containing more than 1 digit is not a valid decimal literal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Decimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A decimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="hexadecimal-integer-literals">Hexadecimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of hexadecimal digit symbols (<code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, or <code>A</code> through <code>F</code>) prefixed by <code>0x</code> or <code>0X</code> is a hexadecimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Hexadecimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A hexadecimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="binary-integer-literals">Binary integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of binary digit symbols (<code>0</code> or <code>1</code>) prefixed by <code>0b</code> or <code>0B</code> is a binary integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Binary literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A binary literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h4 id="real-literals">Real literals</h4>
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
</dd>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>real literal</em> consists of the following parts: the whole-number part, a decimal point (represented by the ASCII period character (<code>.</code>)), a fraction part and an exponent. </span><span class="sentence">Unlike other languages, Kotlin real literals may only be expressed in decimal numbers. </span><span class="sentence">The number also may be followed by type suffix (<code>f</code> or <code>F</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The exponent is an exponent mark (<code>e</code> or <code>E</code>) followed by an optionaly signed decimal integer (a sequence of decimal digits).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The whole-number part and the exponent part may be omitted. </span><span class="sentence">The fraction part may only be omitted together with the decimal point if the whole part and either the exponent part or type suffix are present. </span><span class="sentence">Unlike other languages, Kotlin does not support omitting the fraction part, but leaving the decimal point in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The digits of the whole-number part or the fraction part or the exponent may be optionally separated by underscores, but an underscore may not be placed between, before, or after these parts. </span><span class="sentence">It also may not be placed before or after the exponent sign symbol.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A real literal without a type suffix has type <code>kotlin.Double</code>, while a real literal with the type suffix does have type <code>kotlin.Float</code>. </span><span class="sentence">There is no special suffix attributed to the <code>kotlin.Double</code> type.</span></p>
</div>
<h4 id="character-literals">Character literals</h4>
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
</dd>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <strong>character literal</strong> defines a constant holding a unicode character value. </span><span class="sentence">A simply-formed character literal is any symbol between two single quotation mark symbols (ASCII single quotation <code>'</code>), excluding newline symbols (<em>CR</em> and <em>LF</em>), the single quotation symbol itself and the escaping mark (the ASCII backslash symbol <code>\</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A character literal may also contain an escaped symbol of two kinds: a simple escaped symbol or a unicode codepoint. </span><span class="sentence">Simple escaped symbols include:</span></p>
</div>
<ul>
<li><span class="sentence"><code>\t</code> — the unicode TAB symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\b</code> — the unicode BACKSPACE symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\r</code> — <em>CR</em>;</span></li>
<li><span class="sentence"><code>\n</code> — <em>LF</em>;</span></li>
<li><span class="sentence"><code>\'</code> — the unicode single quotation symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\&quot;</code> — the unicode double quotation symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\\</code> — the unicode backslash symbol symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\$</code> — the unicode DOLLAR symbol.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A unicode codepoint escape sequence is the symbols <code>\u</code> followed by exactly four hexadecimal digits. </span><span class="sentence">It represents the unicode symbol with the codepoint equal to the number represented by these digits. </span><span class="sentence">Please note that unicode escapes support only unicode symbols in range U+0000 to U+FFFF.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Any character literal has type <code>kotlin.Char</code>.</span></p>
</div>
<h4 id="string-literals-1">String literals</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports [string interpolation][String Interpolation] mechanisms that supersede traditional string literals. </span><span class="sentence">Please refer to the corresponding section.</span></p>
</div>
<h4 id="null-literal">Null literal</h4>
<div class="paragraph">
<p><span class="sentence">The keyword <code>null</code> signifies the <strong>null reference</strong>, which is a valid value for all <a href="type-system.html#nullable-types">nullable types</a>. </span><span class="sentence">Null reference implicitly has the nullable <code>kotlin.Nothing?</code> type and is, by definition, the only valid value for this type (see <a href="type-system.html#kotlin.nothing">the corresponding section</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): reshuffle these sections</span></p>
</div>
</div>
<h3 id="try-expression">Try-expression</h3>
<div id="grammar-rule-tryExpression-pasted-0" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-block">block</a></em> ((({<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock-pasted-1" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="syntax.html#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="syntax.html#grammar-rule-type">type</a></em><br />
<code>')'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock-pasted-2" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>try-expression</em> is an expression starting with the keyword <code>try</code>. </span><span class="sentence">It consists of a code block (<em>try body</em>) and several optional additional blocks: one of more <em>catch blocks</em>, starting with the soft keyword <code>catch</code> with a single parameter called <em>exception parameter</em> followed by another code block and a single optional <em>finally block</em>, starting with the soft keyword <code>finally</code> and yet another code block. </span><span class="sentence">At least one catch or finally block must exist, otherwise the expression is ill-formed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The try-expression evaluates its body as normally, but if any statement in the body throws an exception, the exception, rather than being propagated up the call stack, gets checked for its type. </span><span class="sentence">If there exists any catch block which parameter type is valid for the checked exception, this catch block is evaluated immediately after the exception is thrown and the exception itself is passed inside the catch block as the corresponding parameter. </span><span class="sentence">If there are several catch blocks with suitable parameter types, the first one is picked.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If there is a finally block, it gets evaluated after any evaluated catch block, or, if no catch block was encountered, after the exception was thrown. </span><span class="sentence">If no catch block was selected, the exception is [propagated as usual][Exceptions] up the call stack after the finally block (if any) is evaluated. </span><span class="sentence">If no exception is thrown during the evaluation of the try body, no catch blocks are checked, but the finally block is executed anyway and program execution continues as normal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The value of the try-expression is the same as the value of the last expression of the try body (if no exception was thrown) or the value of the last expression of the selected catch block (if one was selected). </span><span class="sentence">All other situations mean that an exception is propagated up the call stack, so the value of the try-expression becomes irrelevant. </span><span class="sentence">The finally block does get executed as described above, but has no effect on the value returned by the try-expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the try-expression is the [least upper bound][Least upper bound] of the types of the last expressions of the try body and the last expressions of all the catch blocks <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If any of the blocks have no valid last expression, the type is inferred to be <code>kotlin.Unit</code>, but the try-expression may be used as an expression anyway.</span></p>
</div>
<h3 id="conditional-expression">Conditional expression</h3>
<div id="grammar-rule-ifExpression-pasted-3" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} (<em><a href="syntax.html#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))<br />
| (<code>'if'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} [<em><a href="syntax.html#grammar-rule-controlStructureBody">controlStructureBody</a></em>] {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} [<code>';'</code>] {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} (<em><a href="syntax.html#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>Conditional expressions</strong> use the boolean value of one expression (<em>condition</em>) to decide which of two control structure bodies (<em>branches</em>) should be evaluated. </span><span class="sentence">If the condition evaluates to <code>true</code>, than the first branch (the true branch) is evaluated, otherwise the second branch is. </span><span class="sentence">The value of the resulting expression is the same as the value of the chosen branch. </span><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of two branches <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If one of the branches is omitted (see the grammar entry above), the resulting expression has type <a href="type-system.html#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The condition expression must have type <code>kotlin.Boolean</code> <span><span class="TODO">(TODO(): or be smartcasted to it!)</span><span class="TODO-marker">*</span></span>, otherwise it is a type error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">When used as expressions, conditional expressions are special in the sense of operator precedence: they have the highest (same as all primary expressions) priority when placed on the right side of any binary expression, but when placed on the left side, they have the lowest priority. </span><span class="sentence">For details, see the <a href="syntax.html#syntax-grammar">grammar</a></span></p>
</div>
</blockquote>
<h3 id="when-expression">When expression</h3>
<div id="grammar-rule-whenExpression-pasted-4" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="syntax.html#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="syntax.html#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry-pasted-5" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="syntax.html#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="syntax.html#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="syntax.html#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition-pasted-6" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-expression">expression</a></em><br />
| <em><a href="syntax.html#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="syntax.html#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest-pasted-7" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-inOperator">inOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest-pasted-8" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-isOperator">isOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression</strong> is alike a <strong>conditional expression</strong> in the sense that it allows several different control structure bodies (<em>cases</em>) to be evaluated depending on boolean conditions. </span><span class="sentence">The key difference, however, is that when expressions may include several different conditions. </span><span class="sentence">When expression has two different forms: with bound value and without it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression without bound value</strong> (the form where the expression enclosed in parantheses is absent) evaluates one of the many different expressions based on corresponding conditions present in the same <em>when entry</em>. </span><span class="sentence">Each entry consists of a boolean <em>condition</em> (or a special <code>else</code> condition), each of which is checked and evaluated in order of appearance. </span><span class="sentence">If the current condition evaluates to <code>true</code>, the corresponding expression is evaluated and the value of when expression is the same as the evaluated expression. </span><span class="sentence">All remaining conditions and expressions are not evaluated. </span><span class="sentence">The <code>else</code> branch is a special branch that evaluates if none of the branches above it evaluated to <code>true</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally speaking, you can always replace the <code>else</code> branch with literal <code>true</code> and the semantics of the entry would not change</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The <code>else</code> entry is also special in the sense that it <strong>must</strong> be the last entry in the expression, otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression with bound value</strong> (the form where the expression enclosed in parantheses is present) are very similar to the form without bound value, but use different syntax for conditions. </span><span class="sentence">In fact, it supports three different condition forms:</span></p>
</div>
<ul>
<li><span class="sentence"><em>Type test condition</em>: type checking operator [TODO: link] followed by type. </span><span class="sentence">The condition generated is a type check expression [TODO: link] with the same operator and the same type, but an implicit left hand side, which has the same value as the bound expression.</span></li>
<li><span class="sentence"><em>Contains test condition</em>: containment operator [TODO: link] followed by an expression; The condition generated is a containment check expression [TODO: link] with the same operator and the same right hand side expression, but an implicit left hand side, which has the same value as the bound expression.</span></li>
<li><span class="sentence"><em>Any other expression</em>. </span><span class="sentence">The condition generated is an equality operator [TODO: link], with the left hand side being the bound expression, and the right hand side being the expression placed inside the entry.</span></li>
<li><span class="sentence">The <code>else</code> condition, which works the exact same way as it would in the form without bound expression.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that if this form of <code>when</code> contains a boolean expression, it is not checked directly as if it would be in the other form, but rather checked for <strong>equality</strong> with the bound variable, which is not the same thing.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of all the entries <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If the expression is not <a href="expressions.html#exhaustive-when-expressions-1">exhaustive</a>, it has type <a href="type-system.html#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<h4 id="exhaustive-when-expressions">Exhaustive when expressions</h4>
<div class="paragraph">
<p><span class="sentence">A when expression is called <strong><em>exhaustive</em></strong> if at least one of the following is true:</span></p>
</div>
<ul>
<li><span class="sentence">It has an <code>else</code> entry;</span></li>
<li><span class="sentence">It has a bound value and at least one of the following holds:</span>
<ul>
<li><span class="sentence">The bound expression is of type <code>kotlin.Boolean</code> and the conditions contain both:</span>
<ul>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>true</code>;</span></li>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>false</code>;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of a [<code>sealed class</code>][Sealed classes] type and all its possible subtypes are covered using type test conditions of this expression. </span><span class="sentence">This may include:</span>
<ul>
<li><span class="sentence">Checks for all the direct subtypes of this sealed class;</span></li>
<li><span class="sentence">If any of the direct subtypes is also a sealed class, there is either a check for this subtype or all possible subtypes of it are also covered;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of an [<code>enum class</code>][Enum classes] type and all enumerated values are checked for equality using constant conditions;</span></li>
<li><span class="sentence">The bound expression is of a nullable type and one of the cases above is met for its non-nullable counterpart and, in addition, there is a condition containing literal <code>null</code>.</span></li>
</ul></li>
</ul>
<h3 id="logical-disjunction-expression">Logical disjunction expression</h3>
<div id="grammar-rule-disjunction-pasted-9" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>||</code> performs logical disjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>false</code>.</span></p>
</div>
<h3 id="logical-conjunction-expression">Logical conjunction expression</h3>
<div id="grammar-rule-conjunction-pasted-10" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-equality">equality</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>&amp;&amp;</code> performs logical conjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>true</code>.</span></p>
</div>
<h3 id="equality-expressions">Equality expressions</h3>
<div id="grammar-rule-equality-pasted-11" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-comparison">comparison</a></em> {<em><a href="syntax.html#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator-pasted-12" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Equality expressions are binary expressions involving equality operators. </span><span class="sentence">There are two kinds of equality operators: <em>reference equality operators</em> and <em>value equality operators</em>.</span></p>
</div>
<h4 id="reference-equality-expressions">Reference equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Reference equality expressions</em> are binary expressions employing reference equality operators: <code>===</code> and <code>!==</code>. </span><span class="sentence">These expressions check if two values are equal <em>by reference</em>, meaning that two values are equal (non-equal for operator <code>!==</code>) if and only if they represent the same runtime value created using the same constructor call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For values created without construction calls, notably the constant literals and constant expressions composed of those literals, the following holds:</span></p>
</div>
<ul>
<li><span class="sentence">If these values are <a href="expressions.html#value-equality-expressions-1">non-equal by value</a>, they are also non-equal by reference;</span></li>
<li><span class="sentence">Any instance of the null reference <code>null</code> is reference-equals to any other instance of the null reference;</span></li>
<li><span class="sentence">Otherwise, it is implementation-defined and must not be used as a means of comparing two such values.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Reference equality expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="value-equality-expressions">Value equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Value equality expressions</em> are binary expressions employing value equality operators: <code>==</code> and <code>!=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> <code>==</code> <span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null)</code> where <code>equals</code> is a valid operator function available in the current scope;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span> <code>!=</code> <span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null))</code> where <code>equals</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Please note that the class <code>kotlin.Any</code> has a built-in open operator member function called <code>equals</code>, meaning that there is always at least one available overloading candidate for any value equality expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Value equality expressions always have type <code>kotlin.Boolean</code>. </span><span class="sentence">If the corresponding operator function has a different return type, it is invalid and a compiler error should be generated.</span></p>
</div>
<h3 id="comparison-expressions">Comparison expressions</h3>
<div id="grammar-rule-comparison-pasted-13" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="syntax.html#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator-pasted-14" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Comparison expressions</em> are binary expressions employing the comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;</code><span class="math inline">\(B\)</span> is exactly the same as <code>0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>))</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>compareTo</code> is a valid operator function available in the current scope and <code>[&lt;]</code> (read “boxed less”) is a special operator unavailable for in-code use in Kotlin and performing integer “less-than” comparison of two integer numbers. </span><span class="sentence">The <code>compareTo</code> overloaded function must have return type <code>kotlin.Int</code>, otherwise it’s a compiler error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All comparison expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</h3>
<div id="grammar-rule-infixOperation-pasted-15" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="syntax.html#grammar-rule-inOperator">inOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="syntax.html#grammar-rule-isOperator">isOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator-pasted-16" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator-pasted-17" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<h4 id="type-checking-expression">Type-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A type checking expression employs the use of an type-checking operators <code>is</code> or <code>!is</code> and has an expression as a left-hand side operand and a type name as a right-hand side operand. </span><span class="sentence">The type must be <a href="overload-resolution.html#runtime-available-types">runtime-available</a>, otherwise a compiler error should be generated. </span><span class="sentence">The expression checks whether the runtime type of the expression on the left is the same (not the same for <code>!is</code>) as the type denoted by the right-hand side argument.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type-checking expression always has type <code>kotlin.Boolean</code>.</span></p>
</div>
<h5 id="todo-1">TODO()</h5>
<ul>
<li><span class="sentence">Smart casts!</span></li>
</ul>
<h4 id="containment-checking-expression">Containment-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>containment-checking expression</em> is a binary expression employing the containment operator (<code>in</code> or <code>!in</code>). </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>in</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>)</code>;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>!in</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>))</code>;</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>contains</code> is a valid operator function available in the current scope. </span><span class="sentence">This function must have return type <code>kotlin.Boolean</code>, otherwise a compiler error is generated. </span><span class="sentence">Containment-checking expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="elvis-operator-expression">Elvis operator expression</h3>
<div id="grammar-rule-elvisExpression-pasted-18" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-elvis">elvis</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Elvis operator expression</em> is a binary expression that emplys the elvis operator (<code>?:</code>). </span><span class="sentence">It checks whether the left-hand side expression is equal to <code>null</code>, and if it is, evaluates and return the right-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator is <strong>lazy</strong>, meaning that if the left-hand side expression is not equal to <code>null</code>, the right-hand side expression is never evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of elvis operator expression is the [least upper bound][The least upper bound] of the non-nullable variant of the type of the left-hand side expression and the type of the right-hand side expression. </span><span class="sentence">TODO(): not that simple, too</span></p>
</div>
<h3 id="range-expression">Range expression</h3>
<div id="grammar-rule-rangeExpression-pasted-19" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>range expression</em> is a binary expression employing the range operator <code>..</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>..</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rangeTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>rangeTo</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding <code>rangeTo</code> overload variant.</span></p>
</div>
<h3 id="additive-expression">Additive expression</h3>
<div id="grammar-rule-additiveExpression-pasted-20" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="syntax.html#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator-pasted-21" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>additive expression</em> is a binary expression employing the addition (<code>+</code>) or subtraction (<code>-</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>plus</code> or <code>minus</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="multiplicative-expression">Multiplicative expression</h3>
<div id="grammar-rule-multiplicativeExpression-pasted-22" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-asExpression">asExpression</a></em> {<em><a href="syntax.html#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator-pasted-23" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>multiplicative expression</em> is a binary expression employing the multiplication (<code>*</code>), division (<code>/</code>) or remainder (<code>%</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">where <code>times</code>, <code>div</code>, <code>rem</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="cast-expression">Cast expression</h3>
<div id="grammar-rule-asExpression-pasted-24" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-asOperator">asOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator-pasted-25" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>cast expression</em> is a binary expression employing the cast operators (<code>as</code> or <code>as?</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The form of cast expression employing the <code>as</code> operator is called <em>a unsafe cast</em> expression This operator perform a runtime check whether runtime type of the expression is a <a href="type-system.html#subtyping">subtype</a> of the type given on the right-hand side operand and throws an exception otherwise. </span><span class="sentence">If the type on the right hand side is a <a href="overload-resolution.html#runtime-available-types">runtime-available</a> type without generic parameters, then this exception is thrown immediately when evaluating the expression, otherwise it is platform-dependent whether an exception is thrown at this point.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Even if the exception is not thrown when evaluating the cast expression, it is guaranteed to be thrown later when the value is used with any runtime-available type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The unsafe cast expression always has the same type as the type specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The form of cast expression employing the <code>as?</code> operator is called <em>a checked cast</em> expression This operator is very similar to the unsafe cast expression, but does not throw an exception, but returns <code>null</code> if the types don’t match. </span><span class="sentence">If the type specified on the right hand side of the expression is not <a href="overload-resolution.html#runtime-available-types">runtime-available</a>, then the check is not performed and <code>null</code> is never returned, leading to potential runtime errors later in the program execution. </span><span class="sentence">This situation should be reported with a compiler warning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The checked cast expression always has the <a href="type-system.html#nullable-types">nullable</a> variant of the type specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>ascription expression</em> is a binary expression employing the ascription operator (<code>:</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator does not perform any actions at runtime and evaluates to the same value as its left hand operand. </span><span class="sentence">However, it does perform a compile-time check whether the current type of the expression is a <a href="type-system.html#subtyping">subtype</a> of the type given on the right-hand side operand and generates a compiler error otherwise.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The ascription expression always has the same type as the type specified in right-hand side of the expression.</span></p>
</div>
<h4 id="todo-2">TODO()</h4>
<ul>
<li><span class="sentence">Smart casts!</span></li>
</ul>
<h3 id="prefix-expressions">Prefix expressions</h3>
<div id="grammar-rule-prefixUnaryExpression-pasted-26" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="syntax.html#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="syntax.html#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix-pasted-27" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="syntax.html#grammar-rule-label">label</a></em><br />
| (<em><a href="syntax.html#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator-pasted-28" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="syntax.html#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<h4 id="annotated-and-labeled-expression">Annotated and labeled expression</h4>
<div class="paragraph">
<p><span class="sentence">Any expression in Kotlin may be prefixed with any number of [annotations][Annotations] and [labels][Labels]. </span><span class="sentence">These do not change the value of the expression and can be used by external tools and platform-dependent features.</span></p>
</div>
<h4 id="prefix-increment-expression">Prefix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>++</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix increment expression must be an <a href="statements.html#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="prefix-decrement-expression">Prefix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>--</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a prefix decrement expression must be an <a href="statements.html#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="unary-minus-expression">Unary minus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary minus</em> expression is an expression employing the prefix form of operator <code>-</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>-</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryMinus()</code> where <code>unaryMinus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="unary-plus-expression">Unary plus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary plus</em> expression is an expression employing the prefix form of operator <code>+</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>+</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryPlus()</code> where <code>unaryPlus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="logical-not-expression">Logical not expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>logical not</em> expression is an expression employing the prefix operator <code>!</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>!</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.not()</code> where <code>not</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h3 id="postfix-operator-expressions">Postfix operator expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-29" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="syntax.html#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="syntax.html#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="syntax.html#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-30" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="syntax.html#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="syntax.html#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="syntax.html#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="syntax.html#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator-pasted-31" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="syntax.html#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<h4 id="postfix-increment-expression">Postfix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix increment</em> expression is an expression employing the postfix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>++</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb2-2" title="2">A = A.inc();</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix increment expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of postfix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="postfix-decrement-expression">Postfix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix decrement</em> expression is an expression employing the postfix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>--</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb3-2" title="2">A = A.dec();</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix decrement expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h3 id="not-null-assertion-expression">Not-null assertion expression</h3>
<div class="paragraph">
<p><span class="sentence">A <em>not-null assertion expression</em> is a postfix expression employing the use of operator <code>!!</code>. </span><span class="sentence">For expressions of nullabe types, this expression checks whether the value is equal to <code>null</code>, and if it is, throws a runtime exception. </span><span class="sentence">If it is not equal to <code>null</code>, it evaluates to the same value as its left-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Not-null assertion expressions have no effect on values of non-nullable types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of non-null assertion expression is the <a href="type-system.html#nullable-types">non-nullable</a> variant of the type of its left-hand side expression. </span><span class="sentence">Note that this type may be non-denotable in Kotlin and as such, may be [approximated][Type approximation] in some situations involving [type inference][Type inference].</span></p>
</div>
<h3 id="indexing-expressions">Indexing expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-32" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="syntax.html#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="syntax.html#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="syntax.html#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-33" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="syntax.html#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="syntax.html#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="syntax.html#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="syntax.html#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix-pasted-34" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-expression">expression</a></em><br />
{{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>indexing expression</em> is a suffix expression employing the use of several subexpressions <em>indices</em> between square brackets (<code>[</code> and <code>]</code>). </span><span class="sentence">At least one index must be provided.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>]</code> is exactly the same as <span class="math inline">\(A\)</span><code>.get(</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>)</code>, where <code>get</code> is a suitable <code>operator</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A correct indexing expression has the same type as the corresponding <code>get</code> expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Indexing expressions are [assignable][Assignable expressions]. </span><span class="sentence">For a corresponding assignment form, see [indexing assignment][Indexing assignment].</span></p>
</div>
<h3 id="call-and-property-access-expressions">Call and property access expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-35" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="syntax.html#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="syntax.html#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="syntax.html#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-36" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="syntax.html#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="syntax.html#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="syntax.html#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="syntax.html#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix-pasted-37" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} (<em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="syntax.html#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix-pasted-38" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="syntax.html#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="syntax.html#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="syntax.html#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="syntax.html#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="syntax.html#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda-pasted-39" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="syntax.html#grammar-rule-annotation">annotation</a></em>} [<em><a href="syntax.html#grammar-rule-label">label</a></em>] {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments-pasted-40" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments-pasted-41" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection-pasted-42" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="syntax.html#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="syntax.html#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers-pasted-43" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="syntax.html#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator-pasted-44" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="syntax.html#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<h4 id="the-navigation-operators">The navigation operators</h4>
<div class="paragraph">
<p><span class="sentence">Expressions employing the navigation binary operators (<code>.</code>, <code>.?</code> or <code>::</code>) are all syntactically similar, but, in fact, may have very different syntactic meaning. </span><span class="sentence"><code>a.c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified type, property or object name. </span><span class="sentence">The left side of <code>.</code> must be a package name, while the right side corresponds to a declaration in that package. </span><span class="sentence">Note that qualification uses operator <code>.</code> only;</span></li>
<li><span class="sentence">A value property access. </span><span class="sentence">Here <code>a</code> is another value available in the current scope and <code>c</code> is the property name. </span><span class="sentence">If used with operator <code>::</code> this becomes a [property reference][Callable references]. </span><span class="sentence">The left-hand side expression may be a type name, which is similar to using the type’s companion object as the left hand side expression;</span></li>
<li><span class="sentence">A member function call if followed by the call suffix (arguments enclosed in parentheses). </span><span class="sentence">These expressions adhere to the <a href="overload-resolution.html#overload-resolution">overloading</a> rules. </span><span class="sentence">If used with operator <code>::</code>, but without the call suffix, this becomes a [function reference][Callable references].</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() + Identifiers</span></p>
</div>
</div>
<h3 id="function-literals">Function Literals</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin supports using functions as values. </span><span class="sentence">This includes, among other things, being able to use named functions (through [function references][Callable references]) as parts of expressions. </span><span class="sentence">Sometimes it does not make much sense to provide a separate function declaration, but rather define a function in-place, using <em>function literals</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two types of function literals in Kotlin: <em>lambda literals</em> and <em>anonymous function declarations</em>. </span><span class="sentence">Both of these provide a way of defining a function in-place, but have subtle differences.</span></p>
</div>
<h4 id="anonymous-function-declarations">Anonymous function declarations</h4>
<div id="grammar-rule-anonymousFunction-pasted-45" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-parametersWithOptionalType">parametersWithOptionalType</a></em><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Anonymous function declarations</em>, despite the name, are not actually declarations, but rather an expression that resembles a function declaration. </span><span class="sentence">They have syntax very similar to the function declaration syntax, but with a few differences:</span></p>
</div>
<ul>
<li><span class="sentence">Anonymous functions do not have a name (obviously);</span></li>
<li><span class="sentence">Anonymous functions may not have type parameters <span><span class="TODO">(TODO(): check!!!)</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence">Anonymous functions may not have default parameters <span><span class="TODO">(TODO(): check!!!)</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence">Anonymous functions may have variable argument parameters, but they are automatically decayed to non-variable argument parameters of array type <span><span class="TODO">(TODO(): how does this really work?)</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Anonymous function declaration may declare anonymous extension functions. </span><span class="sentence">The type of an anonymous function declaration is the function type constructed similarly to the corresponding [named function declaration][Function declarations].</span></p>
</div>
<h4 id="lambda-literals">Lambda literals</h4>
<div id="grammar-rule-lambdaLiteral-pasted-46" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'{'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-statements">statements</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'}'</code>)<br />
| (<code>'{'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} [<em><a href="syntax.html#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-statements">statements</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters-pasted-47" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter-pasted-48" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="syntax.html#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Lambda literals TODO()</span></p>
</div>
<h3 id="object-literals">Object literals</h3>
<div id="grammar-rule-objectLiteral-pasted-49" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-classBody">classBody</a></em>)<br />
| (<code>'object'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Object literals are a way of defining anonymous objects in Kotlin. </span><span class="sentence">Anonymous objects are similar to regular objects, but they (obviously) have no name and thus can (only) be used as expressions. </span><span class="sentence">Anonymous objects, just like regular object declarations, can have at most one base class and many base interfaces declared in its delegation specifiers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between the regular object declaration and an anonymous object is its type. </span><span class="sentence">The type of an anonymous object is a special kind of type that is usable (and visible) only in the scope where it is declared. </span><span class="sentence">It is similar to a type that could be normally declared with a corresponding object declaration, but cannot be used outside the scope, leading to interesting effects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a value of this type escapes current scope:</span></p>
</div>
<ul>
<li><span class="sentence">If the type has only one declared supertype, it is implicitly downcasted to this declared supertype;</span></li>
<li><span class="sentence">If the type has several declared supertypes, there must be an explicit cast to any suitable type visible outside the scope, otherwise a compiler error is generated.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Please not that in this context “escaping” current scope is performed immediately if the corresponding value is declared as a global or classifier-scope property, as those are a part of package interface.</span></p>
</div>
<h3 id="this-expressions">This-expressions</h3>
<div id="grammar-rule-thisExpression-pasted-50" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">This-expressions are a special kind of expressions used to access available receivers in current scope. </span><span class="sentence">For more information about receivers, please refer to the <a href="overload-resolution.html#receivers">overloading section</a>. </span><span class="sentence">The basic form of this expression, denoted by <code>this</code> keyword, is used to access the current implicit receiver according to receiver overloading rules. </span><span class="sentence">In order to access other receivers, labeled <code>this</code> expressions are used. </span><span class="sentence">These may be any of the following:</span></p>
</div>
<ul>
<li><span class="sentence"><code>this@</code><span class="math inline">\(type\)</span> where <span class="math inline">\(type\)</span> is a name of any classifier that is currently being declared (that is, this this-expression is located inside its declaration’s inner scope) refers to the implicit object of the type being declared;</span></li>
<li><span class="sentence"><code>this@</code><span class="math inline">\(function\)</span> where <span class="math inline">\(function\)</span> is a name of a function currently being declared (that is, this this-expression is located inside the function body) refers to the implicit receiver object of this function (if it is an extension function) or is illegal and generates a compiler error.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Any other form of this-expression is illegal and generates a compiler error.</span></p>
</div>
<h3 id="super-forms">Super-forms</h3>
<div id="grammar-rule-superExpression-pasted-51" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> <em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Super form is a special kind of expression that can only be used as the receiver of a function or property access expression. </span><span class="sentence">Any usage of such an expression in any other context is prohibited.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Super forms are used in classifier declarations to access the method implementations from base classifier types without invoking overriding behaviour.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="jump-expressions">Jump expressions</h3>
<div id="grammar-rule-jumpExpression-pasted-52" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="syntax.html#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Jump expressions</em> are a group of expressions that redirect the order the program is evaluated to a different program point when evaluated. </span><span class="sentence">All these expressions have several things in common:</span></p>
</div>
<ul>
<li><span class="sentence">They all have type <code>kotlin.Nothing</code>, effectively meaning that they never produce any runtime value;</span></li>
<li><span class="sentence">Any code that unconditionally follows such expression is never evaluated.</span></li>
</ul>
<h4 id="throw-expressions">Throw expressions</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): [Exceptions] go first</span></p>
</div>
</div>
<h4 id="return-expressions">Return expressions</h4>
<div class="paragraph">
<p><span class="sentence">A <em>return expression</em>, when used inside a function body, immediately stops evaluating the function and returns to the point where this function was called, making the function call expression evaluate to the value specified in this return expression (if any). </span><span class="sentence">A return expression with no value implicitly returns the <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of return expression: a simple return expression, specified using the <code>return</code> keyword, returning from the innermost <a href="type-system.html#function-declaration">function declaration</a> (or [anonymous function expression][Anonymous function expression]) and the extended return expression, using the form <code>return@</code><span class="math inline">\(Context\)</span> where <span class="math inline">\(Context\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">The name of one of the enclosing function declarations to refer to this function. </span><span class="sentence">If several declarations match one name, an ambiguity compiler error is generated;</span></li>
<li><span class="sentence">If current expression is inside a lambda expression body, the name of the function using this lambda expression as a trailing lambda <span><span class="TODO">(TODO: Wut?)</span><span class="TODO-marker">*</span></span> parameter may be used to refer to the lambda literal itself.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If returning from the referred function is allowed in current context, the return is performed as usual. </span><span class="sentence">If returning from the referred function is not allowed, a compiler error is generated.</span></p>
</div>
<h4 id="continue-expression">Continue expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>continue expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the start of the next loop iteration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of continue expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple continue expression, specified using the <code>continue</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">An extended continue expression, denoted <code>continue@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): as a matter of fact, <code>continue</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
</div>
<h4 id="break-expression">Break expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>break expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the next program point after the loop.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of break expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple break expression, specified using the <code>break</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">An extended break expression, denoted <code>break@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): as a matter of fact, <code>break</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
</div>
<h3 id="operator-expressions">Operator expressions</h3>
<h4 id="spread-operator">Spread operator</h4>
<h3 id="safe-call-expression">Safe call expression</h3>
<h3 id="type-check-expression">Type check expression</h3>
</body>
</html>
