<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/css/main.css">
  <script src="../assets/js/katex/katex.min.js"></script><script src="../assets/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="../assets/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>


















<h2 id="statements">Statements</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
</dd>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em>labelDefinition</em>}<br />
( <em>declaration</em><br />
| <em>assignment</em><br />
| <em>loopStatement</em><br />
| <em>expression</em>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin statements include bare expressions and declarations. </span><span class="sentence">This section is focused on those statements that are <em>not</em> expressions or declarations. </span><span class="sentence">For information about expressions and declarations please refer to the corresponding sections of this document.</span></p>
</div>
<h3 id="assignments">Assignments</h3>
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence"><em>directlyAssignableExpression</em> <code>=</code> {<em>NL</em>} <em>expression</em><br />
| <em>assignableExpression</em> <em>assignmentAndOperator</em> {<em>NL</em>} <em>expression</em></span>
</dd>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>+=</code><br />
| <code>-=</code><br />
| <code>*=</code><br />
| <code>/=</code><br />
| <code>%=</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">An <em>assignment</em> is a statement that writes a new value to some location, denoted by its left hand side. </span><span class="sentence">Both left-hand and right-hand sides of an assignment are expressions, although there are several restrictions for the expression on the left hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For an expression to be <em>assignable</em>, i.e. be allowed to occur on the left-hand side of an assignment, it <strong>must</strong> be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">An identifier referring to a mutable property;</span></li>
<li><span class="sentence">A navigation expression referring to a mutable property;</span></li>
<li><span class="sentence">An [indexing expression][Indexing expression], see details below.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin assignments <strong>are not</strong> expressions and cannot be used as such.</span></p>
</div>
<h4 id="simple-assignment">Simple assignment</h4>
<div class="paragraph">
<p><span class="sentence">A <em>simple assigment</em> is the assignment form employing the assign operator <code>=</code>. </span><span class="sentence">If the left-hand side of the assignment refers to a mutable property, a mutation of that property is performed when the assignment is evaluated:</span></p>
</div>
<ul>
<li><span class="sentence">If the property is [delegated][Property delegation], the corresponding operator function <code>setValue</code> is called using the right-hand side expression value as value argument;</span></li>
<li><span class="sentence">If the property has a setter, it is called using the right-hand side expression value as value argument;</span></li>
<li><span class="sentence">If the property is just a variable without delegation or setter, it’s value is directly changed to the value of the right-hand side expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the left-hand side of the assignment is an indexing expression, the whole statement is treated as an overloaded operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,…,<span class="math inline">\(B_N\)</span><code>] =</code><span class="math inline">\(C\)</span> is exactly the same as calling <span class="math inline">\(A\)</span><code>.set(</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,…,<span class="math inline">\(B_N\)</span>,<span class="math inline">\(C\)</span><code>)</code> where <code>set</code> is a sutable <code>operator</code> function.</span></p>
</div>
<h4 id="operator-assignments">Operator assignments</h4>
<div class="paragraph">
<p><span class="sentence">An <em>operator assignment</em> is a combined-form assignment that involves one of the following operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>. </span><span class="sentence">All these are overloadable operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.plusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.minusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.timesAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>timesAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>times</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.divAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>divAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>div</code> operator function exists and is available;</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.remAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>remAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>rem</code> operator function exists and is available.</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The expanded simple assignment is then proceeded as described in the previous section.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Although for most real-world usecases operators <code>++</code> and <code>--</code> are very similar to operator assignments, in Kotlin they are actually expressions and are described as such in the <a href="expressions-1.html#expressions-1">corresponding section</a> of this document.</span></p>
</div>
</blockquote>
<h3 id="loop-statements">Loop statements</h3>
<div class="paragraph">
<p><span class="sentence">Loop statements are constructs that repeat evaluating a certain number of statements until a <em>loop exit condition</em> applies.</span></p>
</div>
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em>forStatement</em><br />
| <em>whileStatement</em><br />
| <em>doWhileStatement</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Loops are closely related to the semantics of several <a href="expressions-1.html#jump-expressions-1">jump expressions</a>, as these expressions, namely <code>break</code> and <code>continue</code>, are only allowed in the body of a loop. </span><span class="sentence">Please refer to the corresponding section for details.</span></p>
</div>
<h4 id="while-loop">While loop</h4>
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <em>controlStructureBody</em><br />
| <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <code>;</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence"><em>While loop statement</em> is very similar to an <a href="expressions-1.html#conditional-expression-1"><code>if</code> expression</a> in the way that it contains a condition expression and a body consisting of one or more statements. </span><span class="sentence">While loop repeats evaluating its body for as long as the condition expression evaluates to true or a <a href="expressions-1.html#jump-expressions-1">jump expression</a> is evaluated to finish the loop.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that the condition expression is evaluated before every evaluation of the body, including the first one.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="do-while-loop">Do-while loop</h4>
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>do</code> {<em>NL</em>} [<em>controlStructureBody</em>] {<em>NL</em>} <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>do-while statement</em> is very similar to the while statement, but with a few differences. </span><span class="sentence">First, it has a different syntax. </span><span class="sentence">Second, it evaluates the loop condition expression <strong>after</strong> evaluating the loop body.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that the body is always evaluated at least once</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="for-loop">For loop</h4>
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>for</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} (variableDeclaration | <em>multiVariableDeclaration</em>) <code>in</code> <em>expression</em> <code>)</code> {<em>NL</em>} [<em>controlStructureBody</em>]</span>
</dd>
</dl>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike other languages, Kotlin does not have a free-form condition-based for loops. </span><span class="sentence">The only form of for-loop available in Kotlin is (what it’s called in other languages) “the foreach loop”, iterating over arrays and other datastructures</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>for statement</em> is a special kind of loop statements that is used to iterate over data structures containing a number of elements. </span><span class="sentence">The for loop consists of a loop body, a <strong>container expression</strong> and the <strong>iteration variable declaration</strong>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The for loop is actually an [overloadable][Overloadable operators] syntax form with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>for(</code><span class="math inline">\(VarDecl\)</span><code>) in</code><span class="math inline">\(C\)</span><code>) $Body$</code> is exactly the same as</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">val</span> <span class="va">__iterator</span> = C.iterator()</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="cf">while</span>(__iterator.hasNext()) {</a>
<a class="sourceLine" id="cb1-3" title="3">    VarDecl = __iterator.next()</a>
<a class="sourceLine" id="cb1-4" title="4">    &lt;... all the statements from Body&gt;</a>
<a class="sourceLine" id="cb1-5" title="5">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>iterator</code>, <code>hasNext</code>, <code>next</code> are all acceptable operator functions available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Please note that expansions are hygenic, meaning the generated iterator variable never clashes with any other values in the program and cannot be accessed outside the expansion</span></p>
</div>
</blockquote>
<h3 id="code-blocks">Code blocks</h3>
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
</dd>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>code block</em> is a series of statements between curly braces separated by newlines or/and semicolons. </span><span class="sentence">A code block may be empty. </span><span class="sentence">Evaluating a code block means evaluating all its statements in the order they are given inside it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <em>last expression</em> of a code block is the last statement in the block (if any) if and only if this statement is also an expression. </span><span class="sentence">The last expressions are important when defining functions and control structure expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The code block is said to contain no last expression if it does not contain any statements of the last statement is not an expression (e.g. it is an assignment, a loop or a declaration).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This usually means that a synthetic last expression with no runtime semantics and with type <code>kotlin.Unit</code> is introduced instead</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>control structure body</em> is either a single statement or a code block. </span><span class="sentence">The <em>last expression</em> of a control structure body is either the last expression of the code block (if it is a code block) or the single statement itself if it is an expression. </span><span class="sentence">If the control structure body is not a code block or an expression, it has no last expression.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This is usually equivalent to wrapping the single statement in a new synthetic code block</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In some contexts, a control structure body is expected to have a value and/or a type. </span><span class="sentence">The value of a control structure body is:</span></p>
</div>
<ul>
<li><span class="sentence">The value of its last expression if it exists;</span></li>
<li><span class="sentence">The singleton <code>kotlin.Unit</code> object otherwise.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The <em>type of a control structure body</em> is the type of its value.</span></p>
</div>
<h3 id="todo">TODO</h3>
<ul>
<li><span class="sentence">Are declarations statements or not?</span>
<ul>
<li><span class="sentence">In the current grammar, they are</span></li>
</ul></li>
<li><span class="sentence">Wording</span></li>
<li><span class="sentence">Mutable vs immutable properties</span></li>
<li><span class="sentence">How expansions with new variables actually work</span></li>
</ul>
</body>
</html>
