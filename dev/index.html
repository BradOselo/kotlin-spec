<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./assets/css/main.css">
  <script src="./assets/js/katex/katex.min.js"></script><script src="./assets/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="./assets/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="./assets/js/jquery-3.4.1.min.js"></script>
  <script src="./assets/js/lodash.js"></script>
  <script src="https://unpkg.com/kotlin-playground@1"></script>
  <script src="./assets/js/helpers.js"></script>
  <script src="./assets/js/Popup.js"></script>
  <script src="./assets/js/compiler-tests-integration/SpecTestsLoader.js"></script>
  <script src="./assets/js/compiler-tests-integration/SpecTestsParser.js"></script>
  <script src="./assets/js/compiler-tests-integration/SpecTestsViewer.js"></script>
  <script src="./assets/js/compiler-tests-integration/TestsCoverageColorsArranger.js"></script>
  <script src="./assets/js/compiler-tests-integration/handlers.js"></script>
  <script src="./assets/js/sentenceHighlighter.js"></script>
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#glossary">Glossary</a></li>
<li><a href="#kotlincore">Kotlin/Core</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#syntax">Syntax</a><ul>
<li><a href="#grammar">Grammar</a><ul>
<li><a href="#lexical-grammar">Lexical grammar</a><ul>
<li><a href="#character-classes">Character classes</a></li>
<li><a href="#keywords-and-operators">Keywords and operators</a></li>
<li><a href="#whitespace-and-comments">Whitespace and comments</a></li>
<li><a href="#number-literals">Number literals</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#string-literals">String literals</a></li>
<li><a href="#misc">Misc</a></li>
</ul></li>
<li><a href="#syntax-grammar">Syntax grammar</a></li>
<li><a href="#documentation-comments">Documentation comments</a></li>
</ul></li>
</ul></li>
<li><a href="#type-system">Type system</a><ul>
<li><a href="#glossary-1">Glossary</a></li>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#type-kinds">Type kinds</a><ul>
<li><a href="#built-in-types">Built-in types</a><ul>
<li><a href="#kotlin.any"><code>kotlin.Any</code></a></li>
<li><a href="#kotlin.nothing"><code>kotlin.Nothing</code></a></li>
<li><a href="#kotlin.unit"><code>kotlin.Unit</code></a></li>
</ul></li>
<li><a href="#classifier-types">Classifier types</a><ul>
<li><a href="#simple-classifier-types">Simple classifier types</a></li>
<li><a href="#parameterized-classifier-types">Parameterized classifier types</a></li>
<li><a href="#type-parameters">Type parameters</a><ul>
<li><a href="#bounded-type-parameters">Bounded type parameters</a></li>
<li><a href="#mixed-site-variance">Mixed-site variance</a></li>
<li><a href="#declaration-site-variance">Declaration-site variance</a></li>
<li><a href="#use-site-variance">Use-site variance</a></li>
</ul></li>
<li><a href="#type-capturing">Type capturing</a></li>
</ul></li>
<li><a href="#function-types">Function types</a></li>
<li><a href="#array-types">Array types</a></li>
<li><a href="#flexible-types">Flexible types</a><ul>
<li><a href="#platform-types">Platform types</a></li>
</ul></li>
<li><a href="#nullable-types">Nullable types</a></li>
</ul></li>
<li><a href="#subtyping">Subtyping</a><ul>
<li><a href="#subtyping-rules">Subtyping rules</a></li>
<li><a href="#subtyping-for-flexible-types">Subtyping for flexible types</a></li>
<li><a href="#subtyping-for-nullable-types">Subtyping for nullable types</a></li>
</ul></li>
<li><a href="#generics">Generics</a></li>
<li><a href="#references">References</a></li>
<li><a href="#glossary-2">Glossary</a></li>
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#classifier-declaration">Classifier declaration</a><ul>
<li><a href="#class-declaration">Class declaration</a><ul>
<li><a href="#constructor-declaration">Constructor declaration</a></li>
<li><a href="#nested-and-inner-classes">Nested and inner classes</a></li>
<li><a href="#inheritance-delegation">Inheritance delegation</a></li>
</ul></li>
<li><a href="#data-class-declaration">Data class declaration</a><ul>
<li><a href="#data-class-generation">Data class generation</a></li>
</ul></li>
<li><a href="#enum-class-declaration">Enum class declaration</a></li>
<li><a href="#annotation-class-declaration">Annotation class declaration</a></li>
<li><a href="#interface-declaration">Interface declaration</a></li>
<li><a href="#object-declaration">Object declaration</a></li>
<li><a href="#anonymous-object-declaration">Anonymous object declaration</a></li>
<li><a href="#classifier-initialization">Classifier initialization</a></li>
</ul></li>
<li><a href="#function-declaration">Function declaration</a><ul>
<li><a href="#named-positional-and-default-parameters">Named, positional and default parameters</a></li>
<li><a href="#variable-length-parameters">Variable length parameters</a></li>
<li><a href="#function-type-parameters">Function type parameters</a></li>
<li><a href="#extension-function-declaration">Extension function declaration</a></li>
<li><a href="#anonymous-function-declaration">Anonymous function declaration</a></li>
</ul></li>
<li><a href="#property-declaration">Property declaration</a><ul>
<li><a href="#read-only-property-declaration">Read-only property declaration</a></li>
<li><a href="#mutable-property-declaration">Mutable property declaration</a></li>
<li><a href="#delegated-property-declaration">Delegated property declaration</a></li>
<li><a href="#local-property-declaration">Local property declaration</a></li>
<li><a href="#getters-and-setters">Getters and setters</a></li>
<li><a href="#property-initialization">Property initialization</a></li>
</ul></li>
<li><a href="#type-alias">Type alias</a></li>
<li><a href="#declarations-with-type-parameters">Declarations with type parameters</a></li>
<li><a href="#declaration-modifiers">Declaration modifiers</a></li>
</ul></li>
<li><a href="#visibility">Visibility</a></li>
<li><a href="#statements">Statements</a><ul>
<li><a href="#assignments">Assignments</a><ul>
<li><a href="#simple-assignment">Simple assignment</a></li>
<li><a href="#operator-assignments">Operator assignments</a></li>
</ul></li>
<li><a href="#loop-statements">Loop statements</a><ul>
<li><a href="#while-loop">While loop</a></li>
<li><a href="#do-while-loop">Do-while loop</a></li>
<li><a href="#for-loop">For loop</a></li>
</ul></li>
<li><a href="#code-blocks">Code blocks</a></li>
<li><a href="#todo">TODO</a></li>
</ul></li>
<li><a href="#expressions">Expressions</a><ul>
<li><a href="#constant-literals">Constant literals</a><ul>
<li><a href="#boolean-literals">Boolean literals</a></li>
<li><a href="#integer-literals">Integer literals</a><ul>
<li><a href="#decimal-integer-literals">Decimal integer literals</a></li>
<li><a href="#hexadecimal-integer-literals">Hexadecimal integer literals</a></li>
<li><a href="#binary-integer-literals">Binary integer literals</a></li>
</ul></li>
<li><a href="#real-literals">Real literals</a></li>
<li><a href="#character-literals">Character literals</a></li>
<li><a href="#string-literals-1">String literals</a></li>
<li><a href="#null-literal">Null literal</a></li>
</ul></li>
<li><a href="#try-expression">Try-expression</a></li>
<li><a href="#conditional-expression">Conditional expression</a></li>
<li><a href="#when-expression">When expression</a><ul>
<li><a href="#exhaustive-when-expressions">Exhaustive when expressions</a></li>
</ul></li>
<li><a href="#logical-disjunction-expression">Logical disjunction expression</a></li>
<li><a href="#logical-conjunction-expression">Logical conjunction expression</a></li>
<li><a href="#equality-expressions">Equality expressions</a><ul>
<li><a href="#reference-equality-expressions">Reference equality expressions</a></li>
<li><a href="#value-equality-expressions">Value equality expressions</a></li>
</ul></li>
<li><a href="#comparison-expressions">Comparison expressions</a></li>
<li><a href="#type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</a><ul>
<li><a href="#type-checking-expression">Type-checking expression</a><ul>
<li><a href="#todo-1">TODO()</a></li>
</ul></li>
<li><a href="#containment-checking-expression">Containment-checking expression</a></li>
</ul></li>
<li><a href="#elvis-operator-expression">Elvis operator expression</a></li>
<li><a href="#range-expression">Range expression</a></li>
<li><a href="#additive-expression">Additive expression</a></li>
<li><a href="#multiplicative-expression">Multiplicative expression</a></li>
<li><a href="#cast-expression">Cast expression</a><ul>
<li><a href="#todo-2">TODO()</a></li>
</ul></li>
<li><a href="#prefix-expressions">Prefix expressions</a><ul>
<li><a href="#annotated-and-labeled-expression">Annotated and labeled expression</a></li>
<li><a href="#prefix-increment-expression">Prefix increment expression</a></li>
<li><a href="#prefix-decrement-expression">Prefix decrement expression</a></li>
<li><a href="#unary-minus-expression">Unary minus expression</a></li>
<li><a href="#unary-plus-expression">Unary plus expression</a></li>
<li><a href="#logical-not-expression">Logical not expression</a></li>
</ul></li>
<li><a href="#postfix-operator-expressions">Postfix operator expressions</a><ul>
<li><a href="#postfix-increment-expression">Postfix increment expression</a></li>
<li><a href="#postfix-decrement-expression">Postfix decrement expression</a></li>
</ul></li>
<li><a href="#not-null-assertion-expression">Not-null assertion expression</a></li>
<li><a href="#indexing-expressions">Indexing expressions</a></li>
<li><a href="#call-and-property-access-expressions">Call and property access expressions</a><ul>
<li><a href="#the-navigation-operators">The navigation operators</a></li>
</ul></li>
<li><a href="#function-literals">Function Literals</a><ul>
<li><a href="#anonymous-function-declarations">Anonymous function declarations</a></li>
<li><a href="#lambda-literals">Lambda literals</a></li>
</ul></li>
<li><a href="#object-literals">Object literals</a></li>
<li><a href="#this-expressions">This-expressions</a></li>
<li><a href="#super-forms">Super-forms</a></li>
<li><a href="#jump-expressions">Jump expressions</a><ul>
<li><a href="#throw-expressions">Throw expressions</a></li>
<li><a href="#return-expressions">Return expressions</a></li>
<li><a href="#continue-expression">Continue expression</a></li>
<li><a href="#break-expression">Break expression</a></li>
</ul></li>
<li><a href="#operator-expressions">Operator expressions</a><ul>
<li><a href="#spread-operator">Spread operator</a></li>
</ul></li>
<li><a href="#safe-call-expression">Safe call expression</a></li>
<li><a href="#type-check-expression">Type check expression</a></li>
</ul></li>
<li><a href="#todos">TODOS()</a></li>
<li><a href="#packages-and-imports">Packages and imports</a><ul>
<li><a href="#importing">Importing</a></li>
<li><a href="#modules">Modules</a></li>
</ul></li>
<li><a href="#overload-resolution">Overload resolution</a><ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#receivers">Receivers</a></li>
<li><a href="#the-forms-of-call-expression">The forms of call-expression</a></li>
<li><a href="#callables-and-invoke-convention">Callables and invoke convention</a></li>
<li><a href="#overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</a></li>
<li><a href="#a-call-with-an-explicit-receiver">A call with an explicit receiver</a></li>
<li><a href="#infix-function-calls">Infix function calls</a></li>
<li><a href="#operator-calls">Operator calls</a></li>
<li><a href="#a-call-without-an-explicit-receiver">A call without an explicit receiver</a></li>
<li><a href="#calls-with-named-parameters">Calls with named parameters</a></li>
<li><a href="#calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</a></li>
<li><a href="#calls-with-specified-type-parameters">Calls with specified type parameters</a></li>
<li><a href="#determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</a><ul>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#description">Description</a></li>
</ul></li>
<li><a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</a><ul>
<li><a href="#rationale-1">Rationale</a></li>
<li><a href="#description-1">Description</a></li>
</ul></li>
<li><a href="#about-type-inference">About type inference</a><ul>
<li><a href="#todo-3">TODO:</a></li>
</ul></li>
<li><a href="#type-constraint-definition">Type constraint definition</a></li>
<li><a href="#type-constraint-solving">Type constraint solving</a><ul>
<li><a href="#checking-constraint-system-soundness">Checking constraint system soundness</a></li>
<li><a href="#finding-optimal-solution">Finding optimal solution</a></li>
</ul></li>
<li><a href="#smart-casts">Smart casts</a></li>
<li><a href="#local-type-inference">Local type inference</a></li>
<li><a href="#todo-4">TODO</a></li>
<li><a href="#runtime-available-types">Runtime-available types</a></li>
</ul></li>
<li><a href="#expressions-1">Expressions</a><ul>
<li><a href="#constant-literals-1">Constant literals</a><ul>
<li><a href="#boolean-literals-1">Boolean literals</a></li>
<li><a href="#integer-literals-1">Integer literals</a><ul>
<li><a href="#decimal-integer-literals-1">Decimal integer literals</a></li>
<li><a href="#hexadecimal-integer-literals-1">Hexadecimal integer literals</a></li>
<li><a href="#binary-integer-literals-1">Binary integer literals</a></li>
</ul></li>
<li><a href="#real-literals-1">Real literals</a></li>
<li><a href="#character-literals-1">Character literals</a></li>
<li><a href="#string-literals-2">String literals</a></li>
<li><a href="#null-literal-1">Null literal</a></li>
</ul></li>
<li><a href="#try-expression-1">Try-expression</a></li>
<li><a href="#conditional-expression-1">Conditional expression</a></li>
<li><a href="#when-expression-1">When expression</a><ul>
<li><a href="#exhaustive-when-expressions-1">Exhaustive when expressions</a></li>
</ul></li>
<li><a href="#logical-disjunction-expression-1">Logical disjunction expression</a></li>
<li><a href="#logical-conjunction-expression-1">Logical conjunction expression</a></li>
<li><a href="#equality-expressions-1">Equality expressions</a><ul>
<li><a href="#reference-equality-expressions-1">Reference equality expressions</a></li>
<li><a href="#value-equality-expressions-1">Value equality expressions</a></li>
</ul></li>
<li><a href="#comparison-expressions-1">Comparison expressions</a></li>
<li><a href="#type-checking-and-containment-checking-expressions-1">Type-checking and containment-checking expressions</a><ul>
<li><a href="#type-checking-expression-1">Type-checking expression</a><ul>
<li><a href="#todo-5">TODO()</a></li>
</ul></li>
<li><a href="#containment-checking-expression-1">Containment-checking expression</a></li>
</ul></li>
<li><a href="#elvis-operator-expression-1">Elvis operator expression</a></li>
<li><a href="#range-expression-1">Range expression</a></li>
<li><a href="#additive-expression-1">Additive expression</a></li>
<li><a href="#multiplicative-expression-1">Multiplicative expression</a></li>
<li><a href="#cast-expression-1">Cast expression</a><ul>
<li><a href="#todo-6">TODO()</a></li>
</ul></li>
<li><a href="#prefix-expressions-1">Prefix expressions</a><ul>
<li><a href="#annotated-and-labeled-expression-1">Annotated and labeled expression</a></li>
<li><a href="#prefix-increment-expression-1">Prefix increment expression</a></li>
<li><a href="#prefix-decrement-expression-1">Prefix decrement expression</a></li>
<li><a href="#unary-minus-expression-1">Unary minus expression</a></li>
<li><a href="#unary-plus-expression-1">Unary plus expression</a></li>
<li><a href="#logical-not-expression-1">Logical not expression</a></li>
</ul></li>
<li><a href="#postfix-operator-expressions-1">Postfix operator expressions</a><ul>
<li><a href="#postfix-increment-expression-1">Postfix increment expression</a></li>
<li><a href="#postfix-decrement-expression-1">Postfix decrement expression</a></li>
</ul></li>
<li><a href="#not-null-assertion-expression-1">Not-null assertion expression</a></li>
<li><a href="#indexing-expressions-1">Indexing expressions</a></li>
<li><a href="#call-and-property-access-expressions-1">Call and property access expressions</a><ul>
<li><a href="#the-navigation-operators-1">The navigation operators</a></li>
</ul></li>
<li><a href="#function-literals-1">Function Literals</a><ul>
<li><a href="#anonymous-function-declarations-1">Anonymous function declarations</a></li>
<li><a href="#lambda-literals-1">Lambda literals</a></li>
</ul></li>
<li><a href="#object-literals-1">Object literals</a></li>
<li><a href="#this-expressions-1">This-expressions</a></li>
<li><a href="#super-forms-1">Super-forms</a></li>
<li><a href="#jump-expressions-1">Jump expressions</a><ul>
<li><a href="#throw-expressions-1">Throw expressions</a></li>
<li><a href="#return-expressions-1">Return expressions</a></li>
<li><a href="#continue-expression-1">Continue expression</a></li>
<li><a href="#break-expression-1">Break expression</a></li>
</ul></li>
<li><a href="#operator-expressions-1">Operator expressions</a><ul>
<li><a href="#spread-operator-1">Spread operator</a></li>
</ul></li>
<li><a href="#safe-call-expression-1">Safe call expression</a></li>
<li><a href="#type-check-expression-1">Type check expression</a></li>
</ul></li>
<li><a href="#todos-1">TODOS()</a></li>
</ul></li>
</ul>
</nav>


















<h1 id="glossary">Glossary</h1>
<div class="paragraph">
<p><span class="sentence">w.r.t.:: with respect to</span></p>
</div>
<h1 id="kotlincore">Kotlin/Core</h1>
<h2 id="introduction">Introduction</h2>
<div class="paragraph">
<p><span class="sentence">Here be dragons…</span></p>
</div>
<h2 id="syntax">Syntax</h2>
<h3 id="grammar">Grammar</h3>
<h4 id="lexical-grammar">Lexical grammar</h4>
<h5 id="character-classes">Character classes</h5>
<div id="grammar-rule-LF" class="grammar-rule">
<dl>
<dt><strong><em>LF</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Line Feed U+000A&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-CR" class="grammar-rule">
<dl>
<dt><strong><em>CR</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Carriage Return U+000D&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-WS" class="grammar-rule">
<dl>
<dt><strong><em>WS</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;one of the following characters: SPACE U+0020, TAB U+0009, Form Feed U+000C&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-Underscore" class="grammar-rule">
<dl>
<dt><strong><em>Underscore</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Low Line U+005F&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-Letter" class="grammar-rule">
<dl>
<dt><strong><em>Letter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character from classes Ll, Lm, Lo, Lt, Lu or Nl&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-UnicodeDigit" class="grammar-rule">
<dl>
<dt><strong><em>UnicodeDigit</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character from class Nd&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineCharacter" class="grammar-rule">
<dl>
<dt><strong><em>LineCharacter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character excluding LF and CR&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinaryDigit" class="grammar-rule">
<dl>
<dt><strong><em>BinaryDigit</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> | <code>'1'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecimalDigit" class="grammar-rule">
<dl>
<dt><strong><em>DecimalDigit</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> | <code>'1'</code> | <code>'2'</code> | <code>'3'</code> | <code>'4'</code> | <code>'5'</code> | <code>'6'</code> | <code>'7'</code> | <code>'8'</code> | <code>'9'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexDigit" class="grammar-rule">
<dl>
<dt><strong><em>HexDigit</em>:</strong></dt>
<dd><span class="sentence"><em>DecimalDigit</em><br />
| <code>'A'</code> | <code>'B'</code> | <code>'C'</code> | <code>'D'</code> | <code>'E'</code> | <code>'F'</code><br />
| <code>'a'</code> | <code>'b'</code> | <code>'c'</code> | <code>'d'</code> | <code>'e'</code> | <code>'f'</code></span>
</dd>
</dl>
</div>
<h5 id="keywords-and-operators">Keywords and operators</h5>
<dl>
<dt><strong><em>Operator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code> | <code>','</code> | <code>'('</code> | <code>')'</code> | <code>'['</code> | <code>']'</code> | <code>'@['</code> | <code>'{'</code> | <code>'}'</code> | <code>'*'</code> | <code>'%'</code> | <code>'/'</code> | <code>'+'</code> | <code>'-'</code> | <code>'++'</code> | <code>'--'</code><br />
| <code>'&amp;&amp;'</code> | <code>'||'</code> | <code>'!'</code> | <code>'!!'</code> | <code>':'</code> | <code>';'</code> | <code>'='</code> | <code>'+='</code> | <code>'-='</code> | <code>'*='</code> | <code>'/='</code> | <code>'%='</code> | <code>'-&gt;'</code> | <code>'=&gt;'</code><br />
| <code>'..'</code> | <code>'::'</code> | <code>'?::'</code> | <code>';;'</code> | <code>'#'</code> | <code>'@'</code> | <code>'?'</code> | <code>'?:'</code> | <code>'&lt;'</code> | <code>'&gt;'</code> | <code>'\m'</code> | <code>'&gt;='</code> | <code>'!='</code> | <code>'!=='</code><br />
| <code>'=='</code> | <code>'==='</code> | <code>'''</code> | <code>'&quot;'</code> | <code>'&quot;&quot;&quot;'</code></span>
</dd>
<dt><strong><em>SoftKeyword</em>:</strong></dt>
<dd><span class="sentence"><code>'public'</code> | <code>'private'</code> | <code>'protected'</code> | <code>'internal'</code><br />
| <code>'enum'</code> | <code>'sealed'</code> | <code>'annotation'</code> | <code>'data'</code> | <code>'inner'</code><br />
| <code>'tailrec'</code> | <code>'operator'</code> | <code>'inline'</code> | <code>'infix'</code> | <code>'external'</code><br />
| <code>'suspend'</code> | <code>'override'</code> | <code>'abstract'</code> | <code>'final'</code> | <code>'open'</code><br />
| <code>'const'</code> | <code>'lateinit'</code> | <code>'vararg'</code> | <code>'noinline'</code> | <code>'crossinline'</code><br />
| <code>'reified'</code> | <code>'expect'</code> | <code>'actual'</code></span>
</dd>
<dt><strong><em>Keyword</em>:</strong></dt>
<dd><span class="sentence"><code>'package'</code> | <code>'import'</code> | <code>'class'</code> | <code>'interface'</code><br />
| <code>'fun'</code> | <code>'object'</code> | <code>'val'</code> | <code>'var'</code> | <code>'typealias'</code><br />
| <code>'constructor'</code> | <code>'by'</code> | <code>'companion'</code> | <code>'init'</code><br />
| <code>'this'</code> | <code>'super'</code> | <code>'typeof'</code> | <code>'where'</code><br />
| <code>'if'</code> | <code>'else'</code> | <code>'when'</code> | <code>'try'</code> | <code>'catch'</code><br />
| <code>'finally'</code> | <code>'for'</code> | <code>'do'</code> | <code>'while'</code> | <code>'throw'</code><br />
| <code>'return'</code> | <code>'continue'</code> | <code>'break'</code> | <code>'as'</code><br />
| <code>'is'</code> | <code>'in'</code> | <code>'!is'</code> | <code>'!in'</code> | <code>'out'</code><br />
| <code>'get'</code> | <code>'set'</code> | <code>'dynamic'</code> | <code>'@file'</code><br />
| <code>'@field'</code> | <code>'@property'</code> | <code>'@get'</code> | <code>'@set'</code><br />
| <code>'@receiver'</code> | <code>'@param'</code> | <code>'@setparam'</code> | <code>'@delegate'</code></span>
</dd>
</dl>
<h5 id="whitespace-and-comments">Whitespace and comments</h5>
<div id="grammar-rule-NL" class="grammar-rule">
<dl>
<dt><strong><em>NL</em>:</strong></dt>
<dd><span class="sentence"><em>LF</em> | <em>CR</em> [<em>LF</em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-ShebangLine" class="grammar-rule">
<dl>
<dt><strong><em>ShebangLine</em>:</strong></dt>
<dd><span class="sentence"><code>'#!'</code> {<em>LineCharacter</em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineComment" class="grammar-rule">
<dl>
<dt><strong><em>LineComment</em>:</strong></dt>
<dd><span class="sentence"><code>'//'</code> {<em>LineCharacter</em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-DelimitedComment" class="grammar-rule">
<dl>
<dt><strong><em>DelimitedComment</em>:</strong></dt>
<dd><span class="sentence"><code>'/*'</code> {<em>DelimitedComment</em> | &lt;any character&gt;} <code>'*/'</code></span>
</dd>
</dl>
</div>
<h5 id="number-literals">Number literals</h5>
<div id="grammar-rule-RealLiteral" class="grammar-rule">
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-FloatLiteral" class="grammar-rule">
<dl>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>'f'</code> | <code>'F'</code>) | <em>DecDigits</em> (<code>'f'</code> | <code>'F'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-DoubleLiteral" class="grammar-rule">
<dl>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>'.'</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LongLiteral" class="grammar-rule">
<dl>
<dt><strong><em>LongLiteral</em>:</strong></dt>
<dd><span class="sentence">(<em>IntegerLiteral</em> | <em>HexLiteral</em> | <em>BinLiteral</em>) <code>'L'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IntegerLiteral" class="grammar-rule">
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexLiteral" class="grammar-rule">
<dl>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> (<code>'x'</code>|<code>'X'</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>'0'</code> (<code>'x'</code>|<code>'X'</code>) <em>HexDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinLiteral" class="grammar-rule">
<dl>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> (<code>'b'</code>|<code>'B'</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>'0'</code> (<code>'b'</code>|<code>'B'</code>) <em>BinDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DegDigitNoZero" class="grammar-rule">
<dl>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>'0'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecDigitOrSeparator" class="grammar-rule">
<dl>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexDigitOrSeparator" class="grammar-rule">
<dl>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinDigitOrSeparator" class="grammar-rule">
<dl>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecDigits" class="grammar-rule">
<dl>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BooleanLiteral" class="grammar-rule">
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'true'</code> | <code>'false'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-NullLiteral" class="grammar-rule">
<dl>
<dt><strong><em>NullLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'null'</code></span>
</dd>
</dl>
</div>
<h5 id="identifiers">Identifiers</h5>
<div id="grammar-rule-Identifier" class="grammar-rule">
<dl>
<dt><strong><em>Identifier</em>:</strong></dt>
<dd><span class="sentence">(<em>Letter</em> | <em>Underscore</em>) {<em>Letter</em> | <em>Underscore</em> | <em>UnicodeDigit</em>}<br />
| <code>'`'</code> {<em>EscapedIdentifierCharacter</em>} <code>'`'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapedIdentifierCharacter" class="grammar-rule">
<dl>
<dt><strong><em>EscapedIdentifierCharacter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any character except CR, LF, <code>'`''</code>, <code>'['</code>, <code>']'</code>, <code>'&lt;'</code> or <code>'&gt;'</code>&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IdentifierOrSoftKey" class="grammar-rule">
<dl>
<dt><strong><em>IdentifierOrSoftKey</em>:</strong></dt>
<dd><span class="sentence"><em>Identifier</em> | <em>SoftKeyword</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-AtIdentifier" class="grammar-rule">
<dl>
<dt><strong><em>AtIdentifier</em>:</strong></dt>
<dd><span class="sentence"><code>'@'</code> <em>IdentifierOrSoftKey</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IdentifierAt" class="grammar-rule">
<dl>
<dt><strong><em>IdentifierAt</em>:</strong></dt>
<dd><span class="sentence"><em>IdentifierOrSoftKey</em> <code>'@'</code></span>
</dd>
</dl>
</div>
<h5 id="string-literals">String literals</h5>
<div class="paragraph">
<p><span class="sentence">Syntax literals are fully defined in syntax grammar due to the complex nature of string interpolation</span></p>
</div>
<div id="grammar-rule-CharacterLiteral" class="grammar-rule">
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'''</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'''</code> and <code>'\'</code>&gt;</em>) <code>'''</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapeSeq" class="grammar-rule">
<dl>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-UnicodeCharacterLiteral" class="grammar-rule">
<dl>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'\'</code> <code>'u'</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapedCharacter" class="grammar-rule">
<dl>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>'\'</code> (<code>'t'</code> | <code>'b'</code> | <code>'r'</code> | <code>'n'</code> | <code>'</code> | <code>'&quot;'</code> | <code>'\'</code> | <code>'$'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-FieldIdentifier" class="grammar-rule">
<dl>
<dt><strong><em>FieldIdentifier</em>:</strong></dt>
<dd><span class="sentence"><code>'$'</code> <em>IdentifierOrSoftKey</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrRef" class="grammar-rule">
<dl>
<dt><strong><em>LineStrRef</em>:</strong></dt>
<dd><span class="sentence"><em>FieldIdentifier</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrEscapedChar" class="grammar-rule">
<dl>
<dt><strong><em>LineStrEscapedChar</em>:</strong></dt>
<dd><span class="sentence"><em>EscapedCharacter</em> | <em>UnicodeCharacterLiteral</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrExprStart" class="grammar-rule">
<dl>
<dt><strong><em>LineStrExprStart</em>:</strong></dt>
<dd><span class="sentence"><code>'${'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStringQuote" class="grammar-rule">
<dl>
<dt><strong><em>MultiLineStringQuote</em>:</strong></dt>
<dd><span class="sentence"><code>'&quot;'</code> {<code>'&quot;'</code>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrRef" class="grammar-rule">
<dl>
<dt><strong><em>MultiLineStrRef</em>:</strong></dt>
<dd><span class="sentence"><em>FieldIdentifier</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrText" class="grammar-rule">
<dl>
<dt><strong><em>MultiLineStrText</em>:</strong></dt>
<dd><span class="sentence">{&lt;any character except <code>'&quot;'</code> and <code>'$'</code>} | <code>'$'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrExprStart" class="grammar-rule">
<dl>
<dt><strong><em>MultiLineStrExprStart</em>:</strong></dt>
<dd><span class="sentence"><code>'${'</code></span>
</dd>
</dl>
</div>
<h5 id="misc">Misc</h5>
<div id="grammar-rule-EOF" class="grammar-rule">
<dl>
<dt><strong><em>EOF</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;end of input&gt;</em></span>
</dd>
</dl>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: redo all the lexical grammar, right now it is a hand-written mess</span></p>
</div>
</div>
<h4 id="syntax-grammar">Syntax grammar</h4>
<div id="grammar-rule-kotlinFile" class="grammar-rule">
<dl>
<dt><strong><em>kotlinFile</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-shebangLine">shebangLine</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-fileAnnotation">fileAnnotation</a></em>}<br />
<em><a href="#grammar-rule-packageHeader">packageHeader</a></em><br />
<em><a href="#grammar-rule-importList">importList</a></em><br />
{<em><a href="#grammar-rule-topLevelObject">topLevelObject</a></em>}<br />
<em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-script" class="grammar-rule">
<dl>
<dt><strong><em>script</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-shebangLine">shebangLine</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-fileAnnotation">fileAnnotation</a></em>}<br />
<em><a href="#grammar-rule-packageHeader">packageHeader</a></em><br />
<em><a href="#grammar-rule-importList">importList</a></em><br />
{<em><a href="#grammar-rule-statement">statement</a></em> <em><a href="#grammar-rule-semi">semi</a></em>}<br />
<em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-shebangLine" class="grammar-rule">
<dl>
<dt><strong><em>shebangLine</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-ShebangLine">ShebangLine</a></em> (<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-fileAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>fileAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> | <em><a href="#grammar-rule-AT_PRE_WS">AT_PRE_WS</a></em>)<br />
<code>'file'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
((<code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>) | <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-packageHeader" class="grammar-rule">
<dl>
<dt><strong><em>packageHeader</em>:</strong></dt>
<dd><span class="sentence">[<code>'package'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importList" class="grammar-rule">
<dl>
<dt><strong><em>importList</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-importHeader">importHeader</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importHeader" class="grammar-rule">
<dl>
<dt><strong><em>importHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'import'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [(<code>'.'</code> <code>'*'</code>) | <em><a href="#grammar-rule-importAlias">importAlias</a></em>] [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importAlias" class="grammar-rule">
<dl>
<dt><strong><em>importAlias</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-topLevelObject" class="grammar-rule">
<dl>
<dt><strong><em>topLevelObject</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-declaration">declaration</a></em> [<em><a href="#grammar-rule-semis">semis</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeAlias" class="grammar-rule">
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'typealias'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'='</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-declaration" class="grammar-rule">
<dl>
<dt><strong><em>declaration</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-classDeclaration">classDeclaration</a></em><br />
| <em><a href="#grammar-rule-objectDeclaration">objectDeclaration</a></em><br />
| <em><a href="#grammar-rule-functionDeclaration">functionDeclaration</a></em><br />
| <em><a href="#grammar-rule-propertyDeclaration">propertyDeclaration</a></em><br />
| <em><a href="#grammar-rule-typeAlias">typeAlias</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'class'</code> | <code>'interface'</code>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-primaryConstructor">primaryConstructor</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumClassBody">enumClassBody</a></em>)]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-primaryConstructor" class="grammar-rule">
<dl>
<dt><strong><em>primaryConstructor</em>:</strong></dt>
<dd><span class="sentence">[[<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'constructor'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}] <em><a href="#grammar-rule-classParameters">classParameters</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classBody" class="grammar-rule">
<dl>
<dt><strong><em>classBody</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-classMemberDeclarations">classMemberDeclarations</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classParameters" class="grammar-rule">
<dl>
<dt><strong><em>classParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-classParameter">classParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classParameter">classParameter</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classParameter" class="grammar-rule">
<dl>
<dt><strong><em>classParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
[<code>'val'</code> | <code>'var'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-delegationSpecifiers" class="grammar-rule">
<dl>
<dt><strong><em>delegationSpecifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotatedDelegationSpecifier">annotatedDelegationSpecifier</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-annotatedDelegationSpecifier">annotatedDelegationSpecifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-delegationSpecifier" class="grammar-rule">
<dl>
<dt><strong><em>delegationSpecifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-constructorInvocation">constructorInvocation</a></em><br />
| <em><a href="#grammar-rule-explicitDelegation">explicitDelegation</a></em><br />
| <em><a href="#grammar-rule-userType">userType</a></em><br />
| <em><a href="#grammar-rule-functionType">functionType</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-constructorInvocation" class="grammar-rule">
<dl>
<dt><strong><em>constructorInvocation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-userType">userType</a></em> <em><a href="#grammar-rule-valueArguments">valueArguments</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedDelegationSpecifier" class="grammar-rule">
<dl>
<dt><strong><em>annotatedDelegationSpecifier</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifier">delegationSpecifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-explicitDelegation" class="grammar-rule">
<dl>
<dt><strong><em>explicitDelegation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-userType">userType</a></em> | <em><a href="#grammar-rule-functionType">functionType</a></em>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'by'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameters" class="grammar-rule">
<dl>
<dt><strong><em>typeParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeParameter">typeParameter</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameter">typeParameter</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameter" class="grammar-rule">
<dl>
<dt><strong><em>typeParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeParameterModifiers">typeParameterModifiers</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeConstraints" class="grammar-rule">
<dl>
<dt><strong><em>typeConstraints</em>:</strong></dt>
<dd><span class="sentence"><code>'where'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraint">typeConstraint</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraint">typeConstraint</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeConstraint" class="grammar-rule">
<dl>
<dt><strong><em>typeConstraint</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classMemberDeclarations" class="grammar-rule">
<dl>
<dt><strong><em>classMemberDeclarations</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-classMemberDeclaration">classMemberDeclaration</a></em> [<em><a href="#grammar-rule-semis">semis</a></em>]}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classMemberDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>classMemberDeclaration</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-declaration">declaration</a></em><br />
| <em><a href="#grammar-rule-companionObject">companionObject</a></em><br />
| <em><a href="#grammar-rule-anonymousInitializer">anonymousInitializer</a></em><br />
| <em><a href="#grammar-rule-secondaryConstructor">secondaryConstructor</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-anonymousInitializer" class="grammar-rule">
<dl>
<dt><strong><em>anonymousInitializer</em>:</strong></dt>
<dd><span class="sentence"><code>'init'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-companionObject" class="grammar-rule">
<dl>
<dt><strong><em>companionObject</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'companion'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'object'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionValueParameters" class="grammar-rule">
<dl>
<dt><strong><em>functionValueParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-functionValueParameter">functionValueParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionValueParameter">functionValueParameter</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionValueParameter" class="grammar-rule">
<dl>
<dt><strong><em>functionValueParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-parameterModifiers">parameterModifiers</a></em>] <em><a href="#grammar-rule-parameter">parameter</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionBody" class="grammar-rule">
<dl>
<dt><strong><em>functionBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| (<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-variableDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>variableDeclaration</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiVariableDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>multiVariableDeclaration</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'val'</code> | <code>'var'</code>)<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
({<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> | <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>))<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} ((<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>) | <em><a href="#grammar-rule-propertyDelegate">propertyDelegate</a></em>)]<br />
[(<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}) <code>';'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(([<em><a href="#grammar-rule-getter">getter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-setter">setter</a></em>]) | ([<em><a href="#grammar-rule-setter">setter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-getter">getter</a></em>]))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyDelegate" class="grammar-rule">
<dl>
<dt><strong><em>propertyDelegate</em>:</strong></dt>
<dd><span class="sentence"><code>'by'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-getter" class="grammar-rule">
<dl>
<dt><strong><em>getter</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'get'</code>)<br />
| ([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'get'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-setter" class="grammar-rule">
<dl>
<dt><strong><em>setter</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'set'</code>)<br />
| ([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'set'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-parameterWithOptionalType">parameterWithOptionalType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parametersWithOptionalType" class="grammar-rule">
<dl>
<dt><strong><em>parametersWithOptionalType</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-parameterWithOptionalType">parameterWithOptionalType</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-parameterWithOptionalType">parameterWithOptionalType</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameterWithOptionalType" class="grammar-rule">
<dl>
<dt><strong><em>parameterWithOptionalType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-parameterModifiers">parameterModifiers</a></em>] <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameter" class="grammar-rule">
<dl>
<dt><strong><em>parameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'object'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-secondaryConstructor" class="grammar-rule">
<dl>
<dt><strong><em>secondaryConstructor</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'constructor'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-constructorDelegationCall">constructorDelegationCall</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-block">block</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-constructorDelegationCall" class="grammar-rule">
<dl>
<dt><strong><em>constructorDelegationCall</em>:</strong></dt>
<dd><span class="sentence">(<code>'this'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)<br />
| (<code>'super'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumClassBody" class="grammar-rule">
<dl>
<dt><strong><em>enumClassBody</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-enumEntries">enumEntries</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classMemberDeclarations">classMemberDeclarations</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumEntries" class="grammar-rule">
<dl>
<dt><strong><em>enumEntries</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-enumEntry">enumEntry</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumEntry">enumEntry</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>','</code>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumEntry" class="grammar-rule">
<dl>
<dt><strong><em>enumEntry</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}] <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-type" class="grammar-rule">
<dl>
<dt><strong><em>type</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeModifiers">typeModifiers</a></em>] (<em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em> | <em><a href="#grammar-rule-nullableType">nullableType</a></em> | <em><a href="#grammar-rule-typeReference">typeReference</a></em> | <em><a href="#grammar-rule-functionType">functionType</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeReference" class="grammar-rule">
<dl>
<dt><strong><em>typeReference</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-userType">userType</a></em><br />
| <code>'dynamic'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-nullableType" class="grammar-rule">
<dl>
<dt><strong><em>nullableType</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-typeReference">typeReference</a></em> | <em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-quest">quest</a></em> {<em><a href="#grammar-rule-quest">quest</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-quest" class="grammar-rule">
<dl>
<dt><strong><em>quest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em><br />
| <em><a href="#grammar-rule-QUEST_WS">QUEST_WS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-userType" class="grammar-rule">
<dl>
<dt><strong><em>userType</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleUserType">simpleUserType</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleUserType">simpleUserType</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-simpleUserType" class="grammar-rule">
<dl>
<dt><strong><em>simpleUserType</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeArguments">typeArguments</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-varianceModifier">varianceModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-annotation">annotation</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionType" class="grammar-rule">
<dl>
<dt><strong><em>functionType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}]<br />
<em><a href="#grammar-rule-functionTypeParameters">functionTypeParameters</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'-&gt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionTypeParameters" class="grammar-rule">
<dl>
<dt><strong><em>functionTypeParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-parameter">parameter</a></em> | <em><a href="#grammar-rule-type">type</a></em>]<br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-parameter">parameter</a></em> | <em><a href="#grammar-rule-type">type</a></em>)}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedType" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedType</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-receiverType" class="grammar-rule">
<dl>
<dt><strong><em>receiverType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeModifiers">typeModifiers</a></em>] (<em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em> | <em><a href="#grammar-rule-nullableType">nullableType</a></em> | <em><a href="#grammar-rule-typeReference">typeReference</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedUserType" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedUserType</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-userType">userType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-parenthesizedUserType">parenthesizedUserType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statements" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statement" class="grammar-rule">
<dl>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-label">label</a></em> | <em><a href="#grammar-rule-annotation">annotation</a></em>} (<em><a href="#grammar-rule-declaration">declaration</a></em> | <em><a href="#grammar-rule-assignment">assignment</a></em> | <em><a href="#grammar-rule-loopStatement">loopStatement</a></em> | <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-label" class="grammar-rule">
<dl>
<dt><strong><em>label</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> (<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> | <em><a href="#grammar-rule-AT_POST_WS">AT_POST_WS</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-controlStructureBody" class="grammar-rule">
<dl>
<dt><strong><em>controlStructureBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| <em><a href="#grammar-rule-statement">statement</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-block" class="grammar-rule">
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-statements">statements</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-loopStatement" class="grammar-rule">
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-forStatement">forStatement</a></em><br />
| <em><a href="#grammar-rule-whileStatement">whileStatement</a></em><br />
| <em><a href="#grammar-rule-doWhileStatement">doWhileStatement</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-forStatement" class="grammar-rule">
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'for'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
(<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em> | <em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em>)<br />
<em><a href="#grammar-rule-IN">IN</a></em><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whileStatement" class="grammar-rule">
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence">(<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)<br />
| (<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-doWhileStatement" class="grammar-rule">
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'do'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'while'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignment" class="grammar-rule">
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-directlyAssignableExpression">directlyAssignableExpression</a></em> <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| (<em><a href="#grammar-rule-assignableExpression">assignableExpression</a></em> <em><a href="#grammar-rule-assignmentAndOperator">assignmentAndOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-semi" class="grammar-rule">
<dl>
<dt><strong><em>semi</em>:</strong></dt>
<dd><span class="sentence">((<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-semis" class="grammar-rule">
<dl>
<dt><strong><em>semis</em>:</strong></dt>
<dd><span class="sentence">(<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em> {<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-expression" class="grammar-rule">
<dl>
<dt><strong><em>expression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-disjunction">disjunction</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-disjunction" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-conjunction" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equality" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparison" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-infixOperation" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-elvisExpression" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-elvis" class="grammar-rule">
<dl>
<dt><strong><em>elvis</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em> <code>':'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-infixFunctionCall" class="grammar-rule">
<dl>
<dt><strong><em>infixFunctionCall</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-rangeExpression">rangeExpression</a></em> {<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-rangeExpression">rangeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeExpression" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveExpression" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeExpression" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asExpression" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-directlyAssignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>directlyAssignableExpression</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em> <em><a href="#grammar-rule-assignableSuffix">assignableSuffix</a></em>)<br />
| <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
| <em><a href="#grammar-rule-parenthesizedDirectlyAssignableExpression">parenthesizedDirectlyAssignableExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedDirectlyAssignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedDirectlyAssignableExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-directlyAssignableExpression">directlyAssignableExpression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>assignableExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em><br />
| <em><a href="#grammar-rule-parenthesizedAssignableExpression">parenthesizedAssignableExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedAssignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedAssignableExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-assignableExpression">assignableExpression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignableSuffix" class="grammar-rule">
<dl>
<dt><strong><em>assignableSuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArgument" class="grammar-rule">
<dl>
<dt><strong><em>valueArgument</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-annotation">annotation</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>}]<br />
[<code>'*'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-primaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>primaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em><br />
| <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
| <em><a href="#grammar-rule-literalConstant">literalConstant</a></em><br />
| <em><a href="#grammar-rule-stringLiteral">stringLiteral</a></em><br />
| <em><a href="#grammar-rule-callableReference">callableReference</a></em><br />
| <em><a href="#grammar-rule-functionLiteral">functionLiteral</a></em><br />
| <em><a href="#grammar-rule-objectLiteral">objectLiteral</a></em><br />
| <em><a href="#grammar-rule-collectionLiteral">collectionLiteral</a></em><br />
| <em><a href="#grammar-rule-thisExpression">thisExpression</a></em><br />
| <em><a href="#grammar-rule-superExpression">superExpression</a></em><br />
| <em><a href="#grammar-rule-ifExpression">ifExpression</a></em><br />
| <em><a href="#grammar-rule-whenExpression">whenExpression</a></em><br />
| <em><a href="#grammar-rule-tryExpression">tryExpression</a></em><br />
| <em><a href="#grammar-rule-jumpExpression">jumpExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedExpression" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-collectionLiteral" class="grammar-rule">
<dl>
<dt><strong><em>collectionLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'['</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>']'</code>)<br />
| (<code>'['</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>']'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-literalConstant" class="grammar-rule">
<dl>
<dt><strong><em>literalConstant</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-BooleanLiteral">BooleanLiteral</a></em><br />
| <em><a href="#grammar-rule-IntegerLiteral">IntegerLiteral</a></em><br />
| <em><a href="#grammar-rule-HexLiteral">HexLiteral</a></em><br />
| <em><a href="#grammar-rule-BinLiteral">BinLiteral</a></em><br />
| <em><a href="#grammar-rule-CharacterLiteral">CharacterLiteral</a></em><br />
| <em><a href="#grammar-rule-RealLiteral">RealLiteral</a></em><br />
| <em><a href="#grammar-rule-NullLiteral">NullLiteral</a></em><br />
| <em><a href="#grammar-rule-LongLiteral">LongLiteral</a></em><br />
| <em><a href="#grammar-rule-UnsignedLiteral">UnsignedLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-stringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>stringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lineStringLiteral">lineStringLiteral</a></em><br />
| <em><a href="#grammar-rule-multiLineStringLiteral">multiLineStringLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>lineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUOTE_OPEN">QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-lineStringContent">lineStringContent</a></em> | <em><a href="#grammar-rule-lineStringExpression">lineStringExpression</a></em>} <em><a href="#grammar-rule-QUOTE_CLOSE">QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-TRIPLE_QUOTE_OPEN">TRIPLE_QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-multiLineStringContent">multiLineStringContent</a></em> | <em><a href="#grammar-rule-multiLineStringExpression">multiLineStringExpression</a></em> | <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em>} <em><a href="#grammar-rule-TRIPLE_QUOTE_CLOSE">TRIPLE_QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringContent" class="grammar-rule">
<dl>
<dt><strong><em>lineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrText">LineStrText</a></em><br />
| <em><a href="#grammar-rule-LineStrEscapedChar">LineStrEscapedChar</a></em><br />
| <em><a href="#grammar-rule-LineStrRef">LineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringExpression" class="grammar-rule">
<dl>
<dt><strong><em>lineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrExprStart">LineStrExprStart</a></em> <em><a href="#grammar-rule-expression">expression</a></em> <code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringContent" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrText">MultiLineStrText</a></em><br />
| <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em><br />
| <em><a href="#grammar-rule-MultiLineStrRef">MultiLineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringExpression" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrExprStart">MultiLineStrExprStart</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaLiteral" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)<br />
| (<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-anonymousFunction" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-parametersWithOptionalType">parametersWithOptionalType</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionLiteral" class="grammar-rule">
<dl>
<dt><strong><em>functionLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em><br />
| <em><a href="#grammar-rule-anonymousFunction">anonymousFunction</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectLiteral" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-thisExpression" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-superExpression" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-ifExpression" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenExpression" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-tryExpression" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-type">type</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-jumpExpression" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-callableReference" class="grammar-rule">
<dl>
<dt><strong><em>callableReference</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-receiverType">receiverType</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'::'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignmentAndOperator" class="grammar-rule">
<dl>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+='</code><br />
| <code>'-='</code><br />
| <code>'*='</code><br />
| <code>'/='</code><br />
| <code>'%='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-excl" class="grammar-rule">
<dl>
<dt><strong><em>excl</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em><br />
| <em><a href="#grammar-rule-EXCL_WS">EXCL_WS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-safeNav" class="grammar-rule">
<dl>
<dt><strong><em>safeNav</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em> <code>'.'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-modifiers" class="grammar-rule">
<dl>
<dt><strong><em>modifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-modifier">modifier</a></em> {<em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-modifier">modifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameterModifiers" class="grammar-rule">
<dl>
<dt><strong><em>parameterModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em> {<em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-modifier" class="grammar-rule">
<dl>
<dt><strong><em>modifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-classModifier">classModifier</a></em> | <em><a href="#grammar-rule-memberModifier">memberModifier</a></em> | <em><a href="#grammar-rule-visibilityModifier">visibilityModifier</a></em> | <em><a href="#grammar-rule-functionModifier">functionModifier</a></em> | <em><a href="#grammar-rule-propertyModifier">propertyModifier</a></em> | <em><a href="#grammar-rule-inheritanceModifier">inheritanceModifier</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em> | <em><a href="#grammar-rule-platformModifier">platformModifier</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeModifier">typeModifier</a></em> {<em><a href="#grammar-rule-typeModifier">typeModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeModifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| (<code>'suspend'</code> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classModifier" class="grammar-rule">
<dl>
<dt><strong><em>classModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'enum'</code><br />
| <code>'sealed'</code><br />
| <code>'annotation'</code><br />
| <code>'data'</code><br />
| <code>'inner'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberModifier" class="grammar-rule">
<dl>
<dt><strong><em>memberModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'override'</code><br />
| <code>'lateinit'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-visibilityModifier" class="grammar-rule">
<dl>
<dt><strong><em>visibilityModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'public'</code><br />
| <code>'private'</code><br />
| <code>'internal'</code><br />
| <code>'protected'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-varianceModifier" class="grammar-rule">
<dl>
<dt><strong><em>varianceModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <code>'out'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameterModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeParameterModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeParameterModifier">typeParameterModifier</a></em> {<em><a href="#grammar-rule-typeParameterModifier">typeParameterModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameterModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeParameterModifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-reificationModifier">reificationModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| (<em><a href="#grammar-rule-varianceModifier">varianceModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-annotation">annotation</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionModifier" class="grammar-rule">
<dl>
<dt><strong><em>functionModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'tailrec'</code><br />
| <code>'operator'</code><br />
| <code>'infix'</code><br />
| <code>'inline'</code><br />
| <code>'external'</code><br />
| <code>'suspend'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyModifier" class="grammar-rule">
<dl>
<dt><strong><em>propertyModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'const'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-inheritanceModifier" class="grammar-rule">
<dl>
<dt><strong><em>inheritanceModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'abstract'</code><br />
| <code>'final'</code><br />
| <code>'open'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameterModifier" class="grammar-rule">
<dl>
<dt><strong><em>parameterModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'vararg'</code><br />
| <code>'noinline'</code><br />
| <code>'crossinline'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-reificationModifier" class="grammar-rule">
<dl>
<dt><strong><em>reificationModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'reified'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-platformModifier" class="grammar-rule">
<dl>
<dt><strong><em>platformModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'expect'</code><br />
| <code>'actual'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotation" class="grammar-rule">
<dl>
<dt><strong><em>annotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-singleAnnotation">singleAnnotation</a></em> | <em><a href="#grammar-rule-multiAnnotation">multiAnnotation</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-singleAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>singleAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-annotationUseSiteTarget">annotationUseSiteTarget</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)<br />
| ((<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> | <em><a href="#grammar-rule-AT_PRE_WS">AT_PRE_WS</a></em>) <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>multiAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-annotationUseSiteTarget">annotationUseSiteTarget</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>)<br />
| ((<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> | <em><a href="#grammar-rule-AT_PRE_WS">AT_PRE_WS</a></em>) <code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotationUseSiteTarget" class="grammar-rule">
<dl>
<dt><strong><em>annotationUseSiteTarget</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> | <em><a href="#grammar-rule-AT_PRE_WS">AT_PRE_WS</a></em>) (<code>'field'</code> | <code>'property'</code> | <code>'get'</code> | <code>'set'</code> | <code>'receiver'</code> | <code>'param'</code> | <code>'setparam'</code> | <code>'delegate'</code>) {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unescapedAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>unescapedAnnotation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-constructorInvocation">constructorInvocation</a></em><br />
| <em><a href="#grammar-rule-userType">userType</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-simpleIdentifier" class="grammar-rule">
<dl>
<dt><strong><em>simpleIdentifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-Identifier">Identifier</a></em><br />
| <code>'abstract'</code><br />
| <code>'annotation'</code><br />
| <code>'by'</code><br />
| <code>'catch'</code><br />
| <code>'companion'</code><br />
| <code>'constructor'</code><br />
| <code>'crossinline'</code><br />
| <code>'data'</code><br />
| <code>'dynamic'</code><br />
| <code>'enum'</code><br />
| <code>'external'</code><br />
| <code>'final'</code><br />
| <code>'finally'</code><br />
| <code>'get'</code><br />
| <code>'import'</code><br />
| <code>'infix'</code><br />
| <code>'init'</code><br />
| <code>'inline'</code><br />
| <code>'inner'</code><br />
| <code>'internal'</code><br />
| <code>'lateinit'</code><br />
| <code>'noinline'</code><br />
| <code>'open'</code><br />
| <code>'operator'</code><br />
| <code>'out'</code><br />
| <code>'override'</code><br />
| <code>'private'</code><br />
| <code>'protected'</code><br />
| <code>'public'</code><br />
| <code>'reified'</code><br />
| <code>'sealed'</code><br />
| <code>'tailrec'</code><br />
| <code>'set'</code><br />
| <code>'vararg'</code><br />
| <code>'where'</code><br />
| <code>'field'</code><br />
| <code>'property'</code><br />
| <code>'receiver'</code><br />
| <code>'param'</code><br />
| <code>'setparam'</code><br />
| <code>'delegate'</code><br />
| <code>'file'</code><br />
| <code>'expect'</code><br />
| <code>'actual'</code><br />
| <code>'const'</code><br />
| <code>'suspend'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-identifier" class="grammar-rule">
<dl>
<dt><strong><em>identifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>}</span>
</dd>
</dl>
</div>
<h4 id="documentation-comments">Documentation comments</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(KDoc goes here)</span></p>
</div>
</div>
<h2 id="type-system">Type system</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add examples)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add grammar snippets?)</span></p>
</div>
</div>
<h3 id="glossary-1">Glossary</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Cleanup)</span></p>
</div>
</div>
<dl>
<dt><span class="math inline">\(T\)</span></dt>
<dd><span class="sentence">Type</span>
</dd>
<dt><span class="math inline">\(T!!\)</span></dt>
<dd><span class="sentence">Non-nullable type</span>
</dd>
<dt><span class="math inline">\(T?\)</span></dt>
<dd><span class="sentence">Nullable type</span>
</dd>
<dt><span class="math inline">\(\{T!!\}\)</span></dt>
<dd><span class="sentence">Universe of non-nullable types</span>
</dd>
<dt><span class="math inline">\(\{T?\}\)</span></dt>
<dd><span class="sentence">Universe of nullable types</span>
</dd>
<dt><span class="math inline">\(\Gamma\)</span></dt>
<dd><span class="sentence">Type context</span>
</dd>
<dt><span class="math inline">\(T\lbrack S_1, \ldots, S_n\rbrack\)</span></dt>
<dd><span class="sentence">The result of type argument substitution for type <span class="math inline">\(T\)</span> with types <span class="math inline">\(S_i\)</span></span>
</dd>
<dt>Type parameter</dt>
<dd><span class="sentence">Formal type argument of parameterized type</span>
</dd>
<dt>Type argument</dt>
<dd><span class="sentence">Actual type argument in parameterized type constructor application</span>
</dd>
<dt>PACT</dt>
<dd><span class="sentence">Parameterized abstract classifier type</span>
</dd>
<dt>iPACT</dt>
<dd><span class="sentence">Instantiated parameterized concrete classifier type</span>
</dd>
</dl>
<h3 id="introduction-1">Introduction</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin has a type system with the following main properties.</span></p>
</div>
<ul>
<li><span class="sentence">Hybrid static and gradual type checking</span></li>
<li><span class="sentence">Null safety</span></li>
<li><span class="sentence">No unsafe implicit conversions</span></li>
<li><span class="sentence">Unified root type</span></li>
<li><span class="sentence">Nominal subtyping with bounded parametric polymorphism and mixed-site variance</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(static type checking, gradual type checking)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Null safety is enforced by having two type universes — <em>nullable</em> (with nullable types <span class="math inline">\(T?\)</span>) and <em>non-nullable</em> (with non-nullable types <span class="math inline">\(T!!\)</span>). </span><span class="sentence">All operations within the non-nullable type universe are safe, i.e., should never cause a runtime null pointer error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <a href="#cast-expression-1">explicit cast</a>. </span><span class="sentence">However, Kotlin also supports smart casts — a special kind of implicit conversions which are safe w.r.t. program control- and data-flow, which are covered in more detail <a href="#smart-casts">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The unified supertype type for all types in Kotlin is <code>kotlin.Any?</code>, a nullable version of <a href="#kotlin.any">kotlin.Any</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as <a href="#generics">generics</a> via <a href="#parameterized-classifier-types">parameterized types</a>. </span><span class="sentence">Subtyping between these parameterized types is defined through <a href="#mixed-site-variance">mixed-site variance</a>.</span></p>
</div>
<h3 id="type-kinds">Type kinds</h3>
<div class="paragraph">
<p><span class="sentence">For the purposes of this section, we establish the following type kinds — different flavours of types which exist in the Kotlin type system.</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#built-in-types">Built-in types</a></span></li>
<li><span class="sentence"><a href="#classifier-types">Classifier types</a></span></li>
<li><span class="sentence"><a href="#function-types">Function types</a></span></li>
<li><span class="sentence"><a href="#array-types">Array types</a></span></li>
<li><span class="sentence"><a href="#flexible-types">Flexible types</a></span></li>
<li><span class="sentence"><a href="#nullable-types">Nullable types</a></span></li>
<li><div class="TODO">
<span class="sentence">TODO(Intersection and union types)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(Error / invalid types)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">We distinguish between <em>concrete</em> and <em>abstract</em> types. </span><span class="sentence">Concrete types are types which are assignable to values; abstract types either need to be instantiated as concrete types before they can be used as value types, or are used internally by the type system and are not directly denotable.</span></p>
</div>
<h4 id="built-in-types">Built-in types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).</span></p>
</div>
<h5 id="kotlin.any"><code>kotlin.Any</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Any</code> is the unified supertype (<span class="math inline">\(\top\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., all non-nullable types are subtypes of <code>kotlin.Any</code>, either explicitly, implicitly, or by subtyping relation.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>kotlin.Any</code> members?)</span></p>
</div>
</div>
<h5 id="kotlin.nothing"><code>kotlin.Nothing</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Nothing</code> is the unified subtype (<span class="math inline">\(\bot\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., <code>kotlin.Nothing</code> is a subtype of all non-nullable types, including user-defined ones. </span><span class="sentence">This makes it an uninhabited type (as it is impossible for anything to be, for example, a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of <code>kotlin.Nothing</code> in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As the evaluation of an expression with <code>kotlin.Nothing</code> type can never complete normally, it is used to mark special situations, such as:</span></p>
</div>
<ul>
<li><span class="sentence">non-terminating expressions</span></li>
<li><span class="sentence">exceptional control flow</span></li>
<li><span class="sentence">control flow transfer</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Additional details about how <code>kotlin.Nothing</code> should be processed are available [here][Control- and data-flow analysis].</span></p>
</div>
<h5 id="kotlin.unit"><code>kotlin.Unit</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Unit</code> is a unit type, i.e., a type with only one value <code>kotlin.Unit</code>; all values of type <code>kotlin.Unit</code> should reference the same underlying <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Compare to <code>void</code>?)</span></p>
</div>
</div>
<h4 id="classifier-types">Classifier types</h4>
<div class="paragraph">
<p><span class="sentence">Classifier types represent regular types which are declared as [classes][Classes], [interfaces][Interfaces] or [objects][Objects]. </span><span class="sentence">As Kotlin supports <a href="#generics">generics</a>, there are two variants of classifier types: simple and parameterized.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(No objects as supertypes?)</span></p>
</div>
</div>
<h5 id="simple-classifier-types">Simple classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A simple concrete classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid simple concrete classifier type, <span class="math inline">\(T : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,m]: S_i\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<h5 id="parameterized-classifier-types">Parameterized classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A parameterized abstract classifier type (PACT)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T(F_1, \ldots, F_n) : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type constructor <span class="math inline">\(T\)</span> which takes type arguments and returns an instantiated type</span></li>
<li><span class="sentence">type parameters <span class="math inline">\(F_1, \ldots, F_n\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid PACT, <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: F_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">[unbounded type parameter][Unbounded type parameters]</span></li>
<li><span class="sentence">[projected type parameter][Projected type parameters]</span></li>
<li><span class="sentence"><a href="#bounded-type-parameters">bounded type parameter</a></span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(\forall j \in [1,m]: S_j[F_1, \ldots, F_n]\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An instantiated parameterized concrete classifier type (iPACT)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T[A_1, \ldots, A_n]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type arguments <span class="math inline">\(A_1, \ldots, A_n\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid iPACT, <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid PACT with <span class="math inline">\(n\)</span> type parameters</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">valid concrete type</span></li>
<li><span class="sentence">valid projected type</span></li>
<li><span class="sentence">type parameter available in the current type context <span class="math inline">\(\Gamma\)</span><br />
TODO(What is a type context?)<br />
TODO(Inner vs nested contexts)</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i &lt;: F_i\)</span> where <span class="math inline">\(F_i\)</span> is the respective type parameter of <span class="math inline">\(T\)</span></span></li>
</ul>
<h5 id="type-parameters">Type parameters</h5>
<div class="paragraph">
<p><span class="sentence">Type parameters are a special kind of abstract types, which are introduced by PACTs. </span><span class="sentence">They are valid only in the context of their declaring PACT.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When creating an iPACT from PACT, type parameters with their respective type arguments go through <a href="#type-capturing">capturing</a> and create <em>captured</em> type arguments, which follow special rules described in more detail below.</span></p>
</div>
<h6 id="bounded-type-parameters">Bounded type parameters</h6>
<div class="paragraph">
<p><span class="sentence">A bounded type parameter is an abstract type which is used to specify upper type bounds for type parameters and is defined as <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span>, where <span class="math inline">\(B_i\)</span> is an i-th upper bound on type parameter <span class="math inline">\(F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid bounded type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: B_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Single generic bound allowed)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Only one class bound allowed)</span></p>
</div>
</div>
<h6 id="mixed-site-variance">Mixed-site variance</h6>
<div class="paragraph">
<p><span class="sentence">To implement subtyping between parameterized types, Kotlin uses <em>mixed-site variance</em> — a combination of declaration- and use-site variance, which is easier to understand and reason about, compared to wildcards from Java. </span><span class="sentence">Mixed-site variance means you can specify, whether you want your parameterized type to be co-, contra- or invariant on some type parameter, both in type parameter (declaration-site) and type argument (use-site). </span><span class="sentence">For more practical discussion about mixed-site variance, we readdress you to <a href="#generics">generics</a>.</span></p>
</div>
<h6 id="declaration-site-variance">Declaration-site variance</h6>
<div class="paragraph">
<p><span class="sentence">An invariant type parameter <span class="math inline">\(F\)</span> is an abstract type which may capture any valid type (see <a href="#subtyping">subtyping</a> for more details on variance); if one needs co- or contravariant type parameter, they need to use projected type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid invariant type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Projected type parameters are abstract types which are used to declare a type parameter as <em>covariant</em> or <em>contravariant</em>. </span><span class="sentence">The variance information is used by <a href="#subtyping">subtyping</a> and for checking allowed operations on values of co- and contravariant type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid covariant type parameter <span class="math inline">\(\triangleleft F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid contravariant type parameter <span class="math inline">\(\triangleright F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(type projections are not allowed on functions and properties)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(no type projections on supertype type arguments)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(conflicting projections)</span></p>
</div>
</div>
<h6 id="use-site-variance">Use-site variance</h6>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports use-site variance, by specifying the variance for type arguments. </span><span class="sentence">Just like with projected type parameters, one can have projected type arguments being co-, contra- or invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid invariant type argument of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid covariant type argument <span class="math inline">\(\triangleleft A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid contravariant type argument <span class="math inline">\(\triangleright A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In case one cannot specify any valid type argument, but still needs to use PACT in a type-safe way, one may use <em>star-projected</em> type argument, which is roughly equivalent to a combination of <span class="math inline">\(\triangleleft \texttt{kotlin.Any?}\)</span> and <span class="math inline">\(\triangleright \texttt{kotlin.Nothing}\)</span> (for further details, see <a href="#generics">here</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clean-up this mess)</span></p>
</div>
</div>
<h5 id="type-capturing">Type capturing</h5>
<div class="paragraph">
<p><span class="sentence">Type capturing (similarly to Java capturing conversion) is used when instantiating parameterized types; it creates <em>captured</em> types based on the type information of both type parameters and arguments, which present a unified view on the resulting types and simplifies further reasoning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For a given PACT <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span>, its iPACT <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> uses the following rules to create captured type <span class="math inline">\(C_i\)</span> from the type parameter <span class="math inline">\(F_i\)</span> and type argument <span class="math inline">\(A_i\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Does this set describe a type universe?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Blah-blah about existential types?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">NB: A captured type <span class="math inline">\(C\)</span> may be viewed as a set of its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence"><strong>All</strong> applicable rules are used to create the resulting constraint set.</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">If <span class="math inline">\(\triangleleft F_i\)</span> is a covariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, covariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i &lt;: A_i\)</span>.</span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleright F_i\)</span> is a contravariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, contravariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i :&gt; A_i\)</span>.</span></li>
<li><span class="sentence">If <span class="math inline">\(F_i &lt;: B_1, \ldots, B_n\)</span> is a bounded type parameter, <span class="math inline">\(C_i &lt;: B_i[C_1, \ldots, C_n]\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleleft A_i\)</span> is a covariant type argument, <span class="math inline">\(C_i &lt;: A_i\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleright A_i\)</span> is a contravariant type argument, <span class="math inline">\(C_i :&gt; A_i\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\star A_i\)</span> is a star-projected type argument, <span class="math inline">\(kotlin.Nothing &lt;: C_i &lt;: kotlin.Any?\)</span></span></li>
<li><span class="sentence">Otherwise, <span class="math inline">\(C_i = A_i\)</span></span></li>
</ul>
<h4 id="function-types">Function types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Everything…)</span></p>
</div>
</div>
<h4 id="array-types">Array types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Everything…)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Primitive type array coercion)</span></p>
</div>
</div>
<h4 id="flexible-types">Flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin, being a multi-platform language, needs to support transparent interoperability with platform-dependent code. </span><span class="sentence">However, this presents a problem in that some platforms may not support null safety the way Kotlin does. </span><span class="sentence">To deal with this, Kotlin supports <em>gradual typing</em> in the form of flexible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A flexible type represents a range of possible types between type <span class="math inline">\(L\)</span> (lower bound) and type <span class="math inline">\(U\)</span> (upper bound), written as <span class="math inline">\((L..U)\)</span>. </span><span class="sentence">One should note flexible types are abstract and <em>non-denotable</em>, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid flexible type, <span class="math inline">\((L..U)\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are valid concrete types</span></li>
<li><span class="sentence"><span class="math inline">\(L &lt;: U\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\neg (L &lt;: U)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are <strong>not</strong> flexible types (but may contains other flexible types as part of their type signature)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As the name suggests, flexible types are flexible — a value of type <span class="math inline">\((L..U)\)</span> can be used in any context, where one of the possible types between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> is needed (for more details, see <a href="#subtyping">subtyping rules for flexible types</a>). </span><span class="sentence">However, the actual type will be a specific type between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>, thus making the substitution possibly unsafe, which is why Kotlin generates dynamic assertions, when it is impossible to prove statically the safety of flexible type use.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Details of assertion generation?)</span></p>
</div>
</div>
<h5 id="platform-types">Platform types</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Platform types as flexible types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Reference for different platforms)</span></p>
</div>
</div>
<h4 id="nullable-types">Nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports null safety by having two type universes — nullable and non-nullable. </span><span class="sentence">All classifier type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold <code>null</code> value at runtime.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a nullable version of type <code>T</code>, one needs to use <code>T?</code> as a type. </span><span class="sentence">Redundant nullability specifiers are ignored — <code>T???</code> is equivalent to <code>T?</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally, question mark means “<span class="math inline">\(T?\)</span> may hold values of type <span class="math inline">\(T\)</span> or value <code>null</code>”</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">To represent a valid nullable type, <span class="math inline">\(T?\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If an operation is safe regardless of absence or presence of <code>null</code>, i.e., assignment of one nullable value to another, it can be used as-is for nullable types. </span><span class="sentence">For operations on <span class="math inline">\(T?\)</span> which may violate null safety, one has the following null-safe options:</span></p>
</div>
<ol type="1">
<li><span class="sentence">Use safe operations</span>
<ul>
<li><span class="sentence"><a href="#safe-call-expression-1">safe call</a></span></li>
</ul></li>
<li><span class="sentence">Downcast from <span class="math inline">\(T?\)</span> to <span class="math inline">\(T!!\)</span></span>
<ul>
<li><span class="sentence"><a href="#cast-expression-1">unsafe cast</a></span></li>
<li><span class="sentence"><a href="#type-check-expression-1">type check</a> combined with <a href="#smart-casts">smart casts</a></span></li>
<li><span class="sentence">null check combined with <a href="#smart-casts">smart casts</a></span></li>
<li><span class="sentence">[not-null assertion operator][Not-null assertion operator expression]</span></li>
</ul></li>
<li><span class="sentence">Supply a default value to use instead of <code>null</code></span>
<ul>
<li><span class="sentence"><a href="#elvis-operator-expression-1">elvis operator</a></span></li>
</ul></li>
</ol>
<h3 id="subtyping">Subtyping</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin uses the classic notion of <em>subtyping</em> as <em>substitutability</em> — if <span class="math inline">\(S\)</span> is a subtype of <span class="math inline">\(T\)</span> (denoted as <span class="math inline">\(S &lt;: T\)</span>), values of type <span class="math inline">\(S\)</span> can be safely used where values of type <span class="math inline">\(T\)</span> are expected. </span><span class="sentence">The subtyping relation <span class="math inline">\(&lt;:\)</span> is:</span></p>
</div>
<ul>
<li><span class="sentence">reflexive (<span class="math inline">\(A &lt;: A\)</span>)</span></li>
<li><span class="sentence">transitive (<span class="math inline">\(A &lt;: B \land B &lt;: C \Rightarrow A &lt;: C\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equivalent</em> (<span class="math inline">\(A \equiv B\)</span>), iff <span class="math inline">\(A &lt;: B \land B &lt;: A\)</span>. </span><span class="sentence">Due to the presence of flexible types, this relation is <strong>not</strong> transitive (see <a href="#subtyping-for-flexible-types">here</a> for more details).</span></p>
</div>
<h4 id="subtyping-rules">Subtyping rules</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, concrete types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any simple classifier type <span class="math inline">\(T : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: T &lt;: S_i\)</span></span></li>
<li><span class="sentence">For any iPACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n)[A_1, \ldots, A_n] : S_1, \ldots, S_m\)</span> with captured type arguments <span class="math inline">\(C_1, \ldots, C_n\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i[C_1, \ldots, C_n]\)</span></span></li>
<li><span class="sentence">For any two iPACTs <span class="math inline">\(\widehat{T}\)</span> and <span class="math inline">\(\widehat{T^\prime}\)</span> with captured type arguments <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: C_i &lt;: C_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, abstract types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any PACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Subtyping for type parameters)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, captured types uses rules of different kind, as captured type <span class="math inline">\(C\)</span> describes not one, but a set of types which satisfy its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence">Therefore, we use the following subtyping rules for captured types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall C : \text{kotlin.Nothing} &lt;: C &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any two captured types <span class="math inline">\(C\)</span> and <span class="math inline">\(C^\prime\)</span>, <span class="math inline">\(C &lt;: C^\prime\)</span> if <span class="math inline">\(\forall T : \mathbb{C}(T) \Rightarrow \mathbb{C^\prime}(T)\)</span> (i.e., a set of types for <span class="math inline">\(C\)</span> is a subset of a set of types for <span class="math inline">\(C^\prime\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for nullable types is checked separately and uses a special set of rules which are described <a href="#subtyping-for-nullable-types">here</a>.</span></p>
</div>
<h4 id="subtyping-for-flexible-types">Subtyping for flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Flexible types (being flexible) follow a simple subtyping relation with other inflexible types. </span><span class="sentence">Let <span class="math inline">\(T, A, B, L, U\)</span> be inflexible types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: T \Rightarrow (L..U) &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(T &lt;: U \Rightarrow T &lt;: (L..U)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This captures the notion of flexible type <span class="math inline">\((L..U)\)</span> as something which may be used in place of any type in between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>. </span><span class="sentence">If we are to extend this idea to subtyping between <em>two</em> flexible types, we get the following definition.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: B \Rightarrow (L..U) &lt;: (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This is the most extensive definition possible, which, unfortunately, makes the type equivalence relation non-transitive. </span><span class="sentence">Let <span class="math inline">\(A, B\)</span> be two <em>different</em> types, for which <span class="math inline">\(A &lt;: B\)</span>. </span><span class="sentence">The following relations hold:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A &lt;: (A..B) \land (A..B) &lt;: A \Rightarrow A \equiv (A..B)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: (A..B) \land (A..B) &lt;: B \Rightarrow B \equiv (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, <span class="math inline">\(A \not \equiv B\)</span>.</span></p>
</div>
<h4 id="subtyping-for-nullable-types">Subtyping for nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is defined via <em>two</em> relations, both of which must hold.</span></p>
</div>
<ul>
<li><span class="sentence">Regular subtyping <span class="math inline">\(&lt;:\)</span> for non-nullable types <span class="math inline">\(A!!\)</span> and <span class="math inline">\(B!!\)</span></span></li>
<li><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span> for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A!! \stackrel{null}{&lt;:}B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\exists T!! : A &lt;: T!!\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B?\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\not \exists T!! : B &lt;: T!!\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(How the existence check works)</span></p>
</div>
</div>
<h3 id="generics">Generics</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Here be a lot of dragons…)</span></p>
</div>
</div>
<h3 id="references">References</h3>
<ol type="1">
<li><span class="sentence">Tate, Ross. </span><span class="sentence">“Mixed-site variance.” FOOL, 2013. </span><span class="sentence">## Declarations</span></li>
</ol>
<h3 id="glossary-2">Glossary</h3>
<dl>
<dt>Entity</dt>
<dd><span class="sentence">A distinguishable part of a program</span>
</dd>
</dl>
<h3 id="introduction-2">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e. they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] (<code>class</code> | <code>interface</code>) {<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <em>typeParameters</em>] [{<em>NL</em>} <em>primaryConstructor</em>]<br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>classBody</em> | {<em>NL</em>} <em>enumClassBody</em>]</span>
</dd>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] <code>object</code><br />
{<em>NL</em>} <em>simpleIdentifier</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>delegationSpecifiers</em>]<br />
[{<em>NL</em>} <em>classBody</em>]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Classifier declarations introduce new types to the program, of the forms described <a href="#classifier-types">here</a>. </span><span class="sentence">There are three kinds of classifier declarations:</span></p>
</div>
<ul>
<li><span class="sentence">class declarations</span></li>
<li><span class="sentence">interface declarations</span></li>
<li><span class="sentence">object declarations</span></li>
</ul>
<h4 id="class-declaration">Class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A simple class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a simple classifier type <span class="math inline">\(c : S_1, \ldots, S_s\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Supertype specifiers are used to create inheritance relation between the declared type and the specified supertype. </span><span class="sentence">You can use classes and interfaces as supertypes, but not objects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is allowed to inherit from a single class only, i.e., multiple class inheritance is not supported. </span><span class="sentence">Multiple interface inheritance is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Instance initialization block describes a block of code which should be executed during <a href="#classifier-initialization">object creation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Property and function declarations in the class body introduce their respective entities in this class’ scope, meaning they are available only on an entity of the corresponding class.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Companion object declaration <code>companion object CO { ... }</code> for class <code>C</code> introduces an object, which is available under this class’ name or under the reference <code>C.CO</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Nested classifier declaraions)</span></p>
</div>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="al">TODO(Examples)</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">A parameterized class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple class declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h5 id="constructor-declaration">Constructor declaration</h5>
<div class="paragraph">
<p><span class="sentence">There are two types of class constructors in Kotlin: primary and secondary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary constructor is a concise way of describing class properties together with constructor parameters, and has the following form</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[ptor : (p_1, \ldots, p_n)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where each of <span class="math inline">\(p_i\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">regular constructor parameter <span class="math inline">\(name: type\)</span></span></li>
<li><span class="sentence">read-only property constructor parameter <span class="math inline">\(val name: type\)</span></span></li>
<li><span class="sentence">mutable property constructor parameter <span class="math inline">\(var name: type\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Property constructor parameters, together with being regular constructor parameters, also declare class properties of the same name and type. </span><span class="sentence">One can consider them to have the following syntactic expansion.</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">d</span>: <span class="dt">Double</span>, <span class="kw">var</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d</span>, <span class="va">s</span>) {}</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">class</span> FooEx(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">d_</span>: <span class="dt">Double</span>, <span class="va">s_</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d_</span>, <span class="va">s_</span>) {</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">val</span> <span class="va">d</span> = d_</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">var</span> <span class="va">s</span> = s_</a>
<a class="sourceLine" id="cb2-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">When accessing property constructor parameters inside the class body, one works with their corresponding properties; however, when accessing them in the supertype specifier list (e.g., as an argument to a superclass constructor invocation), we see them as actual parameters, which cannot be changed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class declaration has a primary constructor and also includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A secondary constructor describes an alternative way of creating a class instance and has only regular constructor parameters. </span><span class="sentence">If a class has a primary constructor, any secondary constructor must delegate to either the primary constructor or to another secondary constructor via <code>this(...)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have a primary constructor, its secondary constructors must delegate to either the superclass constructor via <code>super(...)</code> (if the superclass is present in the supertype specifier list) or to another secondary constructor via <code>this(...)</code>. </span><span class="sentence">If the only superclass is <code>Any</code>, delegation is optional.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In all cases, it is forbidden if two or more secondary constructors form a delegation loop.</span></p>
</div>
<h5 id="nested-and-inner-classes">Nested and inner classes</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h5 id="inheritance-delegation">Inheritance delegation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="data-class-declaration">Data class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A data class <span class="math inline">\(dataClass\)</span> is a special kind of class, which represents a product type constructed from a number of data properties <span class="math inline">\((dp_1, \ldots, dp_m)\)</span>, described in its primary constructor. </span><span class="sentence">As such, it allows Kotlin to reduce the boilerplate and generate a number of additional data-relevant functions.</span></p>
</div>
<ul>
<li><span class="sentence"><code>equals() / hashCode() / toString()</code> functions compliant with their contracts</span></li>
<li><span class="sentence">A <code>copy()</code> function for shallow object copying</span></li>
<li><span class="sentence">A number of <code>componentN()</code> functions for destructive declaration</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All these functions consider only data properties <span class="math inline">\(\{dp_i\}\)</span>; e.g., your data class may include regular property declarations in its body, however, they will <em>not</em> be considered in the <code>equals()</code> implementation or have a <code>componentN()</code> generated for them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To support these features, data classes have the following restrictions.</span></p>
</div>
<ul>
<li><span class="sentence">Data classes are final and cannot be inherited from</span></li>
<li><span class="sentence">Data classes must have a primary constructor with only property constructor parameters, which become data properties for the data class</span></li>
</ul>
<h5 id="data-class-generation">Data class generation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(A more detailed explaination)</span></p>
</div>
</div>
<h4 id="enum-class-declaration">Enum class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="annotation-class-declaration">Annotation class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="interface-declaration">Interface declaration</h4>
<div class="paragraph">
<p><span class="sentence">Interfaces differ from classes in that they cannot be directly instantiated in the program, they are meant as a way of describing a contract which should be satisfied by the interface’s subtypes. </span><span class="sentence">In other aspects they are similar to classes, therefore we shall specify their declarations by specifying their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An interface cannot have a class as its supertype</span></li>
<li><span class="sentence">An interface cannot have a constructor</span></li>
<li><span class="sentence">Interface properties cannot have initializers</span></li>
<li><span class="sentence">All interface members must be public</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="object-declaration">Object declaration</h4>
<div class="paragraph">
<p><span class="sentence">Object declarations are used to support a singleton pattern and, thus, do two things at the same time. </span><span class="sentence">One, they (just like class declarations) introduce a new type to the program. </span><span class="sentence">Two, they create a singleton-like object of that type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Similarly to interfaces, we shall specify object declarations by highlighting their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An object type cannot be used as a supertype for other types</span></li>
<li><span class="sentence">An object cannot have a constructor</span></li>
<li><span class="sentence">An object cannot be parameterized, i.e., cannot have type parameters</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="anonymous-object-declaration">Anonymous object declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h4 id="classifier-initialization">Classifier initialization</h4>
<div class="paragraph">
<p><span class="sentence">When creating a class or object instance via one of its constructors <span class="math inline">\(ctor\)</span>, it is initialized in a particular order, which we describe here.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">First, a supertype constructor corresponding to <span class="math inline">\(ctor\)</span> is called with its respective parameters.</span></p>
</div>
<ul>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a primary constructor, a corresponding supertype constructor is the one from the supertype specifier list</span></li>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a secondary constructor, a corresponding supertype constructor is the one ending the constructor delegation chain of <span class="math inline">\(ctor\)</span></span></li>
<li><span class="sentence">If an explicit supertype constructor is not available, <code>Any()</code> is implicitly used</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">After the supertype initialization is done, we continue the initialization by processing each inner declaration in its body, <em>in the order of their inclusion in the body</em>. </span><span class="sentence">If any initialization step creates a loop, it is considered an undefined behavior.</span></p>
</div>
<h3 id="function-declaration">Function declaration</h3>
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>]<br />
<code>fun</code><br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>] ({<em>NL</em>} <em>simpleIdentifier</em>)<br />
{<em>NL</em>} <em>functionValueParameters</em><br />
[{<em>NL</em>} <code>:</code> {<em>NL</em>} <em>type</em>]<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} <em>functionBody</em>]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Function declarations assign names to such entities as functions — blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail <a href="#function-types">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A simple function declaration consists of four main parts</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a function type <span class="math inline">\(f : (P_1, \ldots, P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span> describes function parameters — inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>; therefore, parameters are final and cannot be changed inside the function. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> should be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Return type <span class="math inline">\(R\)</span> is optional, if function body <span class="math inline">\(b\)</span> is present and may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv kotlin.Nothing\)</span>, in which case <span class="math inline">\(R \equiv B\)</span>. </span><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> must be specified explicitly.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As type <span class="math inline">\(kotlin.Nothing\)</span> has a <a href="#kotlin.nothing">special meaning</a> in Kotlin type system, it must be specified explicitly, to avoid spurious <span class="math inline">\(kotlin.Nothing\)</span> function return types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is ommited, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="#classifier-declaration">abstract classifier declaration</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized function declaration consists of five main parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple function declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h4 id="named-positional-and-default-parameters">Named, positional and default parameters</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>named</em> parameters out-of-the-box, meaning one can bind an argument to a parameter in function invocation not by its position, but by its name, which is equal to the argument name.</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Double</span>, <span class="va">s</span>: <span class="dt">String</span>): <span class="dt">Double</span> = a + b + s.toDouble()</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb3-4" title="4">    println(bar(b = <span class="fl">42.0</span>, a = <span class="dv">5</span>, s = <span class="st">&quot;13&quot;</span>))</a>
<a class="sourceLine" id="cb3-5" title="5">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Argument names are resolved in compile time)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If one wants to mix named and positional arguments, the argument list must conform to the following form: <span class="math inline">\(P_1, \ldots, P_M, N_1, \ldots, N_Q\)</span>, where <span class="math inline">\(P_i\)</span> is a positional argument, <span class="math inline">\(N_j\)</span> is a named argument; i.e., positional arguments must precede all of the named ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports <em>default</em> parameters — parameters which have a default value used in function invocation, if the corresponding argument is missing. </span><span class="sentence">Note that default parameters cannot be used to provide a value for positional argument <em>in the middle</em> of the positional argument list; allowing this would create an ambiguity of which argument for position <span class="math inline">\(i\)</span> is the correct one: explicit one provided by the developer or implicit one from the default value.</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span> = 1, <span class="va">b</span>: <span class="dt">Double</span> = 42.0, <span class="va">s</span>: <span class="dt">String</span> = <span class="st">&quot;Hello&quot;</span>): <span class="dt">Double</span> =</a>
<a class="sourceLine" id="cb4-2" title="2">    a + b + s.toDouble()</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="co">// Valid call, all default parameters used</span></a>
<a class="sourceLine" id="cb4-6" title="6">    println(bar())</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="co">// Valid call, defaults for `b` and `s` used</span></a>
<a class="sourceLine" id="cb4-8" title="8">    println(bar(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="co">// Valid call, default for `b` used</span></a>
<a class="sourceLine" id="cb4-10" title="10">    println(bar(<span class="dv">2</span>, s = <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="co">// Invalid call, default for `b` cannot be used</span></a>
<a class="sourceLine" id="cb4-13" title="13">    println(bar(<span class="dv">2</span>, <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb4-14" title="14">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">In summary, argument list should have the following form:</span></p>
</div>
<ul>
<li><span class="sentence">Zero or more positional arguments</span></li>
<li><span class="sentence">Zero or more named arguments</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Missing arguments are bound to their default values.</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
<p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as an <a href="#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments. </span><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to an <a href="#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An array of type <span class="math inline">\(Q &lt;: P_i\)</span> may be <em>unpacked</em> to a variable length parameter in function invocation using <a href="#spread-operator-1">spread operator</a>; in this case array elements are considered to be separate arguments in the variable length parameter position. </span><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="function-type-parameters">Function type parameters</h4>
<div class="paragraph">
<p><span class="sentence">Some parameters may have <a href="#function-types">function types</a>, as Kotlin supports first-class functions. </span><span class="sentence">Function type parameters do not have any special treatment on the function declaration side, however, there are some special cases on the invocation side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Function type parameter may bind to an argument of the following kinds - [callable reference][Callable references] - <a href="#anonymous-function-declarations-1">anonymous function</a> - <a href="#lambda-literals-1">lambda literal</a> Iff we use a lambda literal for the <strong>last</strong> parameter in the parameter list, it can be written outside the argument list, as in this example.</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Int</span>, <span class="va">f</span>: (<span class="dt">Int</span>, <span class="dt">Int</span>) -&gt; <span class="dt">String</span>): <span class="dt">String</span> = f(a, b)</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Int</span>) = foo(a, b) { a, b -&gt; <span class="st">&quot;${a + b}&quot;</span> }</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Describe possible ambiguities?)</span></p>
</div>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h4 id="anonymous-function-declaration">Anonymous function declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="property-declaration">Property declaration</h3>
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] (<code>val</code> | <code>var</code>)<br />
[{<em>NL</em>} <em>typeParameters</em>]<br />
[{<em>NL</em>} <em>type</em> {<em>NL</em>} <code>.</code>]<br />
({<em>NL</em>} (<em>multiVariableDeclaration</em> | <em>variableDeclaration</em>))<br />
[{<em>NL</em>} <em>typeConstraints</em>]<br />
[{<em>NL</em>} (<code>by</code> | <code>=</code>) {<em>NL</em>} <em>expression</em>]<br />
[NL+ <code>;</code>] {<em>NL</em>} [[<em>getter</em>] ({<em>NL</em>} [<em>semi</em>] <em>setter</em>] | [<em>setter</em>] [{<em>NL</em>} [<em>semi</em>] <em>getter</em>])</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter — functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>. </span><span class="sentence">Both the right-hand value <code>e</code> and the type <code>T</code> are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if the type of <code>e</code> cannot be [inferred][Type inference], the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see <a href="#subtyping">subtyping</a> for more details).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration may include a custom <a href="#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation.</span></p>
</div>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration may include a custom <a href="#getters-and-setters">getter</a> and/or custom <a href="#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code>. </span><span class="sentence">One may view these properties as regular properties with a special <em>delegating</em> <a href="#getters-and-setters">getters</a>. </span><span class="sentence">TODO(Type is optional if inferred?)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In case of a delegated read-only property, access to <code>x</code> is replaced with the call to a special function <code>getValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">getValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>): <span class="dt">R</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
<ul>
<li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
<li><span class="sentence">is <code>null</code> for <a href="#local-property-declaration">local properties</a></span></li>
</ul></li>
<li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
<ul>
<li><span class="sentence"><code>property.name</code> holds the property name</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This convention implies the following requirements on the <code>getValue</code> function</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
<li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="#getters-and-setters">getters and setters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read access is handeled using the same <code>getValue</code> function as for a delegated read-only property. </span><span class="sentence">Write access is processed using a special function <code>setValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">setValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>, <span class="va">value</span>: <span class="dt">R</span>): <span class="dt">U</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
<ul>
<li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
<li><span class="sentence">is <code>null</code> for <a href="#local-property-declaration">local properties</a></span></li>
</ul></li>
<li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
<ul>
<li><span class="sentence"><code>property.name</code> holds the property name</span></li>
</ul></li>
<li><span class="sentence"><code>value: R</code> is the new property value</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This convention implies the following requirements on the <code>setValue</code> function</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
<li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(U\)</span> is ignored</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The delegated property is expanded as follows.</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co"> * Actual code</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="kw">var</span> <span class="va">prop</span>: Type <span class="kw">by</span> DelegateExpression</a>
<a class="sourceLine" id="cb10-6" title="6">}</a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">/*</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="co"> * Expanded code</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb10-12" title="12">    <span class="kw">private</span> <span class="kw">val</span> <span class="va">prop</span>$delegate = DelegateExpression</a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="kw">var</span> <span class="va">prop</span>: Type</a>
<a class="sourceLine" id="cb10-14" title="14">        <span class="kw">get</span>() = prop$delegate.getValue(<span class="kw">this</span>, <span class="kw">this</span>::prop)</a>
<a class="sourceLine" id="cb10-15" title="15">        <span class="kw">set</span>(value: Type) = prop$delegate.setValue(<span class="kw">this</span>, <span class="kw">this</span>::prop, value)</a>
<a class="sourceLine" id="cb10-16" title="16">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(provideDelegate)</span></p>
</div>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
<p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Local property declarations also support <em>destructive</em> declaration in the form of</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">which is a syntactic sygar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb12-4" title="4">...</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Each individual component property follows the rules for regular local property declaration.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
<p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">set</span>(anyValidArgumentName: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">Both <span class="math inline">\(TG\)</span> and <span class="math inline">\(TG\)</span> types are optional and may be omitted from the declaration</span></p>
</div></li>
<li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter</span></li>
<li><div class="paragraph">
<p><span class="sentence">Mutable properties may have any combination of a cusom getter and a custom setter</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Setter argument may have any valid argument name</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can also ommit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the property’s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
<li><span class="sentence">For a property declaration of type <code>T</code>, field<code>has the same type</code>T`</span></li>
<li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
<li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
<li><span class="sentence">A property has no custom accessors</span></li>
<li><span class="sentence">A property has a default accessor</span></li>
<li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property</span></li>
<li><span class="sentence">A mutable property has a custom getter or setter, but not both</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In all other cases a property has no backing field.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
<p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail [here][Control- and data-flow analysis].</span></p>
</div>
<h3 id="type-alias">Type alias</h3>
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em>modifierList</em>] <code>typealias</code> {<em>NL</em>} <em>simpleIdentifier</em> [{<em>NL</em>} <em>typeParameters</em>] {<em>NL</em>} <code>=</code> {<em>NL</em>} <em>type</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be <a href="#type-parameters">unbounded</a>. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden — the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its <a href="#visibility"><em>visibility modifiers</em></a>.</span></p>
</div>
<h3 id="declarations-with-type-parameters">Declarations with type parameters</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="declaration-modifiers">Declaration modifiers</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(declaration scope)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(open)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(abstract)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(lateinit)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(const) ## Inheritance</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…) ## Scopes and identifiers</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">All the program code in Kotlin is logically divided into <em>scopes</em>. </span><span class="sentence">A scope is a syntactically-delimited region of code that constitutes a context in which entities and their names can be introduced. </span><span class="sentence">Scopes are nested, with entities introduced in outer scopes also available in the inner scopes. </span><span class="sentence">The top level of a Kotlin file is also a scope, containing all the scopes within the file.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All the scopes are divided into two categories: declaration scopes and statement scopes. </span><span class="sentence">These two kinds of scopes differ in how the identifiers in code refer to the values definied in the scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declaration scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a normal Kotlin file (not script file);</span></li>
<li><span class="sentence">The bodies of <a href="#classifier-declaration">classifier declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#object-literals-1">object literals</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Statement scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a Kotlin script file;</span></li>
<li><span class="sentence">Various scopes produced by control structure bodies of different <a href="#expressions-1">expressions</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#function-declaration">function declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#anonymous-function-declarations-1">anonymous function literals</a>;</span></li>
<li><span class="sentence">The bodies of getters and setters of <a href="#property-declaration">properties</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#constructor-declaration">constructors</a>;</span></li>
<li><span class="sentence">The bodies of instance initialization blocks in <a href="#class-declaration">class declarations</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All the declarations in a particular scope introduce new <em>bindings</em> of identifiers in this scope to their respective entities in the program. </span><span class="sentence">These entities may be types or values, where values may refer to objects, functions or properties (that may be delegated). </span><span class="sentence">Top-level scopes additionally allow to introduce such bindings using <a href="#packages-and-imports"><code>import</code> directive</a> from other top-level scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In most situations, it is not allowed to bind several values to the same identifier in the same scope, but it is allowed to bind a value to an identifier already available in the scope through outer scopes or imports. </span><span class="sentence">An exception to this rule are function declarations, that, in addition to identifier bound to, also may differ by signature <span><span class="TODO">(TODO: what’s a signature?)</span><span class="TODO-marker">*</span></span> and allow definining several functions with the same name in the same scope. </span><span class="sentence">When <a href="#call-and-property-access-expressions-1">calling functions</a> a process called <a href="#overload-resolution">overloading resolution</a> takes places that allows differentiating such functions. </span><span class="sentence">Overloading resolution also applies to properties if they are used as functions through <code>invoke</code>-convention, but it does not mean several properties with the same name may be defined in the same scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between declaration scopes and statement scopes is that names in the statement scope are bound in the order their declarations appear in it. </span><span class="sentence">It is not allowed to access a value through an identifier in the code that (syntactically) precedes the binding itself. </span><span class="sentence">On the contrary, in declaration scopes it is fully allowed, although initialization cycles may occur and need to be detected by the compiler. </span><span class="sentence">It also means that the statement scopes nested inside declaration scopes may access values declared after itself in the declaration scopes, but any values defined inside the statement scope must be accessed only after they are declared.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">In declaration scope:</span></p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" title="1">    <span class="co">// x refers to the property defined below even if there is another property</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="co">// called x in outer scope or imported</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">In statement scope:</span></p>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" title="1">    <span class="co">// x either refers to other property defined in some outer scope or imported</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="co">// or it is a compile-time error</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: please note that all the above is primarily applied to declarations, because declaration scopes do not allow standalone statements to appear in them</span></p>
</div>
</blockquote>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(qualified names?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(extensions?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(receivers)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(rewrite expressions and statements as references to this part)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(identifier lifetime &amp; such)</span>
</div></li>
</ul>
<h2 id="visibility">Visibility</h2>
<div class="paragraph">
<p><span class="sentence">Any entity declared in a declaration scope has an implicitly or explicitly defined <em>visibility</em>. </span><span class="sentence">The visibility of a declaration denotes whether the entity is <em>accessible</em> in other scopes of the program. </span><span class="sentence">If the entity declared in scope <code>A</code> is not accessible in scope <code>B</code>, it cannot be referred to in that scope, making such reference a compiler error. </span><span class="sentence">There are four basic types of visibility in kotlin: <code>public</code>, <code>private</code>, <code>internal</code> and <code>protected</code>, denoted by the corresponding visibility modifier keywords.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Entities that have <code>public</code> visibility are generally accessible anywhere outside or inside the scope they are declared in, by using imports or qualification when necessary. </span><span class="sentence">Entities that have <code>private</code> visibility are only accessible inside the scope they are declared in or any nested scopes. </span><span class="sentence">For top-level scopes (i.e. kotlin files) it means that such entities are only accessible in the same file. </span><span class="sentence">Entities with <code>internal</code> visibility are accessible inside the same <a href="#modules">module</a> just like if the visibility was <code>public</code> and are inaccessible (as if the visibility was <code>private</code>) in any other scope. </span><span class="sentence">Entities with <code>protected</code> visibility are only allowed in the body scope of class declarations and are used as a means of encapsulation: such entities are accessible inside any scope as if the visibility was <code>private</code>, but are also accessible by any derived classes’ scopes as if they were declared <code>private</code> in the body scope of the derived class.</span></p>
</div>
<h2 id="statements">Statements</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
</dd>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em>labelDefinition</em>}<br />
( <em>declaration</em><br />
| <em>assignment</em><br />
| <em>loopStatement</em><br />
| <em>expression</em>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin statements include bare expressions and declarations. </span><span class="sentence">This section is focused on those statements that are <em>not</em> expressions or declarations. </span><span class="sentence">For information about expressions and declarations please refer to the corresponding sections of this document.</span></p>
</div>
<h3 id="assignments">Assignments</h3>
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence"><em>directlyAssignableExpression</em> <code>=</code> {<em>NL</em>} <em>expression</em><br />
| <em>assignableExpression</em> <em>assignmentAndOperator</em> {<em>NL</em>} <em>expression</em></span>
</dd>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>+=</code><br />
| <code>-=</code><br />
| <code>*=</code><br />
| <code>/=</code><br />
| <code>%=</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">An <em>assignment</em> is a statement that writes a new value to some location, denoted by its left hand side. </span><span class="sentence">Both left-hand and right-hand sides of an assignment are expressions, although there are several restrictions for the expression on the left hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For an expression to be <em>assignable</em>, i.e. be allowed to occur on the left-hand side of an assignment, it <strong>must</strong> be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">An identifier referring to a mutable property;</span></li>
<li><span class="sentence">A navigation expression referring to a mutable property;</span></li>
<li><span class="sentence">An [indexing expression][Indexing expression], see details below.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin assignments <strong>are not</strong> expressions and cannot be used as such.</span></p>
</div>
<h4 id="simple-assignment">Simple assignment</h4>
<div class="paragraph">
<p><span class="sentence">A <em>simple assigment</em> is the assignment form employing the assign operator <code>=</code>. </span><span class="sentence">If the left-hand side of the assignment refers to a mutable property, a mutation of that property is performed when the assignment is evaluated:</span></p>
</div>
<ul>
<li><span class="sentence">If the property is [delegated][Property delegation], the corresponding operator function <code>setValue</code> is called using the right-hand side expression value as value argument;</span></li>
<li><span class="sentence">If the property has a setter, it is called using the right-hand side expression value as value argument;</span></li>
<li><span class="sentence">If the property is just a variable without delegation or setter, it’s value is directly changed to the value of the right-hand side expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the left-hand side of the assignment is an indexing expression, the whole statement is treated as an overloaded operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,…,<span class="math inline">\(B_N\)</span><code>] =</code><span class="math inline">\(C\)</span> is exactly the same as calling <span class="math inline">\(A\)</span><code>.set(</code><span class="math inline">\(B_1\)</span>,<span class="math inline">\(B_2\)</span>,<span class="math inline">\(B_3\)</span>,…,<span class="math inline">\(B_N\)</span>,<span class="math inline">\(C\)</span><code>)</code> where <code>set</code> is a sutable <code>operator</code> function.</span></p>
</div>
<h4 id="operator-assignments">Operator assignments</h4>
<div class="paragraph">
<p><span class="sentence">An <em>operator assignment</em> is a combined-form assignment that involves one of the following operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>. </span><span class="sentence">All these are overloadable operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.plusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>plus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.minusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>minus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.timesAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>timesAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>times</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.divAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>divAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>div</code> operator function exists and is available;</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following (in this order):</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.remAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>remAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code> if a corresponding suitable <code>rem</code> operator function exists and is available.</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The expanded simple assignment is then proceeded as described in the previous section.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Although for most real-world usecases operators <code>++</code> and <code>--</code> are very similar to operator assignments, in Kotlin they are actually expressions and are described as such in the <a href="#expressions-1">corresponding section</a> of this document.</span></p>
</div>
</blockquote>
<h3 id="loop-statements">Loop statements</h3>
<div class="paragraph">
<p><span class="sentence">Loop statements are constructs that repeat evaluating a certain number of statements until a <em>loop exit condition</em> applies.</span></p>
</div>
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em>forStatement</em><br />
| <em>whileStatement</em><br />
| <em>doWhileStatement</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Loops are closely related to the semantics of several <a href="#jump-expressions-1">jump expressions</a>, as these expressions, namely <code>break</code> and <code>continue</code>, are only allowed in the body of a loop. </span><span class="sentence">Please refer to the corresponding section for details.</span></p>
</div>
<h4 id="while-loop">While loop</h4>
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <em>controlStructureBody</em><br />
| <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code> {<em>NL</em>} <code>;</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence"><em>While loop statement</em> is very similar to an <a href="#conditional-expression-1"><code>if</code> expression</a> in the way that it contains a condition expression and a body consisting of one or more statements. </span><span class="sentence">While loop repeats evaluating its body for as long as the condition expression evaluates to true or a <a href="#jump-expressions-1">jump expression</a> is evaluated to finish the loop.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that the condition expression is evaluated before every evaluation of the body, including the first one.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="do-while-loop">Do-while loop</h4>
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>do</code> {<em>NL</em>} [<em>controlStructureBody</em>] {<em>NL</em>} <code>while</code> {<em>NL</em>} <code>(</code> <em>expression</em> <code>)</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>do-while statement</em> is very similar to the while statement, but with a few differences. </span><span class="sentence">First, it has a different syntax. </span><span class="sentence">Second, it evaluates the loop condition expression <strong>after</strong> evaluating the loop body.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that the body is always evaluated at least once</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As for the <code>if</code> expression, the condition subexpression <strong>must have</strong> type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="for-loop">For loop</h4>
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>for</code> {<em>NL</em>} <code>(</code> {<em>annotation</em>} (variableDeclaration | <em>multiVariableDeclaration</em>) <code>in</code> <em>expression</em> <code>)</code> {<em>NL</em>} [<em>controlStructureBody</em>]</span>
</dd>
</dl>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike other languages, Kotlin does not have a free-form condition-based for loops. </span><span class="sentence">The only form of for-loop available in Kotlin is (what it’s called in other languages) “the foreach loop”, iterating over arrays and other datastructures</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>for statement</em> is a special kind of loop statements that is used to iterate over data structures containing a number of elements. </span><span class="sentence">The for loop consists of a loop body, a <strong>container expression</strong> and the <strong>iteration variable declaration</strong>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The for loop is actually an [overloadable][Overloadable operators] syntax form with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>for(</code><span class="math inline">\(VarDecl\)</span><code>) in</code><span class="math inline">\(C\)</span><code>) $Body$</code> is exactly the same as</span></p>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">val</span> <span class="va">__iterator</span> = C.iterator()</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="cf">while</span>(__iterator.hasNext()) {</a>
<a class="sourceLine" id="cb17-3" title="3">    VarDecl = __iterator.next()</a>
<a class="sourceLine" id="cb17-4" title="4">    &lt;... all the statements from Body&gt;</a>
<a class="sourceLine" id="cb17-5" title="5">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>iterator</code>, <code>hasNext</code>, <code>next</code> are all acceptable operator functions available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Please note that expansions are hygenic, meaning the generated iterator variable never clashes with any other values in the program and cannot be accessed outside the expansion</span></p>
</div>
</blockquote>
<h3 id="code-blocks">Code blocks</h3>
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>{</code> {<em>NL</em>} <em>statements</em> {<em>NL</em>} <code>}</code></span>
</dd>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em>statement</em> {semis <em>statement</em>} [<em>semis</em>]]</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>code block</em> is a series of statements between curly braces separated by newlines or/and semicolons. </span><span class="sentence">A code block may be empty. </span><span class="sentence">Evaluating a code block means evaluating all its statements in the order they are given inside it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <em>last expression</em> of a code block is the last statement in the block (if any) if and only if this statement is also an expression. </span><span class="sentence">The last expressions are important when defining functions and control structure expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The code block is said to contain no last expression if it does not contain any statements of the last statement is not an expression (e.g. it is an assignment, a loop or a declaration).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This usually means that a synthetic last expression with no runtime semantics and with type <code>kotlin.Unit</code> is introduced instead</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>control structure body</em> is either a single statement or a code block. </span><span class="sentence">The <em>last expression</em> of a control structure body is either the last expression of the code block (if it is a code block) or the single statement itself if it is an expression. </span><span class="sentence">If the control structure body is not a code block or an expression, it has no last expression.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This is usually equivalent to wrapping the single statement in a new synthetic code block</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In some contexts, a control structure body is expected to have a value and/or a type. </span><span class="sentence">The value of a control structure body is:</span></p>
</div>
<ul>
<li><span class="sentence">The value of its last expression if it exists;</span></li>
<li><span class="sentence">The singleton <code>kotlin.Unit</code> object otherwise.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The <em>type of a control structure body</em> is the type of its value.</span></p>
</div>
<h3 id="todo">TODO</h3>
<ul>
<li><span class="sentence">Are declarations statements or not?</span>
<ul>
<li><span class="sentence">In the current grammar, they are</span></li>
</ul></li>
<li><span class="sentence">Wording</span></li>
<li><span class="sentence">Mutable vs immutable properties</span></li>
<li><span class="sentence">How expansions with new variables actually work</span></li>
</ul>
<h2 id="expressions">Expressions</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An expression may be <em>used as a statement</em> or <em>used as an expression</em> depending on the context. </span><span class="sentence">As all expressions are valid statements <a href="#statements">see the statements section</a>, free expressions may be used as single statements or inside code blocks.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An expression is used as an expression if it is encountered at any position where a statement is not allowed, for example, as an operand to an operator or as an immediate argument for a function call. </span><span class="sentence">An expression is used as a statement if it is encountered at any position where a statement is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Some expressions are only allowed to be used as statements unless certain restrictions are met and this may affect the semantics, the compile-type type information and the safety of these expressions. </span><span class="sentence">All expressions are allowed to be used as statements.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="constant-literals">Constant literals</h3>
<div class="paragraph">
<p><span class="sentence">Constant literals are expressions that correspond to constant, non-changing values. </span><span class="sentence">Every constant literal is defined to have a single standard library type, whichever it is defined to be on current platform.</span></p>
</div>
<h4 id="boolean-literals">Boolean literals</h4>
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>true</code> | <code>false</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Keywords <code>true</code> and <code>false</code> denote boolean literals of corresponding values. </span><span class="sentence">These are two strong keywords and as such cannot be used as identifiers unless [escaped][Escaped identifiers]. </span><span class="sentence">Values <code>true</code> and <code>false</code> always have type <code>kotlin.Bool</code>.</span></p>
</div>
<h4 id="integer-literals">Integer literals</h4>
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
</dd>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
</dd>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
</dd>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
<h5 id="decimal-integer-literals">Decimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of decimal digit symbols (<code>0</code> though <code>9</code>) is a decimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one. </span><span class="sentence">Please note that unlike other languages Kotlin does not support octal literals. </span><span class="sentence">Even more, any decimal literal starting with digit <code>0</code> and containing more than 1 digit is not a valid decimal literal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Decimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A decimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="hexadecimal-integer-literals">Hexadecimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of hexadecimal digit symbols (<code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, or <code>A</code> through <code>F</code>) prefixed by <code>0x</code> or <code>0X</code> is a hexadecimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Hexadecimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A hexadecimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="binary-integer-literals">Binary integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of binary digit symbols (<code>0</code> or <code>1</code>) prefixed by <code>0b</code> or <code>0B</code> is a binary integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Binary literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A binary literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h4 id="real-literals">Real literals</h4>
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
</dd>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>real literal</em> consists of the following parts: the whole-number part, a decimal point (represented by the ASCII period character (<code>.</code>)), a fraction part and an exponent. </span><span class="sentence">Unlike other languages, Kotlin real literals may only be expressed in decimal numbers. </span><span class="sentence">The number also may be followed by type suffix (<code>f</code> or <code>F</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The exponent is an exponent mark (<code>e</code> or <code>E</code>) followed by an optionaly signed decimal integer (a sequence of decimal digits).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The whole-number part and the exponent part may be omitted. </span><span class="sentence">The fraction part may only be omitted together with the decimal point if the whole part and either the exponent part or type suffix are present. </span><span class="sentence">Unlike other languages, Kotlin does not support omitting the fraction part, but leaving the decimal point in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The digits of the whole-number part or the fraction part or the exponent may be optionally separated by underscores, but an underscore may not be placed between, before, or after these parts. </span><span class="sentence">It also may not be placed before or after the exponent sign symbol.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A real literal without a type suffix has type <code>kotlin.Double</code>, while a real literal with the type suffix does have type <code>kotlin.Float</code>. </span><span class="sentence">There is no special suffix attributed to the <code>kotlin.Double</code> type.</span></p>
</div>
<h4 id="character-literals">Character literals</h4>
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
</dd>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <strong>character literal</strong> defines a constant holding a unicode character value. </span><span class="sentence">A simply-formed character literal is any symbol between two single quotation mark symbols (ASCII single quotation <code>'</code>), excluding newline symbols (<em>CR</em> and <em>LF</em>), the single quotation symbol itself and the escaping mark (the ASCII backslash symbol <code>\</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A character literal may also contain an escaped symbol of two kinds: a simple escaped symbol or a unicode codepoint. </span><span class="sentence">Simple escaped symbols include:</span></p>
</div>
<ul>
<li><span class="sentence"><code>\t</code> — the unicode TAB symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\b</code> — the unicode BACKSPACE symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\r</code> — <em>CR</em>;</span></li>
<li><span class="sentence"><code>\n</code> — <em>LF</em>;</span></li>
<li><span class="sentence"><code>\'</code> — the unicode single quotation symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\&quot;</code> — the unicode double quotation symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\\</code> — the unicode backslash symbol symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\$</code> — the unicode DOLLAR symbol.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A unicode codepoint escape sequence is the symbols <code>\u</code> followed by exactly four hexadecimal digits. </span><span class="sentence">It represents the unicode symbol with the codepoint equal to the number represented by these digits. </span><span class="sentence">Please note that unicode escapes support only unicode symbols in range U+0000 to U+FFFF.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Any character literal has type <code>kotlin.Char</code>.</span></p>
</div>
<h4 id="string-literals-1">String literals</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports [string interpolation][String Interpolation] mechanisms that supersede traditional string literals. </span><span class="sentence">Please refer to the corresponding section.</span></p>
</div>
<h4 id="null-literal">Null literal</h4>
<div class="paragraph">
<p><span class="sentence">The keyword <code>null</code> signifies the <strong>null reference</strong>, which is a valid value for all <a href="#nullable-types">nullable types</a>. </span><span class="sentence">Null reference implicitly has the nullable <code>kotlin.Nothing?</code> type and is, by definition, the only valid value for this type (see <a href="#kotlin.nothing">the corresponding section</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): reshuffle these sections</span></p>
</div>
</div>
<h3 id="try-expression">Try-expression</h3>
<div id="grammar-rule-tryExpression-pasted-0" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock-pasted-1" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-type">type</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock-pasted-2" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>try-expression</em> is an expression starting with the keyword <code>try</code>. </span><span class="sentence">It consists of a code block (<em>try body</em>) and several optional additional blocks: one of more <em>catch blocks</em>, starting with the soft keyword <code>catch</code> with a single parameter called <em>exception parameter</em> followed by another code block and a single optional <em>finally block</em>, starting with the soft keyword <code>finally</code> and yet another code block. </span><span class="sentence">At least one catch or finally block must exist, otherwise the expression is ill-formed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The try-expression evaluates its body as normally, but if any statement in the body throws an exception, the exception, rather than being propagated up the call stack, gets checked for its type. </span><span class="sentence">If there exists any catch block which parameter type is valid for the checked exception, this catch block is evaluated immediately after the exception is thrown and the exception itself is passed inside the catch block as the corresponding parameter. </span><span class="sentence">If there are several catch blocks with suitable parameter types, the first one is picked.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If there is a finally block, it gets evaluated after any evaluated catch block, or, if no catch block was encountered, after the exception was thrown. </span><span class="sentence">If no catch block was selected, the exception is [propagated as usual][Exceptions] up the call stack after the finally block (if any) is evaluated. </span><span class="sentence">If no exception is thrown during the evaluation of the try body, no catch blocks are checked, but the finally block is executed anyway and program execution continues as normal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The value of the try-expression is the same as the value of the last expression of the try body (if no exception was thrown) or the value of the last expression of the selected catch block (if one was selected). </span><span class="sentence">All other situations mean that an exception is propagated up the call stack, so the value of the try-expression becomes irrelevant. </span><span class="sentence">The finally block does get executed as described above, but has no effect on the value returned by the try-expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the try-expression is the [least upper bound][Least upper bound] of the types of the last expressions of the try body and the last expressions of all the catch blocks <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If any of the blocks have no valid last expression, the type is inferred to be <code>kotlin.Unit</code>, but the try-expression may be used as an expression anyway.</span></p>
</div>
<h3 id="conditional-expression">Conditional expression</h3>
<div id="grammar-rule-ifExpression-pasted-3" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>Conditional expressions</strong> use the boolean value of one expression (<em>condition</em>) to decide which of two control structure bodies (<em>branches</em>) should be evaluated. </span><span class="sentence">If the condition evaluates to <code>true</code>, than the first branch (the true branch) is evaluated, otherwise the second branch is. </span><span class="sentence">The value of the resulting expression is the same as the value of the chosen branch. </span><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of two branches <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If one of the branches is omitted (see the grammar entry above), the resulting expression has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The condition expression must have type <code>kotlin.Boolean</code> <span><span class="TODO">(TODO(): or be smartcasted to it!)</span><span class="TODO-marker">*</span></span>, otherwise it is a type error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">When used as expressions, conditional expressions are special in the sense of operator precedence: they have the highest (same as all primary expressions) priority when placed on the right side of any binary expression, but when placed on the left side, they have the lowest priority. </span><span class="sentence">For details, see the <a href="#syntax-grammar">grammar</a></span></p>
</div>
</blockquote>
<h3 id="when-expression">When expression</h3>
<div id="grammar-rule-whenExpression-pasted-4" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry-pasted-5" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition-pasted-6" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest-pasted-7" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest-pasted-8" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression</strong> is alike a <strong>conditional expression</strong> in the sense that it allows several different control structure bodies (<em>cases</em>) to be evaluated depending on boolean conditions. </span><span class="sentence">The key difference, however, is that when expressions may include several different conditions. </span><span class="sentence">When expression has two different forms: with bound value and without it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression without bound value</strong> (the form where the expression enclosed in parantheses is absent) evaluates one of the many different expressions based on corresponding conditions present in the same <em>when entry</em>. </span><span class="sentence">Each entry consists of a boolean <em>condition</em> (or a special <code>else</code> condition), each of which is checked and evaluated in order of appearance. </span><span class="sentence">If the current condition evaluates to <code>true</code>, the corresponding expression is evaluated and the value of when expression is the same as the evaluated expression. </span><span class="sentence">All remaining conditions and expressions are not evaluated. </span><span class="sentence">The <code>else</code> branch is a special branch that evaluates if none of the branches above it evaluated to <code>true</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally speaking, you can always replace the <code>else</code> branch with literal <code>true</code> and the semantics of the entry would not change</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The <code>else</code> entry is also special in the sense that it <strong>must</strong> be the last entry in the expression, otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression with bound value</strong> (the form where the expression enclosed in parantheses is present) are very similar to the form without bound value, but use different syntax for conditions. </span><span class="sentence">In fact, it supports three different condition forms:</span></p>
</div>
<ul>
<li><span class="sentence"><em>Type test condition</em>: type checking operator [TODO: link] followed by type. </span><span class="sentence">The condition generated is a type check expression [TODO: link] with the same operator and the same type, but an implicit left hand side, which has the same value as the bound expression.</span></li>
<li><span class="sentence"><em>Contains test condition</em>: containment operator [TODO: link] followed by an expression; The condition generated is a containment check expression [TODO: link] with the same operator and the same right hand side expression, but an implicit left hand side, which has the same value as the bound expression.</span></li>
<li><span class="sentence"><em>Any other expression</em>. </span><span class="sentence">The condition generated is an equality operator [TODO: link], with the left hand side being the bound expression, and the right hand side being the expression placed inside the entry.</span></li>
<li><span class="sentence">The <code>else</code> condition, which works the exact same way as it would in the form without bound expression.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that if this form of <code>when</code> contains a boolean expression, it is not checked directly as if it would be in the other form, but rather checked for <strong>equality</strong> with the bound variable, which is not the same thing.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of all the entries <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If the expression is not <a href="#exhaustive-when-expressions-1">exhaustive</a>, it has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<h4 id="exhaustive-when-expressions">Exhaustive when expressions</h4>
<div class="paragraph">
<p><span class="sentence">A when expression is called <strong><em>exhaustive</em></strong> if at least one of the following is true:</span></p>
</div>
<ul>
<li><span class="sentence">It has an <code>else</code> entry;</span></li>
<li><span class="sentence">It has a bound value and at least one of the following holds:</span>
<ul>
<li><span class="sentence">The bound expression is of type <code>kotlin.Boolean</code> and the conditions contain both:</span>
<ul>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>true</code>;</span></li>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>false</code>;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of a [<code>sealed class</code>][Sealed classes] type and all its possible subtypes are covered using type test conditions of this expression. </span><span class="sentence">This may include:</span>
<ul>
<li><span class="sentence">Checks for all the direct subtypes of this sealed class;</span></li>
<li><span class="sentence">If any of the direct subtypes is also a sealed class, there is either a check for this subtype or all possible subtypes of it are also covered;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of an [<code>enum class</code>][Enum classes] type and all enumerated values are checked for equality using constant conditions;</span></li>
<li><span class="sentence">The bound expression is of a nullable type and one of the cases above is met for its non-nullable counterpart and, in addition, there is a condition containing literal <code>null</code>.</span></li>
</ul></li>
</ul>
<h3 id="logical-disjunction-expression">Logical disjunction expression</h3>
<div id="grammar-rule-disjunction-pasted-9" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>||</code> performs logical disjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>false</code>.</span></p>
</div>
<h3 id="logical-conjunction-expression">Logical conjunction expression</h3>
<div id="grammar-rule-conjunction-pasted-10" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>&amp;&amp;</code> performs logical conjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>true</code>.</span></p>
</div>
<h3 id="equality-expressions">Equality expressions</h3>
<div id="grammar-rule-equality-pasted-11" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator-pasted-12" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Equality expressions are binary expressions involving equality operators. </span><span class="sentence">There are two kinds of equality operators: <em>reference equality operators</em> and <em>value equality operators</em>.</span></p>
</div>
<h4 id="reference-equality-expressions">Reference equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Reference equality expressions</em> are binary expressions employing reference equality operators: <code>===</code> and <code>!==</code>. </span><span class="sentence">These expressions check if two values are equal <em>by reference</em>, meaning that two values are equal (non-equal for operator <code>!==</code>) if and only if they represent the same runtime value created using the same constructor call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For values created without construction calls, notably the constant literals and constant expressions composed of those literals, the following holds:</span></p>
</div>
<ul>
<li><span class="sentence">If these values are <a href="#value-equality-expressions-1">non-equal by value</a>, they are also non-equal by reference;</span></li>
<li><span class="sentence">Any instance of the null reference <code>null</code> is reference-equals to any other instance of the null reference;</span></li>
<li><span class="sentence">Otherwise, it is implementation-defined and must not be used as a means of comparing two such values.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Reference equality expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="value-equality-expressions">Value equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Value equality expressions</em> are binary expressions employing value equality operators: <code>==</code> and <code>!=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> <code>==</code> <span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null)</code> where <code>equals</code> is a valid operator function available in the current scope;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span> <code>!=</code> <span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null))</code> where <code>equals</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Please note that the class <code>kotlin.Any</code> has a built-in open operator member function called <code>equals</code>, meaning that there is always at least one available overloading candidate for any value equality expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Value equality expressions always have type <code>kotlin.Boolean</code>. </span><span class="sentence">If the corresponding operator function has a different return type, it is invalid and a compiler error should be generated.</span></p>
</div>
<h3 id="comparison-expressions">Comparison expressions</h3>
<div id="grammar-rule-comparison-pasted-13" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator-pasted-14" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Comparison expressions</em> are binary expressions employing the comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;</code><span class="math inline">\(B\)</span> is exactly the same as <code>0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>))</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>compareTo</code> is a valid operator function available in the current scope and <code>[&lt;]</code> (read “boxed less”) is a special operator unavailable for in-code use in Kotlin and performing integer “less-than” comparison of two integer numbers. </span><span class="sentence">The <code>compareTo</code> overloaded function must have return type <code>kotlin.Int</code>, otherwise it’s a compiler error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All comparison expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</h3>
<div id="grammar-rule-infixOperation-pasted-15" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator-pasted-16" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator-pasted-17" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<h4 id="type-checking-expression">Type-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A type checking expression employs the use of an type-checking operators <code>is</code> or <code>!is</code> and has an expression as a left-hand side operand and a type name as a right-hand side operand. </span><span class="sentence">The type must be <a href="#runtime-available-types">runtime-available</a>, otherwise a compiler error should be generated. </span><span class="sentence">The expression checks whether the runtime type of the expression on the left is the same (not the same for <code>!is</code>) as the type denoted by the right-hand side argument.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type-checking expression always has type <code>kotlin.Boolean</code>.</span></p>
</div>
<h5 id="todo-1">TODO()</h5>
<ul>
<li><span class="sentence">Smart casts!</span></li>
</ul>
<h4 id="containment-checking-expression">Containment-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>containment-checking expression</em> is a binary expression employing the containment operator (<code>in</code> or <code>!in</code>). </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>in</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>)</code>;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>!in</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>))</code>;</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>contains</code> is a valid operator function available in the current scope. </span><span class="sentence">This function must have return type <code>kotlin.Boolean</code>, otherwise a compiler error is generated. </span><span class="sentence">Containment-checking expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="elvis-operator-expression">Elvis operator expression</h3>
<div id="grammar-rule-elvisExpression-pasted-18" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Elvis operator expression</em> is a binary expression that emplys the elvis operator (<code>?:</code>). </span><span class="sentence">It checks whether the left-hand side expression is equal to <code>null</code>, and if it is, evaluates and return the right-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator is <strong>lazy</strong>, meaning that if the left-hand side expression is not equal to <code>null</code>, the right-hand side expression is never evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of elvis operator expression is the [least upper bound][The least upper bound] of the non-nullable variant of the type of the left-hand side expression and the type of the right-hand side expression. </span><span class="sentence">TODO(): not that simple, too</span></p>
</div>
<h3 id="range-expression">Range expression</h3>
<div id="grammar-rule-rangeExpression-pasted-19" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>range expression</em> is a binary expression employing the range operator <code>..</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>..</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rangeTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>rangeTo</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding <code>rangeTo</code> overload variant.</span></p>
</div>
<h3 id="additive-expression">Additive expression</h3>
<div id="grammar-rule-additiveExpression-pasted-20" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator-pasted-21" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>additive expression</em> is a binary expression employing the addition (<code>+</code>) or subtraction (<code>-</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>plus</code> or <code>minus</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="multiplicative-expression">Multiplicative expression</h3>
<div id="grammar-rule-multiplicativeExpression-pasted-22" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator-pasted-23" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>multiplicative expression</em> is a binary expression employing the multiplication (<code>*</code>), division (<code>/</code>) or remainder (<code>%</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">where <code>times</code>, <code>div</code>, <code>rem</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="cast-expression">Cast expression</h3>
<div id="grammar-rule-asExpression-pasted-24" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator-pasted-25" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>cast expression</em> is a binary expression employing the cast operators (<code>as</code> or <code>as?</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The form of cast expression employing the <code>as</code> operator is called <em>a unsafe cast</em> expression This operator perform a runtime check whether runtime type of the expression is a <a href="#subtyping">subtype</a> of the type given on the right-hand side operand and throws an exception otherwise. </span><span class="sentence">If the type on the right hand side is a <a href="#runtime-available-types">runtime-available</a> type without generic parameters, then this exception is thrown immediately when evaluating the expression, otherwise it is platform-dependent whether an exception is thrown at this point.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Even if the exception is not thrown when evaluating the cast expression, it is guaranteed to be thrown later when the value is used with any runtime-available type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The unsafe cast expression always has the same type as the type specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The form of cast expression employing the <code>as?</code> operator is called <em>a checked cast</em> expression This operator is very similar to the unsafe cast expression, but does not throw an exception, but returns <code>null</code> if the types don’t match. </span><span class="sentence">If the type specified on the right hand side of the expression is not <a href="#runtime-available-types">runtime-available</a>, then the check is not performed and <code>null</code> is never returned, leading to potential runtime errors later in the program execution. </span><span class="sentence">This situation should be reported with a compiler warning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The checked cast expression always has the <a href="#nullable-types">nullable</a> variant of the type specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>ascription expression</em> is a binary expression employing the ascription operator (<code>:</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator does not perform any actions at runtime and evaluates to the same value as its left hand operand. </span><span class="sentence">However, it does perform a compile-time check whether the current type of the expression is a <a href="#subtyping">subtype</a> of the type given on the right-hand side operand and generates a compiler error otherwise.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The ascription expression always has the same type as the type specified in right-hand side of the expression.</span></p>
</div>
<h4 id="todo-2">TODO()</h4>
<ul>
<li><span class="sentence">Smart casts!</span></li>
</ul>
<h3 id="prefix-expressions">Prefix expressions</h3>
<div id="grammar-rule-prefixUnaryExpression-pasted-26" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix-pasted-27" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator-pasted-28" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<h4 id="annotated-and-labeled-expression">Annotated and labeled expression</h4>
<div class="paragraph">
<p><span class="sentence">Any expression in Kotlin may be prefixed with any number of [annotations][Annotations] and [labels][Labels]. </span><span class="sentence">These do not change the value of the expression and can be used by external tools and platform-dependent features.</span></p>
</div>
<h4 id="prefix-increment-expression">Prefix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>++</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix increment expression must be an <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="prefix-decrement-expression">Prefix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>--</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a prefix decrement expression must be an <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="unary-minus-expression">Unary minus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary minus</em> expression is an expression employing the prefix form of operator <code>-</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>-</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryMinus()</code> where <code>unaryMinus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="unary-plus-expression">Unary plus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary plus</em> expression is an expression employing the prefix form of operator <code>+</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>+</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryPlus()</code> where <code>unaryPlus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="logical-not-expression">Logical not expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>logical not</em> expression is an expression employing the prefix operator <code>!</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>!</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.not()</code> where <code>not</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h3 id="postfix-operator-expressions">Postfix operator expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-29" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-30" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator-pasted-31" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<h4 id="postfix-increment-expression">Postfix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix increment</em> expression is an expression employing the postfix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>++</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb18"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb18-2" title="2">A = A.inc();</a>
<a class="sourceLine" id="cb18-3" title="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix increment expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of postfix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="postfix-decrement-expression">Postfix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix decrement</em> expression is an expression employing the postfix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>--</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb19-2" title="2">A = A.dec();</a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix decrement expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h3 id="not-null-assertion-expression">Not-null assertion expression</h3>
<div class="paragraph">
<p><span class="sentence">A <em>not-null assertion expression</em> is a postfix expression employing the use of operator <code>!!</code>. </span><span class="sentence">For expressions of nullabe types, this expression checks whether the value is equal to <code>null</code>, and if it is, throws a runtime exception. </span><span class="sentence">If it is not equal to <code>null</code>, it evaluates to the same value as its left-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Not-null assertion expressions have no effect on values of non-nullable types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of non-null assertion expression is the <a href="#nullable-types">non-nullable</a> variant of the type of its left-hand side expression. </span><span class="sentence">Note that this type may be non-denotable in Kotlin and as such, may be [approximated][Type approximation] in some situations involving [type inference][Type inference].</span></p>
</div>
<h3 id="indexing-expressions">Indexing expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-32" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-33" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix-pasted-34" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>indexing expression</em> is a suffix expression employing the use of several subexpressions <em>indices</em> between square brackets (<code>[</code> and <code>]</code>). </span><span class="sentence">At least one index must be provided.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>]</code> is exactly the same as <span class="math inline">\(A\)</span><code>.get(</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>)</code>, where <code>get</code> is a suitable <code>operator</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A correct indexing expression has the same type as the corresponding <code>get</code> expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Indexing expressions are [assignable][Assignable expressions]. </span><span class="sentence">For a corresponding assignment form, see [indexing assignment][Indexing assignment].</span></p>
</div>
<h3 id="call-and-property-access-expressions">Call and property access expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-35" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-36" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix-pasted-37" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix-pasted-38" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda-pasted-39" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments-pasted-40" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments-pasted-41" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection-pasted-42" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers-pasted-43" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator-pasted-44" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<h4 id="the-navigation-operators">The navigation operators</h4>
<div class="paragraph">
<p><span class="sentence">Expressions employing the navigation binary operators (<code>.</code>, <code>.?</code> or <code>::</code>) are all syntactically similar, but, in fact, may have very different syntactic meaning. </span><span class="sentence"><code>a.c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified type, property or object name. </span><span class="sentence">The left side of <code>.</code> must be a package name, while the right side corresponds to a declaration in that package. </span><span class="sentence">Note that qualification uses operator <code>.</code> only;</span></li>
<li><span class="sentence">A value property access. </span><span class="sentence">Here <code>a</code> is another value available in the current scope and <code>c</code> is the property name. </span><span class="sentence">If used with operator <code>::</code> this becomes a [property reference][Callable references]. </span><span class="sentence">The left-hand side expression may be a type name, which is similar to using the type’s companion object as the left hand side expression;</span></li>
<li><span class="sentence">A member function call if followed by the call suffix (arguments enclosed in parentheses). </span><span class="sentence">These expressions adhere to the <a href="#overload-resolution">overloading</a> rules. </span><span class="sentence">If used with operator <code>::</code>, but without the call suffix, this becomes a [function reference][Callable references].</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() + Identifiers</span></p>
</div>
</div>
<h3 id="function-literals">Function Literals</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin supports using functions as values. </span><span class="sentence">This includes, among other things, being able to use named functions (through [function references][Callable references]) as parts of expressions. </span><span class="sentence">Sometimes it does not make much sense to provide a separate function declaration, but rather define a function in-place, using <em>function literals</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two types of function literals in Kotlin: <em>lambda literals</em> and <em>anonymous function declarations</em>. </span><span class="sentence">Both of these provide a way of defining a function in-place, but have subtle differences.</span></p>
</div>
<h4 id="anonymous-function-declarations">Anonymous function declarations</h4>
<div id="grammar-rule-anonymousFunction-pasted-45" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-parametersWithOptionalType">parametersWithOptionalType</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Anonymous function declarations</em>, despite the name, are not actually declarations, but rather an expression that resembles a function declaration. </span><span class="sentence">They have syntax very similar to the function declaration syntax, but with a few differences:</span></p>
</div>
<ul>
<li><span class="sentence">Anonymous functions do not have a name (obviously);</span></li>
<li><span class="sentence">Anonymous functions may not have type parameters <span><span class="TODO">(TODO(): check!!!)</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence">Anonymous functions may not have default parameters <span><span class="TODO">(TODO(): check!!!)</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence">Anonymous functions may have variable argument parameters, but they are automatically decayed to non-variable argument parameters of array type <span><span class="TODO">(TODO(): how does this really work?)</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Anonymous function declaration may declare anonymous extension functions. </span><span class="sentence">The type of an anonymous function declaration is the function type constructed similarly to the corresponding [named function declaration][Function declarations].</span></p>
</div>
<h4 id="lambda-literals">Lambda literals</h4>
<div id="grammar-rule-lambdaLiteral-pasted-46" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)<br />
| (<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters-pasted-47" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter-pasted-48" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Lambda literals TODO()</span></p>
</div>
<h3 id="object-literals">Object literals</h3>
<div id="grammar-rule-objectLiteral-pasted-49" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Object literals are a way of defining anonymous objects in Kotlin. </span><span class="sentence">Anonymous objects are similar to regular objects, but they (obviously) have no name and thus can (only) be used as expressions. </span><span class="sentence">Anonymous objects, just like regular object declarations, can have at most one base class and many base interfaces declared in its delegation specifiers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between the regular object declaration and an anonymous object is its type. </span><span class="sentence">The type of an anonymous object is a special kind of type that is usable (and visible) only in the scope where it is declared. </span><span class="sentence">It is similar to a type that could be normally declared with a corresponding object declaration, but cannot be used outside the scope, leading to interesting effects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a value of this type escapes current scope:</span></p>
</div>
<ul>
<li><span class="sentence">If the type has only one declared supertype, it is implicitly downcasted to this declared supertype;</span></li>
<li><span class="sentence">If the type has several declared supertypes, there must be an explicit cast to any suitable type visible outside the scope, otherwise a compiler error is generated.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Please not that in this context “escaping” current scope is performed immediately if the corresponding value is declared as a global or classifier-scope property, as those are a part of package interface.</span></p>
</div>
<h3 id="this-expressions">This-expressions</h3>
<div id="grammar-rule-thisExpression-pasted-50" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">This-expressions are a special kind of expressions used to access available receivers in current scope. </span><span class="sentence">For more information about receivers, please refer to the <a href="#receivers">overloading section</a>. </span><span class="sentence">The basic form of this expression, denoted by <code>this</code> keyword, is used to access the current implicit receiver according to receiver overloading rules. </span><span class="sentence">In order to access other receivers, labeled <code>this</code> expressions are used. </span><span class="sentence">These may be any of the following:</span></p>
</div>
<ul>
<li><span class="sentence"><code>this@</code><span class="math inline">\(type\)</span> where <span class="math inline">\(type\)</span> is a name of any classifier that is currently being declared (that is, this this-expression is located inside its declaration’s inner scope) refers to the implicit object of the type being declared;</span></li>
<li><span class="sentence"><code>this@</code><span class="math inline">\(function\)</span> where <span class="math inline">\(function\)</span> is a name of a function currently being declared (that is, this this-expression is located inside the function body) refers to the implicit receiver object of this function (if it is an extension function) or is illegal and generates a compiler error.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Any other form of this-expression is illegal and generates a compiler error.</span></p>
</div>
<h3 id="super-forms">Super-forms</h3>
<div id="grammar-rule-superExpression-pasted-51" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Super form is a special kind of expression that can only be used as the receiver of a function or property access expression. </span><span class="sentence">Any usage of such an expression in any other context is prohibited.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Super forms are used in classifier declarations to access the method implementations from base classifier types without invoking overriding behaviour.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="jump-expressions">Jump expressions</h3>
<div id="grammar-rule-jumpExpression-pasted-52" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Jump expressions</em> are a group of expressions that redirect the order the program is evaluated to a different program point when evaluated. </span><span class="sentence">All these expressions have several things in common:</span></p>
</div>
<ul>
<li><span class="sentence">They all have type <code>kotlin.Nothing</code>, effectively meaning that they never produce any runtime value;</span></li>
<li><span class="sentence">Any code that unconditionally follows such expression is never evaluated.</span></li>
</ul>
<h4 id="throw-expressions">Throw expressions</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): [Exceptions] go first</span></p>
</div>
</div>
<h4 id="return-expressions">Return expressions</h4>
<div class="paragraph">
<p><span class="sentence">A <em>return expression</em>, when used inside a function body, immediately stops evaluating the function and returns to the point where this function was called, making the function call expression evaluate to the value specified in this return expression (if any). </span><span class="sentence">A return expression with no value implicitly returns the <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of return expression: a simple return expression, specified using the <code>return</code> keyword, returning from the innermost <a href="#function-declaration">function declaration</a> (or [anonymous function expression][Anonymous function expression]) and the extended return expression, using the form <code>return@</code><span class="math inline">\(Context\)</span> where <span class="math inline">\(Context\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">The name of one of the enclosing function declarations to refer to this function. </span><span class="sentence">If several declarations match one name, an ambiguity compiler error is generated;</span></li>
<li><span class="sentence">If current expression is inside a lambda expression body, the name of the function using this lambda expression as a trailing lambda <span><span class="TODO">(TODO: Wut?)</span><span class="TODO-marker">*</span></span> parameter may be used to refer to the lambda literal itself.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If returning from the referred function is allowed in current context, the return is performed as usual. </span><span class="sentence">If returning from the referred function is not allowed, a compiler error is generated.</span></p>
</div>
<h4 id="continue-expression">Continue expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>continue expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the start of the next loop iteration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of continue expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple continue expression, specified using the <code>continue</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">An extended continue expression, denoted <code>continue@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): as a matter of fact, <code>continue</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
</div>
<h4 id="break-expression">Break expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>break expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the next program point after the loop.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of break expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple break expression, specified using the <code>break</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">An extended break expression, denoted <code>break@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): as a matter of fact, <code>break</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
</div>
<h3 id="operator-expressions">Operator expressions</h3>
<h4 id="spread-operator">Spread operator</h4>
<h3 id="safe-call-expression">Safe call expression</h3>
<h3 id="type-check-expression">Type check expression</h3>
<h2 id="todos">TODOS()</h2>
<ul>
<li><span class="sentence">Overloadable operators &amp;&amp; operator expansion</span></li>
<li><span class="sentence">Smart casts vs compile-time types</span></li>
<li><div class="paragraph">
<p><span class="sentence">What does <code>decaying</code> for vararg actually mean?</span></p>
</div></li>
<li><span class="sentence">!!! </span><span class="sentence">object literal typing looks just like restricted union types. </span><span class="sentence">Are there any traps hidden here?</span></li>
<li><span class="sentence">The whole last paragraph in <a href="#object-literals-1">Object literals</a> is pretty shady</span></li>
<li><div class="paragraph">
<p><span class="sentence">What does it mean for returning to be disallowed? </span><span class="sentence">## Overloadable operators</span></p>
</div></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(rename this and all the refs to smth)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Some syntax forms in Kotlin are defined <em>by convention</em>, meaning that their semantics are defined through syntactic expansion of current syntax form into another syntax form. </span><span class="sentence">The expansion of a particular syntax form is a different piece of code usually defined in the terms of operator functions. </span><span class="sentence">Operator functions are function that are <a href="#function-declaration">declared</a> with a special keyword <code>operator</code> and are not different from normal functions when called normally, but allow themselves to be employed by syntactic expansion. </span><span class="sentence">Different platforms may add other criteria on whether a function may be considered a suitable candidate for operator convention.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Particular cases of definition by convention include:</span></p>
</div>
<ul>
<li><span class="sentence">Arithmetic and comparison operators;</span></li>
<li><span class="sentence">Operator-form <a href="#assignments">assignments</a>;</span></li>
<li><span class="sentence">[For-loop statements][For-loop statement];</span></li>
<li><span class="sentence"><a href="#delegated-property-declaration">Delegated properties</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">There are several common points among all the syntax forms defined using this mechanism:</span></p>
</div>
<ul>
<li><span class="sentence">The expansions are hygenic: if they seemingly introduce new identifiers that were not present in original syntax, all such identifiers are not accessible outside the expansion and cannot clash with any other declarations in the program;</span></li>
<li><span class="sentence">The expressions captured by an expansion are using call-by-need evaluation strategy, meaning that they are evaluated only once during first usage specified in the expansion even if the expansion itself has more than one usage of such an expression;</span></li>
<li><span class="sentence">An expansion may lead to another expansion, following the same rules;</span></li>
<li><span class="sentence">All the new call expressions that are produced by expansion are only allowed to use operator functions.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For example, take the following declarations:</span></p>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb20-2" title="2">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">inc</span>(): <span class="dt">A</span> { ... }</a>
<a class="sourceLine" id="cb20-3" title="3">}</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="kw">object</span> B {</a>
<a class="sourceLine" id="cb20-6" title="6">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span>(<span class="va">i</span>: <span class="dt">Int</span>): <span class="dt">A</span> { ... }</a>
<a class="sourceLine" id="cb20-7" title="7">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">set</span>(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">value</span>: <span class="dt">A</span>) { ... }</a>
<a class="sourceLine" id="cb20-8" title="8">}</a>
<a class="sourceLine" id="cb20-9" title="9"></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="kw">object</span> C {</a>
<a class="sourceLine" id="cb20-11" title="11">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span>(<span class="va">i</span>: <span class="dt">Int</span>): <span class="dt">B</span> { ... }</a>
<a class="sourceLine" id="cb20-12" title="12">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The expression <code>C[0][0]++</code> is expanded (see the <a href="#expressions-1">Expressions</a> section for details) using the following rules:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">First, the <a href="#postfix-increment-expression-1">increment operator</a> is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb21"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb21-1" title="1">C[<span class="dv">0</span>][<span class="dv">0</span>] = C[<span class="dv">0</span>][<span class="dv">0</span>].inc()</a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">Second, the <a href="#assignments">assigment</a> to an indexing expression (produced by the previous expansion) is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb22"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb22-1" title="1">C[<span class="dv">0</span>].<span class="kw">set</span>(C[<span class="dv">0</span>].<span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">Third, the [indexing expression][Indexing expression] is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb23"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb23-1" title="1">C.<span class="kw">get</span>(<span class="dv">0</span>).<span class="kw">set</span>(C.<span class="kw">get</span>(<span class="dv">0</span>).<span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Although the resulting expression contains several invocations of the subexpression <code>C.get(0)</code>, it is evaluated only once, making this code roughly equivalent to:</span></p>
</div>
<div class="sourceCode" id="cb24"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">val</span> $<span class="va">tmp</span> = C.<span class="kw">get</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb24-2" title="2">$tmp.<span class="kw">set</span>($tmp.<span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="packages-and-imports">Packages and imports</h2>
<div class="paragraph">
<p><span class="sentence">Any Kotlin project is structured into <strong>packages</strong>. </span><span class="sentence">A package may contain one or more Kotlin files and each file is related to the corresponding package using the <em>package header</em>. </span><span class="sentence">A file may contain only one (or zero) package headers, meaning that each file belongs to exactly one package.</span></p>
</div>
<div id="grammar-rule-packageHeader-pasted-53" class="grammar-rule">
<dl>
<dt><strong><em>packageHeader</em>:</strong></dt>
<dd><span class="sentence">[<code>'package'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>]]</span>
</dd>
</dl>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an absence of a package header in a file means that is belongs to the special <em>root package</em></span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Packages are different from <a href="#modules">modules</a>. </span><span class="sentence">A module may contain many packages, while a single package can be spread across several modules.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The name of a package is a dot (<code>.</code>)-separated sequence of identifiers, introducing a package hierarchy. </span><span class="sentence">Unlike Java and some other languages, Kotlin does not restrict the package hierarchy to correspond directly to the folder structure of the project.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that the hierarchy itself is only notational, not affecting the code in any way. </span><span class="sentence">It is strongly recommended, however, that the folder structure of the project does correspond to the package hierarchy.</span></p>
</div>
</blockquote>
<h3 id="importing">Importing</h3>
<div class="paragraph">
<p><span class="sentence">Program entities declared in one package may be freely used in any file in the same package with the only restriction being <a href="#modules">module</a> boundaries. </span><span class="sentence">In order to use an entity from a file belonging to a different package, the programmer must use <em>import directives</em>.</span></p>
</div>
<div id="grammar-rule-importList-pasted-54" class="grammar-rule">
<dl>
<dt><strong><em>importList</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-importHeader">importHeader</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importHeader-pasted-55" class="grammar-rule">
<dl>
<dt><strong><em>importHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'import'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [(<code>'.'</code> <code>'*'</code>) | <em><a href="#grammar-rule-importAlias">importAlias</a></em>] [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importAlias-pasted-56" class="grammar-rule">
<dl>
<dt><strong><em>importAlias</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An import directive contains dot-separated <em>path</em> to an entity, as well as the name of the entity itself (the last argument of the navigation dot operator). </span><span class="sentence">A path may include not only the package the import is importing from, but also an object or a type (referring to companion object of this type). </span><span class="sentence">Any named declaration within that scope (that is, top-level scope of all files in the package or, in the object case, the object declararion scope) may be imported using their names. </span><span class="sentence">There are two special kinds of imports: star-imports ending in an asterisk (<code>*</code>) and renaming imports employing the use of <code>as</code> operator. </span><span class="sentence">Star-imports import all the named entities inside the corresponding scope, but have weaker priority during <a href="#overload-resolution">resolution</a> of functions and properties. </span><span class="sentence">Renaming imports work just as regular imports, but introduce the entity into current file with a name different from the name it has at declaration site.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Imports are file-based, meaning that if an entity is introduced into file A.kt belonging to package <code>kotlinx.foo</code>, it does not introduce this entity to all other files belonging to <code>kotlinx.foo</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are some packages that have all their entities <em>implicitly imported</em> into any Kotlin file, meaning one can access this entity without explicitly using import directives. </span><span class="sentence">One may, however, import this entities explicitly if they choose to. </span><span class="sentence">These are the following packages of the standard library:</span></p>
</div>
<ul>
<li><span class="sentence"><code>kotlin</code></span></li>
<li><span class="sentence"><code>kotlin.annotation</code></span></li>
<li><span class="sentence"><code>kotlin.collections</code></span></li>
<li><span class="sentence"><code>kotlin.comparisons</code></span></li>
<li><span class="sentence"><code>kotlin.io</code></span></li>
<li><span class="sentence"><code>kotlin.ranges</code></span></li>
<li><span class="sentence"><code>kotlin.sequences</code></span></li>
<li><span class="sentence"><code>kotlin.text</code></span></li>
<li><span class="sentence"><code>kotlin.math</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Platform implementations may introduce additional implicitly imported packages, for example, adding standard platform functionality into Kotlin code.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an example of this would be <code>java.lang</code> package implicitly imported on the jvm platform</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Importing certain entities may be disallowed by their <a href="#visibility">visibility modifiers</a>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clarify all this)</span></p>
</div>
</div>
<h3 id="modules">Modules</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Here be The dragons)</span></p>
</div>
</div>
<h2 id="overload-resolution">Overload resolution</h2>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>function overloading</em>, that is, the ability for several functions of the same name to coexist in the same scope, with the compiler picking the most suitable one when such a function is called. </span><span class="sentence">This section describes this mechanism in detail.</span></p>
</div>
<h3 id="intro">Intro</h3>
<div class="paragraph">
<p><span class="sentence">Unlike other object-oriented languages, Kotlin does not only have object methods, but also top-level functions, local functions, extension functions and function-like values, which complicates the overloading process quite a lot. </span><span class="sentence">Kotlin also has infix functions, operator and property overloading which all work in a similar but rather different way.</span></p>
</div>
<h3 id="receivers">Receivers</h3>
<div class="paragraph">
<p><span class="sentence">Every function or property that is defined as a method or an extension has one or more special parameters called <em>receiver</em> parameters. </span><span class="sentence">When calling such a callable using navigation operators (<code>.</code> or <code>?.</code>) the left hand side parameter is called an <em>explicit receiver</em> or this particular call. </span><span class="sentence">In addition to the explicit receiver, each such call may indirectly access zero or more <em>implicit receivers</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit receivers are available in some syntactic scope according to the following rules:</span></p>
</div>
<ul>
<li><span class="sentence">All receivers available in outer scope are also available in all nested scopes;</span></li>
<li><span class="sentence">In the scope of a classifier definition, the following receivers are available:</span>
<ul>
<li><span class="sentence">The implicit <code>this</code> object of the defined type;</span></li>
<li><span class="sentence">The companion object (if one exist) of this class;</span></li>
<li><span class="sentence">The companion objects (if any exists) of all its superclasses;</span></li>
</ul></li>
<li><span class="sentence">If a function or a property is an extension, the <code>this</code> parameter of the extension is also available inside the extension definition;</span></li>
<li><span class="sentence">The scope of a lambda expression if it has an extension function type contains the <code>this</code> argument of this lambda expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The available receivers are prioritized in the following way:</span></p>
</div>
<ul>
<li><span class="sentence">The receivers provided in most inner scope have higher priority;</span></li>
<li><span class="sentence">In a classifier body, the implicit <code>this</code> reference has higher priority than the companion object receiver;</span></li>
<li><span class="sentence">Current class companion object receiver has higher priority than any of the base classes.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The implicit receiver having the highest priority is also called the <em>default implicit receiver</em>. </span><span class="sentence">The default implicit receiver is available in the scope as <code>this</code>. </span><span class="sentence">Other available receivers may be accessed using <a href="#this-expressions-1">this-expressions</a> of different form.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If an implicit receiver is available in some scope, it may be used to call functions implicitely without using the navigation operator.</span></p>
</div>
<h3 id="the-forms-of-call-expression">The forms of call-expression</h3>
<div class="paragraph">
<p><span class="sentence">Any function in Kotlin may be called in several different ways:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified call: <code>package.foo()</code>;</span></li>
<li><span class="sentence">A call with an explicit receiver: <code>a.foo()</code>;</span></li>
<li><span class="sentence">An infix function call: <code>a foo b</code>;</span></li>
<li><span class="sentence">An overloaded operator call: <code>a + b</code>;</span></li>
<li><span class="sentence">A call without an explicit receiver: <code>foo()</code>;</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For each of these cases, a compiler should first pick a number of <em>overload candidates</em> which is a set of callables that may be the intended callees and then <em>choose the most specific function</em> to call based on the types of the function and the call operands. </span><span class="sentence">Please note that the overload candidates are picked <strong>before</strong> the most specific function is chosen.</span></p>
</div>
<h3 id="callables-and-invoke-convention">Callables and invoke convention</h3>
<div class="paragraph">
<p><span class="sentence">A <em>callable</em> <span class="math inline">\(X\)</span> for the purpose of this document is one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">A function named <span class="math inline">\(X\)</span> at declaration site;</span></li>
<li><span class="sentence">A property named <span class="math inline">\(X\)</span> at declaration site with an operator function called <code>invoke</code> that is available as member or extension in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In the latter case a call <span class="math inline">\(X\)</span><code>(</code><span class="math inline">\(Y_0\)</span><code>,</code><span class="math inline">\(Y_1\)</span><code>,...,</code><span class="math inline">\(Y_N\)</span><code>)</code> is an overloadable operator which is expanded to <span class="math inline">\(X\)</span><code>.invoke(</code><span class="math inline">\(Y_0\)</span><code>,</code><span class="math inline">\(Y_1\)</span><code>,...,</code><span class="math inline">\(Y_N\)</span><code>)</code>. </span><span class="sentence">The call may contain type parameters, named parameters, variable argument parameter expansion and trailing lambda parameters, all of which are forwarded as-is to the corresponding <code>invoke</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>member callable</em> is either a member function or a member property with member operator <code>invoke</code>. </span><span class="sentence">An <em>extension callable</em> is either an extension function, a member property with an extension operator <code>invoke</code> or an extension property with an extension operator <code>invoke</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When calculating overload resolution sets, member callables produce the following separate sets (ordered by priority, bigger priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Member functions;</span></li>
<li><span class="sentence">Member properties.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Extension callables produce the following separate sets (ordered by priority, bigger priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Extension functions;</span></li>
<li><span class="sentence">Member properties with extension invoke;</span></li>
<li><span class="sentence">Extension properties with member invoke;</span></li>
<li><span class="sentence">Extension properties with extension invoke.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This division is more granular than all other means of dividing resolution candidates into sets, meaning that it is performed the last.</span></p>
</div>
<h3 id="overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</h3>
<div class="paragraph">
<p><span class="sentence">If the callable name is fully-qualified (that is, contains full package path), then the overloading candidate set simply contains all the callables with the same name in the same package. </span><span class="sentence">As a package name may never clash with any other declared entity, after performing division of callables, these are the only sets available.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb25"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">package</span> <span class="im">a.b.c</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>) {}</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Double</span>) {}</a>
<a class="sourceLine" id="cb25-5" title="5"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">List</span>&lt;<span class="va">Char</span>&gt;) {}</a>
<a class="sourceLine" id="cb25-6" title="6"><span class="kw">val</span> <span class="va">foo</span> = {}</a>
<a class="sourceLine" id="cb25-7" title="7">. . .</a>
<a class="sourceLine" id="cb25-8" title="8">a.b.c.foo()</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here the overload candidates set contains all the callables named <code>foo</code> from the package <code>a.b.c</code>.</span></p>
</div>
<h3 id="a-call-with-an-explicit-receiver">A call with an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">If a function call is done using a navigation operator (<code>.</code> or <code>?.</code>, not to be confused with a <a href="#overload-resolution-for-a-fully-qualified-call">fully-qualified call</a>), then the left hand side operand of this operator is the explicit receiver of this call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A call of callable <code>f</code> with explicit receiver <code>e</code> is correct if one (or more) of the following holds:</span></p>
</div>
<ol type="1">
<li><span class="sentence"><code>f</code> is a member callable of the classifier type of <code>e</code> or any of its supertypes;</span></li>
<li><span class="sentence"><code>f</code> is an extension callable for the classifier type of <code>e</code> or any of its supertypes, including local and imported extensions.</span></li>
</ol>
<div class="paragraph">
<p><span class="sentence">Please note that callables functions for case 2 not only include top-level declared extension callables, but also extension callables available in any of the available implicit receivers. </span><span class="sentence">For example, if a class contains a member extension function for another class and an object of this class is available as an implicit receiver, this extension function may be used for the call if it has a suitable type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Then for a callable named <code>f</code> the following sets are looked upon (in this order):</span></p>
</div>
<ol type="1">
<li><span class="sentence">The sets of non-extension member callables named <code>f</code> of the receiver type;</span></li>
<li><span class="sentence">The sets of local extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type, in all declaration scopes containing the current declaration scope, ordered by the size of the scope (smallest first), excluding the package scope;</span></li>
<li><span class="sentence">The sets of explicitly imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type;</span></li>
<li><span class="sentence">The sets of extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type, declared in the current package;</span></li>
<li><span class="sentence">The sets of star-imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type;</span></li>
<li><span class="sentence">The sets of implicitly imported extension callables named <code>f</code> whose receiver type conforms to the explicit receiver type.</span></li>
</ol>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() : all this X-imported things need to be defined somewhere</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">When looked upon these sets, the first set that contains <strong>any</strong> callable with the corresponding name and conforming types is picked. </span><span class="sentence">This means, among other things, that if the set constructed during step 2 contains a more suitable candidate function, but the set constructed in step 1 is not empty, the function from set 1 is picked even it is a less suitable candidate.</span></p>
</div>
<h3 id="infix-function-calls">Infix function calls</h3>
<div class="paragraph">
<p><span class="sentence">In reality, infix function calls are a special case of function calls with an explicit receiver using the left hand operand as the receiver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There is a slight difference though: during the overload candidate set selection the only functions considered for inclusion are the ones with the <code>infix</code> modifier. </span><span class="sentence">All other functions (and all properties) are not even considered for inclusion. </span><span class="sentence">Aside from this small difference, candidates are selected using the same rules as for normal calls with explicit receiver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions deemed valid candidates for inclusion as infix functions.</span></p>
</div>
<h3 id="operator-calls">Operator calls</h3>
<div class="paragraph">
<p><span class="sentence">According to TODO(), some operator expressions in Kotlin can be overloaded using specially-named functions. </span><span class="sentence">This makes operator expressions semantically equivalent to function calls with explicit receiver, where the receiver expression is selected according to operator form (see TODO()). </span><span class="sentence">The selection of an exact function that is called in each particular case is based on the same rules as for function calls with explicit receivers, the only difference being that only functions with <code>operator</code> modifier are considered for inclusion when building overload candidate sets. </span><span class="sentence">Properties are never considered for inclusion for operator calls.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions deemed valid candidates for inclusion as operator functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Please note that this is valid not only for dedicated operator expressions, but also for <code>for</code>-loops iteration process and property delegates.</span></p>
</div>
<h3 id="a-call-without-an-explicit-receiver">A call without an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">A call that is performed with unqualified function name and without using a navigation operator is a call without an explicit receiver. </span><span class="sentence">It may in fact have one or more implicit receivers or be a top-level function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As with function calls with explicit receiver, a valid implementation should first pick a valid overload candidate set and then search this set for the <em>most specific function</em> to match the call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Than for a function named <code>f</code> the following sets are looked upon (in this order):</span></p>
</div>
<ol type="1">
<li><span class="sentence">The sets of local non-extension functions named <code>f</code> available in current scope, in order of the scope they are declared in, smallest scope first;</span></li>
<li><span class="sentence">The overload candidate sets for each implicit receiver and <code>f</code>, calculated as if it was the explicit receiver, in the order of the receiver priority (see previous section);</span></li>
<li><span class="sentence">Top-level non-extension functions named <code>f</code>, in this order:</span>
<ol type="a">
<li><span class="sentence">Functions explicitely imported into current file;</span></li>
<li><span class="sentence">Functions declared in the same package;</span></li>
<li><span class="sentence">Functions star-imported into current file;</span></li>
<li><span class="sentence">Implicitly imported functions (kotlin standard library or platform-specific);</span></li>
</ol></li>
</ol>
<div class="paragraph">
<p><span class="sentence">When looked upon these sets, the first set that contains <strong>any</strong> function with the corresponding name and conforming types is picked.</span></p>
</div>
<h3 id="calls-with-named-parameters">Calls with named parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most of the call forms listed above may use named parameters in call expressions, for example, <code>f(a = 2)</code>, where <code>a</code> is a named formal parameter specified in the declaration of <code>f</code>. </span><span class="sentence">Such calls are treated the same way as normal calls, but the overload resolution sets are filtered to only contain callables that actually have formal parameters for all the corresponding names.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">For properties called through invoke-convention, the named parameters must be present in the declaration of the <code>invoke</code> operator function</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike positional arguments, named arguments specify directly which of the formal parameters of the function the argument corresponds to. </span><span class="sentence">The matching of formal parameters and arguments is performed separately for each function candidate and while the number of defaults ( see <a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">the MSC definition process</a>) does affect resolution process, the fact that some argument was mapped using named or positional argument does not affect is in any way.</span></p>
</div>
<h3 id="calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</h3>
<div class="paragraph">
<p><span class="sentence">Most of the call forms listed above may have a single lambda expression presented outside of the parentheses or replacing them (see [Call expression]). </span><span class="sentence">This has no effect on overload resolution process, aside from argument reordering that may happen due to variable argument parameters or parameters with defaults between the arguments.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This means that calls <code>f(1,2){ g() }</code> and <code>f(1,2, body = { g() })</code> are completely equivalent from the overload resolution standpoint, assuming that <code>body</code> is the name of the last formal parameter of <code>f</code></span></p>
</div>
</blockquote>
<h3 id="calls-with-specified-type-parameters">Calls with specified type parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most of the call forms listed above may have a list of type arguments that precedes the list of value arguments of the call. </span><span class="sentence">In this case, all the potential overload sets only include callables that contain an exactly same number of formal type arguments at declaration site. </span><span class="sentence">In the case of property callable through <code>invoke</code> convention, the type parameters must be present at the <code>invoke</code> operator function declaration.</span></p>
</div>
<h3 id="determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</h3>
<h4 id="rationale">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">A function is <em>applicable</em> for a specific call if and only if the function type parameters may be assigned the values of the arguments specified in the call and all the type constraints of the function still hold.</span></p>
</div>
<h4 id="description">Description</h4>
<div class="paragraph">
<p><span class="sentence">Determining function applicability for a specific call is a [type constraint][Type constraints] problem. </span><span class="sentence">First, for every argument of the function supplied in the call, the type inference is performed. </span><span class="sentence">This excludes lambda arguments, as the inference of the specific type for them needs the results of overloading to finish.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">After that the following constraint system is built:</span></p>
</div>
<ul>
<li><span class="sentence">For every parameter of the call (excluding lambda parameters) inferred to have type <span class="math inline">\(T_i\)</span>, corresponding to function argument of type <span class="math inline">\(U_j\)</span>, a constraint <span class="math inline">\(T_i &lt;: U_j\)</span> is constructed;</span></li>
<li><span class="sentence">All the declaration-site type constraints for the function are also added to the system;</span></li>
<li><span class="sentence">For each lambda parameter with the number of lambda arguments known to be <span class="math inline">\(K\)</span>, a constraint and corresponding to function argument of type <span class="math inline">\(U_m\)</span>, an artificial constraint is added in the form <span class="math inline">\(R(L_1,...,L_K) &lt;: U_m\)</span>, where <span class="math inline">\(R, L_1, ..., L_K\)</span> are all fresh variables;</span></li>
<li><span class="sentence">For each lambda parameter with the number of lambda arguments not known (that is, being equal to 0 or 1), an artificial constraint is added in the form <span class="math inline">\(kotlin.Function &lt;: U_m\)</span>, where <span class="math inline">\(kotlin.Function\)</span> is the common base of all functional types; TODO(): what’s the name???</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If this constraint system is sound, the function is applicable for the call. </span><span class="sentence">Only applicable functions are considered for the next step: finding the most specific overload candidate from the candidate set.</span></p>
</div>
<h3 id="choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</h3>
<h4 id="rationale-1">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">The main rationale behind choosing the most specific function from a candidate set is that the function chosen could be easily forwarded to by all the other functions in the set, while the reverse is not true. </span><span class="sentence">If there are several functions with this property, none of them is the most specific and an ambiguity error should be reported by the compiler.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Let’s look at an example with two functions:</span></p>
</div>
<div class="sourceCode" id="cb26"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {}        <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {} <span class="co">// (2)</span></a>
<a class="sourceLine" id="cb26-3" title="3">...</a>
<a class="sourceLine" id="cb26-4" title="4">f(<span class="dv">2</span>, <span class="st">&quot;Hello&quot;</span>)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here both functions are applicable for the call, but also function (1) could easily call function (2) by forwarding both arguments into it, but the reverse is impossible. </span><span class="sentence">As a result, function (1) is more specific of the two. </span><span class="sentence">Let’s rename the functions to make it more clear:</span></p>
</div>
<div class="sourceCode" id="cb27"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">fun</span> <span class="fu">f1</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {</a>
<a class="sourceLine" id="cb27-2" title="2">    f2(arg, arg2) <span class="co">// perfectly valid</span></a>
<a class="sourceLine" id="cb27-3" title="3">}</a>
<a class="sourceLine" id="cb27-4" title="4"><span class="kw">fun</span> <span class="fu">f2</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {</a>
<a class="sourceLine" id="cb27-5" title="5">    f1(arg, arg2) <span class="co">// invalid: function f1 is not appicable</span></a>
<a class="sourceLine" id="cb27-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The rest of this section will try to clarify this mechanism a little more.</span></p>
</div>
<h4 id="description-1">Description</h4>
<div class="paragraph">
<p><span class="sentence">When an overload resolution set is picked up and contains more than one callable, the next step is to find the most appropriate candidate from these callables.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Firts, the appicable set is divided into two sub-sets: the callables that employ type parameters (generic callables) and the callables that don’t (non-generic callables). </span><span class="sentence">If there are any non-generic applicable candidates, the choise is limited only to non-generic subset. </span><span class="sentence">Otherwise, all canidates (of generic callables) is considered.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This process employs the usage of [type constraint][Type constraints] system of Kotlin, similar to the process of <a href="#determining-function-applicability-for-a-specific-call">determining function applicability</a>. </span><span class="sentence">For every two members of the candidate set (let’s call them <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span>), the following constraint system is constructed and solved:</span></p>
</div>
<ul>
<li><span class="sentence">For every non-default argument of the call the corresponding value parameters’ types <span class="math inline">\(X_1, X_2, X_3 ... X_N\)</span> of <span class="math inline">\(F_1\)</span> and value parameters’ types <span class="math inline">\(Y_1, Y_2, Y_3 ... Y_N\)</span> of <span class="math inline">\(F_2\)</span> a type constraint <span class="math inline">\(X_K &lt;: Y_K\)</span> is built. </span><span class="sentence">During construction of these constraints, all the type parameters of <span class="math inline">\(F_1\)</span> are considered bound and all the type parameters of <span class="math inline">\(F_2\)</span> are considered free;</span></li>
<li><span class="sentence">All the declaration-site type constraints of <span class="math inline">\(X_1, X_2, X_3 ... X_N\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3 ... Y_N\)</span> are also added to the system.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If this constraint system is sound, it means that <span class="math inline">\(F_1\)</span> is equally or more applicable as an overload candidate. </span><span class="sentence">After that the check is repeated with <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span> swapped. </span><span class="sentence">If <span class="math inline">\(F_1\)</span> is equally or more applicable than <span class="math inline">\(F_2\)</span> and <span class="math inline">\(F_2\)</span> is equally or more applicable than <span class="math inline">\(F_1\)</span>, this means that the two callables are equally applicable and an additional decision procedure needs to be invoked.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All the members of the overload candidate set are sorted according to the criteria of applicability, determining the most applicable callable. </span><span class="sentence">If there are several callables which are both more applicable than other candidates and equally applicable to each other, an additional step is performed:</span></p>
</div>
<ul>
<li><span class="sentence">For each candidate, the number of default parameters not specified in the call is counted;</span></li>
<li><span class="sentence">The candidate with the least default parameters is a more specific candidate;</span></li>
<li><span class="sentence">If the number of defaulted parameters is equal for several candidates, the candidate having any variable-argument parameters is less specific than any candidate without them.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If, even after this additional step, there are several candidates that are equally applicable for the call, there is an <strong>overload ambiguity</strong> that must be reported as a compiler error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">NOTE: Please note that, unlike the applicability test, the candidate comparison constraint system is <strong>not</strong> based on the actuall call, meaning that when comparing two candidates, only constraints visible at declaration site apply.</span></p>
</div>
</blockquote>
<h3 id="about-type-inference">About type inference</h3>
<div class="paragraph">
<p><span class="sentence">[Type inference][Type inference] in Kotlin is a pretty complicated process, which is performed after resolving all the overload candidates. </span><span class="sentence">Due to the complexity of the process, type inference may not affect the way overload resolution candidate is picked up.</span></p>
</div>
<h4 id="todo-3">TODO:</h4>
<ul>
<li><span class="sentence">Properties business</span></li>
<li><span class="sentence">Function types (type system section???)</span></li>
<li><span class="sentence">Definition of “applicable function”</span></li>
<li><span class="sentence">Definition of “type parameter level”</span></li>
<li><span class="sentence">Calls with named parameters <code>f(x = 2)</code></span></li>
<li><span class="sentence">Calls with trailing lambda without parameter type</span>
<ul>
<li><span class="sentence">Lambdas with parameter types seem to be covered, <strong>nope, they are not</strong></span></li>
</ul></li>
<li><span class="sentence">Calls with specified type parameters <code>f&lt;Double&gt;(3)</code> ## Control- and data-flow analysis</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() ## Kotlin type constraints</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Some complex tasks that need to be solved when compiling Kotlin code are formulated best using <em>constraint systems</em> on Kotlin types. </span><span class="sentence">These are solved using constraint solvers.</span></p>
</div>
<h3 id="type-constraint-definition">Type constraint definition</h3>
<div class="paragraph">
<p><span class="sentence">A <em>type constraint</em> in general is an inequation of the following form: <span class="math inline">\(T &lt;: U\)</span> where <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> are Kotlin types (see <a href="#type-system">type system</a>). </span><span class="sentence">It is important, however, that Kotlin has parameterized types and type parameters of <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> (or type parameters of their parameters, or <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> themselves) may be <em>type variables</em>, that are unknown types that may be substituted by any other type in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Please note that, in general, type variables of the constraint system are not the same as type parameters of a type or a callable. </span><span class="sentence">Some type parameters may be <em>bound</em> in the constraint system, meaning that, although they are not known yet in Kotlin code, they are not type variables and are not to be substituted.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When such an ambiguity arises, we will use the notation <span class="math inline">\(T_i\)</span> for a type variable and <span class="math inline">\(\tilde{T_i}\)</span> for a bound type parameter. </span><span class="sentence">The main difference between bound parameters and concrete types is that different concrete types may not be equal, but a bound parameter may be equal to another bound parameter or a concrete type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Several examples of valid type constraints:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: \mathtt{List}\left&lt;\mathtt{List}\left&lt;\mathtt{Int}\right&gt;\right&gt;\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\widetilde{X} &lt;: Y\)</span></span></li>
</ul>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Every constraint system has implicit constraints <span class="math inline">\(\mathtt{Any} &lt;: T_j\)</span> and <span class="math inline">\(T_j &lt;: \mathtt{Nothing?}\)</span> for every type <span class="math inline">\(T_j\)</span> mentioned in constraint, including type variables.</span></p>
</div>
<h3 id="type-constraint-solving">Type constraint solving</h3>
<div class="paragraph">
<p><span class="sentence">There are two tasks that a type constraint solver may perform: checking constraint system for soundness and solving the system, e.g. inferring values for all the type variables that have themselves no type variables in them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Checking a constraint system for soundness can be viewed as a simpler case of solving a constraint, as if there is a solution, than the system is sound. </span><span class="sentence">It is, however, a much simpler task with only two possible outcomes. </span><span class="sentence">Solving a constraint system, on the other hand, may have several different results as there may be several valid solutions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Constraint examples that are sound yet no relevant solutions exist:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(X &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;X\right&gt; &lt;: \mathtt{Collection}\left&lt;X\right&gt;\)</span></span></li>
</ul>
</blockquote>
<h4 id="checking-constraint-system-soundness">Checking constraint system soundness</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO?</span></p>
</div>
</div>
<h4 id="finding-optimal-solution">Finding optimal solution</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO? </span><span class="sentence">## Type inference</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin has a concept of <em>type inference</em> for compile-time type information, meaning that some type information in the code may be omitted, to be inferred by the compiler. </span><span class="sentence">Type inference is a [type constraint][Kotlin type constraints] problem, solved by the type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two kinds of type inference supported by kotlin:</span></p>
</div>
<ul>
<li><span class="sentence">Local type inference, inferring types of expressions locally, in statement scope;</span></li>
<li><span class="sentence">Function signature type inference, inferring types for function return values and/or parameters.</span></li>
</ul>
<h3 id="smart-casts">Smart casts</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin introduces a limited form of flow-dependent typing called <em>smart casting</em>. </span><span class="sentence">Flow-dependent typing means that some statements in the program may introduce changes to the compile-time types of properties. </span><span class="sentence">This allows to avoid unnecessary casting of these values in cases where the runtime types are guaranteed to conform to expected compile-time types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casting is dependent on the <em>smart cast conditions</em> that are boolean predicates about program values. </span><span class="sentence">If some condition involving a program value <em>dominates</em> some program scope, the type of this value is mutated inside that scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two kinds of smart cast conditions: nullity conditions and type conditions. </span><span class="sentence">Nullity conditions signify that some value is not nullable, e.g. it’s value is guaranteed to not be <code>null</code>. </span><span class="sentence">Type conditions signify that some value’s runtime type conforms to a constraint of <span class="math inline">\(RT &lt;: T\)</span> where <span class="math inline">\(T\)</span> is the assumed type and <span class="math inline">\(RT\)</span> is the runtime type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Nullity conditions may be viewed as a subcase of type conditions with assumed type <code>kotlin.Any</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">There are also negated forms of both conditions that do not affect the typing in any way, but may be negated again to introduce non-negated forms of the same conditions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The actual compile type of a value that is subject of smart casting (see below) for any purpose (including, but not limited to, function overloading and further type inference of other values) if it is dominated by a smart casting condition, is, for every condition:</span></p>
</div>
<ul>
<li><span class="sentence">If the condition is a nullability condition, the intersection of the type it had before (including the results of smart casting performed for other conditions) and type <code>kotlin.Any</code>;</span></li>
<li><span class="sentence">If the condition is a type condition, the intersection of the type it had before (including the results of smart casting performed for other conditions) and the assumed type of the condition.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The following values are subject to smart casting:</span></p>
</div>
<ul>
<li><span class="sentence">Immutable local or classifier-scope properties without delegation or custom getters;</span></li>
<li><span class="sentence">Immutable properties of other such properties that too do not have delegation or custom getters;</span></li>
<li><span class="sentence">Mutable local properties without delegation or custom getters as soon as the compiler can prove that they cannot be mutated by external means:</span>
<ul>
<li><span class="sentence">Any properties that are captured in non-inlining lambda expressions or anonymous objects are not applicable.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): the rest is really shaky</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casting conditions are introduced by:</span></p>
</div>
<ul>
<li><span class="sentence">Conditional expressions (<code>if</code> and <code>when</code>):</span>
<ul>
<li><span class="sentence">Smart cast conditions derived from expression condition are active inside the positive branch scope;</span></li>
<li><span class="sentence">Smart cast conditions derived from negated expression condition are active inside the negative branch scope;</span></li>
<li><span class="sentence">If all the branches except one are unreachable, that branch’s condition is also propagated over to the scope containing the conditional expression, after the conditional expression;</span></li>
</ul></li>
<li><span class="sentence">Elvis operator (operator <code>?:</code>): if the right-hand branch of elvis operator is unreachable, a nullability condition for the left-hand side expression (if applicable) is introduced for the rest of the containing scope;</span></li>
<li><span class="sentence">Logical conjunction expressions (operator <code>&amp;&amp;</code>): all conditions derived from left-hand expression are applied to the right-hand expression;</span></li>
<li><span class="sentence">Logical disjunction expressions (operator <code>||</code>): all condtions derived from left-hand expression are applied negated to the right-hand expression;</span></li>
<li><span class="sentence">Not-null assertion expressions (operator <code>!!</code>): the left-hand side value (if applicable) introduces a nullability condtion for the rest of the scope the expression is contained in;</span></li>
<li><span class="sentence">Direct casting expression (operator <code>as</code>): the left-hand side expression (if applicable) introduces a type condition for the rest of the scope the expression is contained in with the assumed type being the same as the right-hand side type of the casting expression;</span></li>
<li><span class="sentence">Direct assignments: if both sides of the assignment are applicable expressions, all the conditions currently applying to the right-hand side are also applied to the left-hand side of the assignment for the rest of the containing scope;</span></li>
<li><span class="sentence">Platform-specific cases: different platforms may add other kinds of expressions that introduce smart-casting conditions.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Property declarations are not listed here because their types are naturally derived from initializers</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Smart cast conditions are derived from boolean expressions in the following way:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>is</code><span class="math inline">\(T\)</span> where <span class="math inline">\(x\)</span> is an applicable expression implies a type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>!is</code><span class="math inline">\(T\)</span> where <span class="math inline">\(x\)</span> is an applicable expression implies a negated type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>== null</code> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression implies a a nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>!= null</code> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression implies a a negated nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>!</code><span class="math inline">\(x\)</span> where <span class="math inline">\(x\)</span> implies all the conditions implied by <span class="math inline">\(x\)</span>, but in negated form;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>&amp;&amp;</code><span class="math inline">\(y\)</span> implies all the non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all the negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>||</code><span class="math inline">\(y\)</span> implies all the negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all the non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>==</code><span class="math inline">\(y\)</span> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is a known non-nullable value (that is, has a non-nullable compile-time type) implies the nullability condition for <span class="math inline">\(x\)</span>.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): is there more than that?</span></p>
</div>
</div>
<h3 id="local-type-inference">Local type inference</h3>
<div class="paragraph">
<p><span class="sentence">Local type inference in Kotlin is the process of deducing the compile-time types of expressions, lambda expression parameters and properties. </span><span class="sentence">As already mentioned above, type inference is a [type constraint][Kotlin type constraints] problem, solved by the type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In addition to the types of intermediate expressions, local type inference also must perform deduction and substitution for generic type parameters of functions and types involved in every expression. </span><span class="sentence">You can use the <a href="#expressions-1">expressions</a> part of this document as a reference point on how the types for different expressions are constructed (please note the effects of <a href="#smart-casts">smart casting</a> that are not mentioned in that part).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It does, however, need some clarification as those types are given as definitions, not as type constraints:</span></p>
</div>
<ul>
<li><span class="sentence">If the type <span class="math inline">\(T\)</span> is described as the least upper bound of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, it gets promoted to a pair of constraints: <span class="math inline">\(A &lt;: T\)</span> and <span class="math inline">\(B &lt;: T\)</span>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO: are there other cases?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Type inference in kotlin is also a bidirectional process, meaning that types of expressions may not only be derived from their arguments, but their usage as well. </span><span class="sentence">Please note that, albeit bidirectional, this process is still local, meaning that it processes one statement at a time, in the order of appearance in a scope, so a type of property in statement <span class="math inline">\(S_1\)</span> that goes before statement <span class="math inline">\(S_2\)</span> cannot be inferred based on usage information from <span class="math inline">\(S_2\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Unlike checking satisfiability for a type constraint system, actually solving it is not a definite process, as there may be more than one valid solution (see <a href="#type-constraint-solving">type constraint solving</a>). </span><span class="sentence">This means, among other things, that type inference in general may have several valid solutions as well. </span><span class="sentence">In particular, one may always derive a system <span class="math inline">\(A &lt;: T &lt;: B\)</span> for every type variable <span class="math inline">\(T\)</span> where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are both valid solution types. </span><span class="sentence">One of these types is always the solution in Kotlin (although from the constraint viewpoint, there are usually more solutions available), but choosing between them is done according to special rules:</span></p>
</div>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(): What are the rules?)</span>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note that this is valid even if <span class="math inline">\(T\)</span> is a variable without any constraints, as every type in kotlin has an implicit constraint <span class="math inline">\(\mathtt{kotlin.Nothing} &lt;: T &lt;: \mathtt{kotlin.Any?}\)</span>.</span></p>
</div>
</blockquote>
<h3 id="todo-4">TODO</h3>
<ul>
<li><span class="sentence">Type approximation for public usage</span></li>
<li><span class="sentence">Ordering of lambdas (and ordering of overloading vs TI in general) ## Runtime type information</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The <em>runtime type information</em> (RTTI) is the information about Kotlin types of values available from these values at runtime. </span><span class="sentence">RTTI affects the semantics of certain expressions, changing their evaluation depending on the amount of RTTI available for particular values, implementation, and platform:</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#type-checking-expression-1">The type checking operator</a></span></li>
<li><span class="sentence"><a href="#cast-expression-1">The cast expression</a>, expecially the <code>as?</code> operator</span></li>
<li><span class="sentence">[Class literals][class literal] and the values they evaluate to</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><em>Runtime types</em> are particular instances of RTTI for a particular value at runtime. </span><span class="sentence">These model a subset of the Kotlin <a href="#type-system">type system</a>. </span><span class="sentence">Namely, the runtime types are limited to <a href="#classifier-types">classifier types</a>, <a href="#function-types">function types</a> and a special case of <code>kotlin.Nothing?</code> which is the type of <a href="#null-literal-1"><code>null</code> reference</a> and the only nullable runtime type. </span><span class="sentence">This includes the classifier types created by <a href="#object-literals-1">anonymous object literals</a>. </span><span class="sentence">There is a slight distinction between a Kotlin type system type and its runtime counterpart:</span></p>
</div>
<ul>
<li><span class="sentence">On some platforms, some particular types may have the same runtime type representation. </span><span class="sentence">This means that checking or casting values of these types works the same way as if they were the same type</span></li>
<li><span class="sentence">Generic types with the same classifier are not required to have different runtime representations. </span><span class="sentence">One cannot generally rely on them having the same representation outside of a particular platform. </span><span class="sentence">Platform specifications must clarify whether some or all types on these platforms have this feature.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">RTTI is also the source of information for platform-specific <em>reflection</em> facilities in the standard library.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The types actual values may have are limited to <a href="#classifier-types">class and object types</a> and <a href="#function-types">function types</a> as well as <code>kotlin.Nothing?</code> for the <code>null</code> reference. </span><span class="sentence"><code>kotlin.Nothing</code> (not to be confused with its nullable variant <code>kotlin.Nothing?</code>) is special in the way that this type is never encountered as a runtime type even though it may have a platform-specific representation. </span><span class="sentence">The reason for this is that this type is used to signify non-existent values.</span></p>
</div>
<h3 id="runtime-available-types">Runtime-available types</h3>
<div class="paragraph">
<p><span class="sentence"><em>Runtime-available types</em> are the types that can be guaranteed (during compilation) to have a concrete <em>runtime</em> counterpart. </span><span class="sentence">These include all the runtime types, their nullable variants as well as [<code>reified</code> type parameters][Reified type parameters], that are guaranteed to inline to a runtime type during type parameter substitution. </span><span class="sentence">Only runtime-available types may be passed (implicitly or explicitly) as substitutions to reified type paramters, used for type checks and safe casts. </span><span class="sentence">During these operations, the nullability of the type is checked using reference-equality to <code>null</code>, while the rest is performed by accessing the runtime type of a value and comparing it to the supplied runtime-available type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For all generic types that are not expected to have RTTI for their generic arguments, only “raw” variants of generic types (denoted in code using the star-projected type notation or a special parameter-less notation <span><span class="TODO">(TODO: link?)</span><span class="TODO-marker">*</span></span>) are runtime-available.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may say that classifier generics are <em>partially</em> runtime available due to them having information about only the classifier part of the type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">[Exception types][Exceptions] must be runtime-available to enable type checks that the <code>catch</code> clause of <a href="#try-expression-1"><code>try</code>-expression</a> performs.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Only non-nullable runtime types may be used in <code>class</code> literal expressions. </span><span class="sentence">These include reified type parameters with non-nullable upper bounds, as well as all classifier and function types.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Anything else?)</span></p>
</div>
</div>
<h2 id="expressions-1">Expressions</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An expression may be <em>used as a statement</em> or <em>used as an expression</em> depending on the context. </span><span class="sentence">As all expressions are valid statements <a href="#statements">see the statements section</a>, free expressions may be used as single statements or inside code blocks.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An expression is used as an expression if it is encountered at any position where a statement is not allowed, for example, as an operand to an operator or as an immediate argument for a function call. </span><span class="sentence">An expression is used as a statement if it is encountered at any position where a statement is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Some expressions are only allowed to be used as statements unless certain restrictions are met and this may affect the semantics, the compile-type type information and the safety of these expressions. </span><span class="sentence">All expressions are allowed to be used as statements.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="constant-literals-1">Constant literals</h3>
<div class="paragraph">
<p><span class="sentence">Constant literals are expressions that correspond to constant, non-changing values. </span><span class="sentence">Every constant literal is defined to have a single standard library type, whichever it is defined to be on current platform.</span></p>
</div>
<h4 id="boolean-literals-1">Boolean literals</h4>
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>true</code> | <code>false</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Keywords <code>true</code> and <code>false</code> denote boolean literals of corresponding values. </span><span class="sentence">These are two strong keywords and as such cannot be used as identifiers unless [escaped][Escaped identifiers]. </span><span class="sentence">Values <code>true</code> and <code>false</code> always have type <code>kotlin.Bool</code>.</span></p>
</div>
<h4 id="integer-literals-1">Integer literals</h4>
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
</dd>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
</dd>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
</dd>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
<h5 id="decimal-integer-literals-1">Decimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of decimal digit symbols (<code>0</code> though <code>9</code>) is a decimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one. </span><span class="sentence">Please note that unlike other languages Kotlin does not support octal literals. </span><span class="sentence">Even more, any decimal literal starting with digit <code>0</code> and containing more than 1 digit is not a valid decimal literal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Decimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A decimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="hexadecimal-integer-literals-1">Hexadecimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of hexadecimal digit symbols (<code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, or <code>A</code> through <code>F</code>) prefixed by <code>0x</code> or <code>0X</code> is a hexadecimal integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Hexadecimal literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A hexadecimal literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h5 id="binary-integer-literals-1">Binary integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of binary digit symbols (<code>0</code> or <code>1</code>) prefixed by <code>0b</code> or <code>0B</code> is a binary integer literal. </span><span class="sentence">Digits may be separated by the underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Binary literals may be suffixed by the long literal mark (<code>L</code> symbol). </span><span class="sentence">A binary literal with the mark has type <code>kotlin.Long</code>, while a literal without it has type <code>kotlin.Int</code> if its value is below <span class="math inline">\(2^{31}-1\)</span> or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<h4 id="real-literals-1">Real literals</h4>
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
</dd>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>real literal</em> consists of the following parts: the whole-number part, a decimal point (represented by the ASCII period character (<code>.</code>)), a fraction part and an exponent. </span><span class="sentence">Unlike other languages, Kotlin real literals may only be expressed in decimal numbers. </span><span class="sentence">The number also may be followed by type suffix (<code>f</code> or <code>F</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The exponent is an exponent mark (<code>e</code> or <code>E</code>) followed by an optionaly signed decimal integer (a sequence of decimal digits).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The whole-number part and the exponent part may be omitted. </span><span class="sentence">The fraction part may only be omitted together with the decimal point if the whole part and either the exponent part or type suffix are present. </span><span class="sentence">Unlike other languages, Kotlin does not support omitting the fraction part, but leaving the decimal point in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The digits of the whole-number part or the fraction part or the exponent may be optionally separated by underscores, but an underscore may not be placed between, before, or after these parts. </span><span class="sentence">It also may not be placed before or after the exponent sign symbol.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A real literal without a type suffix has type <code>kotlin.Double</code>, while a real literal with the type suffix does have type <code>kotlin.Float</code>. </span><span class="sentence">There is no special suffix attributed to the <code>kotlin.Double</code> type.</span></p>
</div>
<h4 id="character-literals-1">Character literals</h4>
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
</dd>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <strong>character literal</strong> defines a constant holding a unicode character value. </span><span class="sentence">A simply-formed character literal is any symbol between two single quotation mark symbols (ASCII single quotation <code>'</code>), excluding newline symbols (<em>CR</em> and <em>LF</em>), the single quotation symbol itself and the escaping mark (the ASCII backslash symbol <code>\</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A character literal may also contain an escaped symbol of two kinds: a simple escaped symbol or a unicode codepoint. </span><span class="sentence">Simple escaped symbols include:</span></p>
</div>
<ul>
<li><span class="sentence"><code>\t</code> — the unicode TAB symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\b</code> — the unicode BACKSPACE symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\r</code> — <em>CR</em>;</span></li>
<li><span class="sentence"><code>\n</code> — <em>LF</em>;</span></li>
<li><span class="sentence"><code>\'</code> — the unicode single quotation symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\&quot;</code> — the unicode double quotation symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\\</code> — the unicode backslash symbol symbol<span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\$</code> — the unicode DOLLAR symbol.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A unicode codepoint escape sequence is the symbols <code>\u</code> followed by exactly four hexadecimal digits. </span><span class="sentence">It represents the unicode symbol with the codepoint equal to the number represented by these digits. </span><span class="sentence">Please note that unicode escapes support only unicode symbols in range U+0000 to U+FFFF.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Any character literal has type <code>kotlin.Char</code>.</span></p>
</div>
<h4 id="string-literals-2">String literals</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports [string interpolation][String Interpolation] mechanisms that supersede traditional string literals. </span><span class="sentence">Please refer to the corresponding section.</span></p>
</div>
<h4 id="null-literal-1">Null literal</h4>
<div class="paragraph">
<p><span class="sentence">The keyword <code>null</code> signifies the <strong>null reference</strong>, which is a valid value for all <a href="#nullable-types">nullable types</a>. </span><span class="sentence">Null reference implicitly has the nullable <code>kotlin.Nothing?</code> type and is, by definition, the only valid value for this type (see <a href="#kotlin.nothing">the corresponding section</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): reshuffle these sections</span></p>
</div>
</div>
<h3 id="try-expression-1">Try-expression</h3>
<div id="grammar-rule-tryExpression-pasted-57" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock-pasted-58" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-type">type</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock-pasted-59" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>try-expression</em> is an expression starting with the keyword <code>try</code>. </span><span class="sentence">It consists of a code block (<em>try body</em>) and several optional additional blocks: one of more <em>catch blocks</em>, starting with the soft keyword <code>catch</code> with a single parameter called <em>exception parameter</em> followed by another code block and a single optional <em>finally block</em>, starting with the soft keyword <code>finally</code> and yet another code block. </span><span class="sentence">At least one catch or finally block must exist, otherwise the expression is ill-formed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The try-expression evaluates its body as normally, but if any statement in the body throws an exception, the exception, rather than being propagated up the call stack, gets checked for its type. </span><span class="sentence">If there exists any catch block which parameter type is valid for the checked exception, this catch block is evaluated immediately after the exception is thrown and the exception itself is passed inside the catch block as the corresponding parameter. </span><span class="sentence">If there are several catch blocks with suitable parameter types, the first one is picked.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If there is a finally block, it gets evaluated after any evaluated catch block, or, if no catch block was encountered, after the exception was thrown. </span><span class="sentence">If no catch block was selected, the exception is [propagated as usual][Exceptions] up the call stack after the finally block (if any) is evaluated. </span><span class="sentence">If no exception is thrown during the evaluation of the try body, no catch blocks are checked, but the finally block is executed anyway and program execution continues as normal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The value of the try-expression is the same as the value of the last expression of the try body (if no exception was thrown) or the value of the last expression of the selected catch block (if one was selected). </span><span class="sentence">All other situations mean that an exception is propagated up the call stack, so the value of the try-expression becomes irrelevant. </span><span class="sentence">The finally block does get executed as described above, but has no effect on the value returned by the try-expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the try-expression is the [least upper bound][Least upper bound] of the types of the last expressions of the try body and the last expressions of all the catch blocks <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If any of the blocks have no valid last expression, the type is inferred to be <code>kotlin.Unit</code>, but the try-expression may be used as an expression anyway.</span></p>
</div>
<h3 id="conditional-expression-1">Conditional expression</h3>
<div id="grammar-rule-ifExpression-pasted-60" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>Conditional expressions</strong> use the boolean value of one expression (<em>condition</em>) to decide which of two control structure bodies (<em>branches</em>) should be evaluated. </span><span class="sentence">If the condition evaluates to <code>true</code>, than the first branch (the true branch) is evaluated, otherwise the second branch is. </span><span class="sentence">The value of the resulting expression is the same as the value of the chosen branch. </span><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of two branches <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If one of the branches is omitted (see the grammar entry above), the resulting expression has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The condition expression must have type <code>kotlin.Boolean</code> <span><span class="TODO">(TODO(): or be smartcasted to it!)</span><span class="TODO-marker">*</span></span>, otherwise it is a type error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">When used as expressions, conditional expressions are special in the sense of operator precedence: they have the highest (same as all primary expressions) priority when placed on the right side of any binary expression, but when placed on the left side, they have the lowest priority. </span><span class="sentence">For details, see the <a href="#syntax-grammar">grammar</a></span></p>
</div>
</blockquote>
<h3 id="when-expression-1">When expression</h3>
<div id="grammar-rule-whenExpression-pasted-61" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry-pasted-62" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition-pasted-63" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest-pasted-64" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest-pasted-65" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression</strong> is alike a <strong>conditional expression</strong> in the sense that it allows several different control structure bodies (<em>cases</em>) to be evaluated depending on boolean conditions. </span><span class="sentence">The key difference, however, is that when expressions may include several different conditions. </span><span class="sentence">When expression has two different forms: with bound value and without it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression without bound value</strong> (the form where the expression enclosed in parantheses is absent) evaluates one of the many different expressions based on corresponding conditions present in the same <em>when entry</em>. </span><span class="sentence">Each entry consists of a boolean <em>condition</em> (or a special <code>else</code> condition), each of which is checked and evaluated in order of appearance. </span><span class="sentence">If the current condition evaluates to <code>true</code>, the corresponding expression is evaluated and the value of when expression is the same as the evaluated expression. </span><span class="sentence">All remaining conditions and expressions are not evaluated. </span><span class="sentence">The <code>else</code> branch is a special branch that evaluates if none of the branches above it evaluated to <code>true</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally speaking, you can always replace the <code>else</code> branch with literal <code>true</code> and the semantics of the entry would not change</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The <code>else</code> entry is also special in the sense that it <strong>must</strong> be the last entry in the expression, otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression with bound value</strong> (the form where the expression enclosed in parantheses is present) are very similar to the form without bound value, but use different syntax for conditions. </span><span class="sentence">In fact, it supports three different condition forms:</span></p>
</div>
<ul>
<li><span class="sentence"><em>Type test condition</em>: type checking operator [TODO: link] followed by type. </span><span class="sentence">The condition generated is a type check expression [TODO: link] with the same operator and the same type, but an implicit left hand side, which has the same value as the bound expression.</span></li>
<li><span class="sentence"><em>Contains test condition</em>: containment operator [TODO: link] followed by an expression; The condition generated is a containment check expression [TODO: link] with the same operator and the same right hand side expression, but an implicit left hand side, which has the same value as the bound expression.</span></li>
<li><span class="sentence"><em>Any other expression</em>. </span><span class="sentence">The condition generated is an equality operator [TODO: link], with the left hand side being the bound expression, and the right hand side being the expression placed inside the entry.</span></li>
<li><span class="sentence">The <code>else</code> condition, which works the exact same way as it would in the form without bound expression.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This also means that if this form of <code>when</code> contains a boolean expression, it is not checked directly as if it would be in the other form, but rather checked for <strong>equality</strong> with the bound variable, which is not the same thing.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the [least upper bound][Least upper bound] of the types of all the entries <span><span class="TODO">(TODO(): not that simple)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If the expression is not <a href="#exhaustive-when-expressions-1">exhaustive</a>, it has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and the whole construct may not be used as an expression, but only as a statement.</span></p>
</div>
<h4 id="exhaustive-when-expressions-1">Exhaustive when expressions</h4>
<div class="paragraph">
<p><span class="sentence">A when expression is called <strong><em>exhaustive</em></strong> if at least one of the following is true:</span></p>
</div>
<ul>
<li><span class="sentence">It has an <code>else</code> entry;</span></li>
<li><span class="sentence">It has a bound value and at least one of the following holds:</span>
<ul>
<li><span class="sentence">The bound expression is of type <code>kotlin.Boolean</code> and the conditions contain both:</span>
<ul>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>true</code>;</span></li>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to value <code>false</code>;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of a [<code>sealed class</code>][Sealed classes] type and all its possible subtypes are covered using type test conditions of this expression. </span><span class="sentence">This may include:</span>
<ul>
<li><span class="sentence">Checks for all the direct subtypes of this sealed class;</span></li>
<li><span class="sentence">If any of the direct subtypes is also a sealed class, there is either a check for this subtype or all possible subtypes of it are also covered;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of an [<code>enum class</code>][Enum classes] type and all enumerated values are checked for equality using constant conditions;</span></li>
<li><span class="sentence">The bound expression is of a nullable type and one of the cases above is met for its non-nullable counterpart and, in addition, there is a condition containing literal <code>null</code>.</span></li>
</ul></li>
</ul>
<h3 id="logical-disjunction-expression-1">Logical disjunction expression</h3>
<div id="grammar-rule-disjunction-pasted-66" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>||</code> performs logical disjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>false</code>.</span></p>
</div>
<h3 id="logical-conjunction-expression-1">Logical conjunction expression</h3>
<div id="grammar-rule-conjunction-pasted-67" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>&amp;&amp;</code> performs logical conjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">Note that this operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>true</code>.</span></p>
</div>
<h3 id="equality-expressions-1">Equality expressions</h3>
<div id="grammar-rule-equality-pasted-68" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator-pasted-69" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Equality expressions are binary expressions involving equality operators. </span><span class="sentence">There are two kinds of equality operators: <em>reference equality operators</em> and <em>value equality operators</em>.</span></p>
</div>
<h4 id="reference-equality-expressions-1">Reference equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Reference equality expressions</em> are binary expressions employing reference equality operators: <code>===</code> and <code>!==</code>. </span><span class="sentence">These expressions check if two values are equal <em>by reference</em>, meaning that two values are equal (non-equal for operator <code>!==</code>) if and only if they represent the same runtime value created using the same constructor call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For values created without construction calls, notably the constant literals and constant expressions composed of those literals, the following holds:</span></p>
</div>
<ul>
<li><span class="sentence">If these values are <a href="#value-equality-expressions-1">non-equal by value</a>, they are also non-equal by reference;</span></li>
<li><span class="sentence">Any instance of the null reference <code>null</code> is reference-equals to any other instance of the null reference;</span></li>
<li><span class="sentence">Otherwise, it is implementation-defined and must not be used as a means of comparing two such values.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Reference equality expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="value-equality-expressions-1">Value equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Value equality expressions</em> are binary expressions employing value equality operators: <code>==</code> and <code>!=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> <code>==</code> <span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null)</code> where <code>equals</code> is a valid operator function available in the current scope;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span> <code>!=</code> <span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>?.equals(</code><span class="math inline">\(B\)</span><code>) ?: (</code><span class="math inline">\(B\)</span><code>=== null))</code> where <code>equals</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Please note that the class <code>kotlin.Any</code> has a built-in open operator member function called <code>equals</code>, meaning that there is always at least one available overloading candidate for any value equality expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Value equality expressions always have type <code>kotlin.Boolean</code>. </span><span class="sentence">If the corresponding operator function has a different return type, it is invalid and a compiler error should be generated.</span></p>
</div>
<h3 id="comparison-expressions-1">Comparison expressions</h3>
<div id="grammar-rule-comparison-pasted-70" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator-pasted-71" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Comparison expressions</em> are binary expressions employing the comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. </span><span class="sentence">These operators are [overloadable][Overloadable operators] with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;</code><span class="math inline">\(B\)</span> is exactly the same as <code>0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&lt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>) [&lt;] 0)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>&gt;=</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(0 [&lt;]</code><span class="math inline">\(A\)</span><code>.compareTo(</code><span class="math inline">\(B\)</span><code>))</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>compareTo</code> is a valid operator function available in the current scope and <code>[&lt;]</code> (read “boxed less”) is a special operator unavailable for in-code use in Kotlin and performing integer “less-than” comparison of two integer numbers. </span><span class="sentence">The <code>compareTo</code> overloaded function must have return type <code>kotlin.Int</code>, otherwise it’s a compiler error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All comparison expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="type-checking-and-containment-checking-expressions-1">Type-checking and containment-checking expressions</h3>
<div id="grammar-rule-infixOperation-pasted-72" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator-pasted-73" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator-pasted-74" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<h4 id="type-checking-expression-1">Type-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A type checking expression employs the use of an type-checking operators <code>is</code> or <code>!is</code> and has an expression as a left-hand side operand and a type name as a right-hand side operand. </span><span class="sentence">The type must be <a href="#runtime-available-types">runtime-available</a>, otherwise a compiler error should be generated. </span><span class="sentence">The expression checks whether the runtime type of the expression on the left is the same (not the same for <code>!is</code>) as the type denoted by the right-hand side argument.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type-checking expression always has type <code>kotlin.Boolean</code>.</span></p>
</div>
<h5 id="todo-5">TODO()</h5>
<ul>
<li><span class="sentence">Smart casts!</span></li>
</ul>
<h4 id="containment-checking-expression-1">Containment-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>containment-checking expression</em> is a binary expression employing the containment operator (<code>in</code> or <code>!in</code>). </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>in</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>)</code>;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>!in</code><span class="math inline">\(B\)</span> is exactly the same as <code>!(</code><span class="math inline">\(B\)</span><code>.contains(</code><span class="math inline">\(B\)</span><code>))</code>;</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>contains</code> is a valid operator function available in the current scope. </span><span class="sentence">This function must have return type <code>kotlin.Boolean</code>, otherwise a compiler error is generated. </span><span class="sentence">Containment-checking expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="elvis-operator-expression-1">Elvis operator expression</h3>
<div id="grammar-rule-elvisExpression-pasted-75" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Elvis operator expression</em> is a binary expression that emplys the elvis operator (<code>?:</code>). </span><span class="sentence">It checks whether the left-hand side expression is equal to <code>null</code>, and if it is, evaluates and return the right-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator is <strong>lazy</strong>, meaning that if the left-hand side expression is not equal to <code>null</code>, the right-hand side expression is never evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of elvis operator expression is the [least upper bound][The least upper bound] of the non-nullable variant of the type of the left-hand side expression and the type of the right-hand side expression. </span><span class="sentence">TODO(): not that simple, too</span></p>
</div>
<h3 id="range-expression-1">Range expression</h3>
<div id="grammar-rule-rangeExpression-pasted-76" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>range expression</em> is a binary expression employing the range operator <code>..</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>..</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rangeTo(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>rangeTo</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding <code>rangeTo</code> overload variant.</span></p>
</div>
<h3 id="additive-expression-1">Additive expression</h3>
<div id="grammar-rule-additiveExpression-pasted-77" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator-pasted-78" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>additive expression</em> is a binary expression employing the addition (<code>+</code>) or subtraction (<code>-</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>plus</code> or <code>minus</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="multiplicative-expression-1">Multiplicative expression</h3>
<div id="grammar-rule-multiplicativeExpression-pasted-79" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator-pasted-80" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>multiplicative expression</em> is a binary expression employing the multiplication (<code>*</code>), division (<code>/</code>) or remainder (<code>%</code>) operators. </span><span class="sentence">These are [overloadable][Overloadable operators] operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%</code><span class="math inline">\(B\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As of Kotlin version 1.2.31, there exists an additional overloading function for <code>%</code> called <code>mod</code>, which is deprecated</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">where <code>times</code>, <code>div</code>, <code>rem</code> is a valid operator function available in the current scope. </span><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">The range expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="cast-expression-1">Cast expression</h3>
<div id="grammar-rule-asExpression-pasted-81" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator-pasted-82" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>cast expression</em> is a binary expression employing the cast operators (<code>as</code> or <code>as?</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The form of cast expression employing the <code>as</code> operator is called <em>a unsafe cast</em> expression This operator perform a runtime check whether runtime type of the expression is a <a href="#subtyping">subtype</a> of the type given on the right-hand side operand and throws an exception otherwise. </span><span class="sentence">If the type on the right hand side is a <a href="#runtime-available-types">runtime-available</a> type without generic parameters, then this exception is thrown immediately when evaluating the expression, otherwise it is platform-dependent whether an exception is thrown at this point.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Even if the exception is not thrown when evaluating the cast expression, it is guaranteed to be thrown later when the value is used with any runtime-available type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The unsafe cast expression always has the same type as the type specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The form of cast expression employing the <code>as?</code> operator is called <em>a checked cast</em> expression This operator is very similar to the unsafe cast expression, but does not throw an exception, but returns <code>null</code> if the types don’t match. </span><span class="sentence">If the type specified on the right hand side of the expression is not <a href="#runtime-available-types">runtime-available</a>, then the check is not performed and <code>null</code> is never returned, leading to potential runtime errors later in the program execution. </span><span class="sentence">This situation should be reported with a compiler warning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The checked cast expression always has the <a href="#nullable-types">nullable</a> variant of the type specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>ascription expression</em> is a binary expression employing the ascription operator (<code>:</code>) and receives an expression as the left-hand side operand and a type name as the right-hand side operand.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator does not perform any actions at runtime and evaluates to the same value as its left hand operand. </span><span class="sentence">However, it does perform a compile-time check whether the current type of the expression is a <a href="#subtyping">subtype</a> of the type given on the right-hand side operand and generates a compiler error otherwise.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The ascription expression always has the same type as the type specified in right-hand side of the expression.</span></p>
</div>
<h4 id="todo-6">TODO()</h4>
<ul>
<li><span class="sentence">Smart casts!</span></li>
</ul>
<h3 id="prefix-expressions-1">Prefix expressions</h3>
<div id="grammar-rule-prefixUnaryExpression-pasted-83" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix-pasted-84" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator-pasted-85" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<h4 id="annotated-and-labeled-expression-1">Annotated and labeled expression</h4>
<div class="paragraph">
<p><span class="sentence">Any expression in Kotlin may be prefixed with any number of [annotations][Annotations] and [labels][Labels]. </span><span class="sentence">These do not change the value of the expression and can be used by external tools and platform-dependent features.</span></p>
</div>
<h4 id="prefix-increment-expression-1">Prefix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>++</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix increment expression must be an <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="prefix-decrement-expression-1">Prefix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression employing the prefix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>--</code><span class="math inline">\(A\)</span> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value to <span class="math inline">\(A\)</span> and then returning the value of <span class="math inline">\(A\)</span> as the result of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a prefix decrement expression must be an <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="unary-minus-expression-1">Unary minus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary minus</em> expression is an expression employing the prefix form of operator <code>-</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>-</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryMinus()</code> where <code>unaryMinus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="unary-plus-expression-1">Unary plus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary plus</em> expression is an expression employing the prefix form of operator <code>+</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>+</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.unaryPlus()</code> where <code>unaryPlus</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="logical-not-expression-1">Logical not expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>logical not</em> expression is an expression employing the prefix operator <code>!</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>!</code><span class="math inline">\(A\)</span> is exactly the same as <span class="math inline">\(A\)</span><code>.not()</code> where <code>not</code> is a suitable <code>operator</code> function, including its type. </span><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h3 id="postfix-operator-expressions-1">Postfix operator expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-86" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-87" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator-pasted-88" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<h4 id="postfix-increment-expression-1">Postfix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix increment</em> expression is an expression employing the postfix form of operator <code>++</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>++</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.inc()</code> where <code>inc</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb28"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb28-2" title="2">A = A.inc();</a>
<a class="sourceLine" id="cb28-3" title="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix increment expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of postfix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h4 id="postfix-decrement-expression-1">Postfix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix decrement</em> expression is an expression employing the postfix form of operator <code>--</code>. </span><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>--</code> is exactly the same as evaluating the expression <span class="math inline">\(A\)</span><code>.dec()</code> where <code>dec</code> is a suitable <code>operator</code> function, assigning the value of <span class="math inline">\(A\)</span> to a temporary location, assigning the result of <code>inc</code> to <span class="math inline">\(A\)</span> and returning the temporary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It can also be represented with the following code:</span></p>
</div>
<div class="sourceCode" id="cb29"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">val</span> <span class="va">tmp</span> = A;</a>
<a class="sourceLine" id="cb29-2" title="2">A = A.dec();</a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">return</span> tmp;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The left-hand side of a postfix decrement expression must be an [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise a compiler error must be generated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of prefix increment is always equal to the type of the right-hand side expression.</span></p>
</div>
<h3 id="not-null-assertion-expression-1">Not-null assertion expression</h3>
<div class="paragraph">
<p><span class="sentence">A <em>not-null assertion expression</em> is a postfix expression employing the use of operator <code>!!</code>. </span><span class="sentence">For expressions of nullabe types, this expression checks whether the value is equal to <code>null</code>, and if it is, throws a runtime exception. </span><span class="sentence">If it is not equal to <code>null</code>, it evaluates to the same value as its left-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Not-null assertion expressions have no effect on values of non-nullable types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of non-null assertion expression is the <a href="#nullable-types">non-nullable</a> variant of the type of its left-hand side expression. </span><span class="sentence">Note that this type may be non-denotable in Kotlin and as such, may be [approximated][Type approximation] in some situations involving [type inference][Type inference].</span></p>
</div>
<h3 id="indexing-expressions-1">Indexing expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-89" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-90" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix-pasted-91" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>indexing expression</em> is a suffix expression employing the use of several subexpressions <em>indices</em> between square brackets (<code>[</code> and <code>]</code>). </span><span class="sentence">At least one index must be provided.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is an [overloadable][Overloadable operators] operator with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A\)</span><code>[</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>]</code> is exactly the same as <span class="math inline">\(A\)</span><code>.get(</code><span class="math inline">\(I_0\)</span><code>,</code><span class="math inline">\(I_1\)</span><code>,</code><span class="math inline">\(\ldots\)</span><code>,</code><span class="math inline">\(I_N\)</span><code>)</code>, where <code>get</code> is a suitable <code>operator</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A correct indexing expression has the same type as the corresponding <code>get</code> expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Indexing expressions are [assignable][Assignable expressions]. </span><span class="sentence">For a corresponding assignment form, see [indexing assignment][Indexing assignment].</span></p>
</div>
<h3 id="call-and-property-access-expressions-1">Call and property access expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-92" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-93" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix-pasted-94" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix-pasted-95" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda-pasted-96" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments-pasted-97" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments-pasted-98" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection-pasted-99" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers-pasted-100" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator-pasted-101" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<h4 id="the-navigation-operators-1">The navigation operators</h4>
<div class="paragraph">
<p><span class="sentence">Expressions employing the navigation binary operators (<code>.</code>, <code>.?</code> or <code>::</code>) are all syntactically similar, but, in fact, may have very different syntactic meaning. </span><span class="sentence"><code>a.c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified type, property or object name. </span><span class="sentence">The left side of <code>.</code> must be a package name, while the right side corresponds to a declaration in that package. </span><span class="sentence">Note that qualification uses operator <code>.</code> only;</span></li>
<li><span class="sentence">A value property access. </span><span class="sentence">Here <code>a</code> is another value available in the current scope and <code>c</code> is the property name. </span><span class="sentence">If used with operator <code>::</code> this becomes a [property reference][Callable references]. </span><span class="sentence">The left-hand side expression may be a type name, which is similar to using the type’s companion object as the left hand side expression;</span></li>
<li><span class="sentence">A member function call if followed by the call suffix (arguments enclosed in parentheses). </span><span class="sentence">These expressions adhere to the <a href="#overload-resolution">overloading</a> rules. </span><span class="sentence">If used with operator <code>::</code>, but without the call suffix, this becomes a [function reference][Callable references].</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() + Identifiers</span></p>
</div>
</div>
<h3 id="function-literals-1">Function Literals</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin supports using functions as values. </span><span class="sentence">This includes, among other things, being able to use named functions (through [function references][Callable references]) as parts of expressions. </span><span class="sentence">Sometimes it does not make much sense to provide a separate function declaration, but rather define a function in-place, using <em>function literals</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two types of function literals in Kotlin: <em>lambda literals</em> and <em>anonymous function declarations</em>. </span><span class="sentence">Both of these provide a way of defining a function in-place, but have subtle differences.</span></p>
</div>
<h4 id="anonymous-function-declarations-1">Anonymous function declarations</h4>
<div id="grammar-rule-anonymousFunction-pasted-102" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-parametersWithOptionalType">parametersWithOptionalType</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Anonymous function declarations</em>, despite the name, are not actually declarations, but rather an expression that resembles a function declaration. </span><span class="sentence">They have syntax very similar to the function declaration syntax, but with a few differences:</span></p>
</div>
<ul>
<li><span class="sentence">Anonymous functions do not have a name (obviously);</span></li>
<li><span class="sentence">Anonymous functions may not have type parameters <span><span class="TODO">(TODO(): check!!!)</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence">Anonymous functions may not have default parameters <span><span class="TODO">(TODO(): check!!!)</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence">Anonymous functions may have variable argument parameters, but they are automatically decayed to non-variable argument parameters of array type <span><span class="TODO">(TODO(): how does this really work?)</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Anonymous function declaration may declare anonymous extension functions. </span><span class="sentence">The type of an anonymous function declaration is the function type constructed similarly to the corresponding [named function declaration][Function declarations].</span></p>
</div>
<h4 id="lambda-literals-1">Lambda literals</h4>
<div id="grammar-rule-lambdaLiteral-pasted-103" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)<br />
| (<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters-pasted-104" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter-pasted-105" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Lambda literals TODO()</span></p>
</div>
<h3 id="object-literals-1">Object literals</h3>
<div id="grammar-rule-objectLiteral-pasted-106" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Object literals are a way of defining anonymous objects in Kotlin. </span><span class="sentence">Anonymous objects are similar to regular objects, but they (obviously) have no name and thus can (only) be used as expressions. </span><span class="sentence">Anonymous objects, just like regular object declarations, can have at most one base class and many base interfaces declared in its delegation specifiers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between the regular object declaration and an anonymous object is its type. </span><span class="sentence">The type of an anonymous object is a special kind of type that is usable (and visible) only in the scope where it is declared. </span><span class="sentence">It is similar to a type that could be normally declared with a corresponding object declaration, but cannot be used outside the scope, leading to interesting effects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a value of this type escapes current scope:</span></p>
</div>
<ul>
<li><span class="sentence">If the type has only one declared supertype, it is implicitly downcasted to this declared supertype;</span></li>
<li><span class="sentence">If the type has several declared supertypes, there must be an explicit cast to any suitable type visible outside the scope, otherwise a compiler error is generated.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Please not that in this context “escaping” current scope is performed immediately if the corresponding value is declared as a global or classifier-scope property, as those are a part of package interface.</span></p>
</div>
<h3 id="this-expressions-1">This-expressions</h3>
<div id="grammar-rule-thisExpression-pasted-107" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">This-expressions are a special kind of expressions used to access available receivers in current scope. </span><span class="sentence">For more information about receivers, please refer to the <a href="#receivers">overloading section</a>. </span><span class="sentence">The basic form of this expression, denoted by <code>this</code> keyword, is used to access the current implicit receiver according to receiver overloading rules. </span><span class="sentence">In order to access other receivers, labeled <code>this</code> expressions are used. </span><span class="sentence">These may be any of the following:</span></p>
</div>
<ul>
<li><span class="sentence"><code>this@</code><span class="math inline">\(type\)</span> where <span class="math inline">\(type\)</span> is a name of any classifier that is currently being declared (that is, this this-expression is located inside its declaration’s inner scope) refers to the implicit object of the type being declared;</span></li>
<li><span class="sentence"><code>this@</code><span class="math inline">\(function\)</span> where <span class="math inline">\(function\)</span> is a name of a function currently being declared (that is, this this-expression is located inside the function body) refers to the implicit receiver object of this function (if it is an extension function) or is illegal and generates a compiler error.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Any other form of this-expression is illegal and generates a compiler error.</span></p>
</div>
<h3 id="super-forms-1">Super-forms</h3>
<div id="grammar-rule-superExpression-pasted-108" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<em><a href="#grammar-rule-AT_NO_WS">AT_NO_WS</a></em> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Super form is a special kind of expression that can only be used as the receiver of a function or property access expression. </span><span class="sentence">Any usage of such an expression in any other context is prohibited.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Super forms are used in classifier declarations to access the method implementations from base classifier types without invoking overriding behaviour.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="jump-expressions-1">Jump expressions</h3>
<div id="grammar-rule-jumpExpression-pasted-109" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Jump expressions</em> are a group of expressions that redirect the order the program is evaluated to a different program point when evaluated. </span><span class="sentence">All these expressions have several things in common:</span></p>
</div>
<ul>
<li><span class="sentence">They all have type <code>kotlin.Nothing</code>, effectively meaning that they never produce any runtime value;</span></li>
<li><span class="sentence">Any code that unconditionally follows such expression is never evaluated.</span></li>
</ul>
<h4 id="throw-expressions-1">Throw expressions</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): [Exceptions] go first</span></p>
</div>
</div>
<h4 id="return-expressions-1">Return expressions</h4>
<div class="paragraph">
<p><span class="sentence">A <em>return expression</em>, when used inside a function body, immediately stops evaluating the function and returns to the point where this function was called, making the function call expression evaluate to the value specified in this return expression (if any). </span><span class="sentence">A return expression with no value implicitly returns the <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of return expression: a simple return expression, specified using the <code>return</code> keyword, returning from the innermost <a href="#function-declaration">function declaration</a> (or [anonymous function expression][Anonymous function expression]) and the extended return expression, using the form <code>return@</code><span class="math inline">\(Context\)</span> where <span class="math inline">\(Context\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">The name of one of the enclosing function declarations to refer to this function. </span><span class="sentence">If several declarations match one name, an ambiguity compiler error is generated;</span></li>
<li><span class="sentence">If current expression is inside a lambda expression body, the name of the function using this lambda expression as a trailing lambda <span><span class="TODO">(TODO: Wut?)</span><span class="TODO-marker">*</span></span> parameter may be used to refer to the lambda literal itself.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If returning from the referred function is allowed in current context, the return is performed as usual. </span><span class="sentence">If returning from the referred function is not allowed, a compiler error is generated.</span></p>
</div>
<h4 id="continue-expression-1">Continue expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>continue expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the start of the next loop iteration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of continue expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple continue expression, specified using the <code>continue</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">An extended continue expression, denoted <code>continue@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): as a matter of fact, <code>continue</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
</div>
<h4 id="break-expression-1">Break expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>break expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the next program point after the loop.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of break expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple break expression, specified using the <code>break</code> keyword, which refers to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">An extended break expression, denoted <code>break@</code><span class="math inline">\(Loop\)</span>, where <span class="math inline">\(Loop\)</span> is a label referring to a labeled loop statement, which refers to the loop the label refers to.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): as a matter of fact, <code>break</code> is not allowed inside <code>when</code> &gt;_&lt;</span></p>
</div>
</div>
<h3 id="operator-expressions-1">Operator expressions</h3>
<h4 id="spread-operator-1">Spread operator</h4>
<h3 id="safe-call-expression-1">Safe call expression</h3>
<h3 id="type-check-expression-1">Type check expression</h3>
<h2 id="todos-1">TODOS()</h2>
<ul>
<li><span class="sentence">Overloadable operators &amp;&amp; operator expansion</span></li>
<li><span class="sentence">Smart casts vs compile-time types</span></li>
<li><div class="paragraph">
<p><span class="sentence">What does <code>decaying</code> for vararg actually mean?</span></p>
</div></li>
<li><span class="sentence">!!! </span><span class="sentence">object literal typing looks just like restricted union types. </span><span class="sentence">Are there any traps hidden here?</span></li>
<li><span class="sentence">The whole last paragraph in <a href="#object-literals-1">Object literals</a> is pretty shady</span></li>
<li><div class="paragraph">
<p><span class="sentence">What does it mean for returning to be disallowed? </span><span class="sentence">## Annotations</span></p>
</div></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() ## Coroutines</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO() ## Concurrency</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
</body>
</html>
