<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../assets/css/main.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="../assets/js/tests-integration.js"></script>
</head>
<body>



















<h2 id="inheritance">Inheritance</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(This is a stub)</span></p>
</div>
</div>
<h3 id="classifier-type-inheritance">Classifier type inheritance</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin is an object-oriented language with its object model based on <strong>inheritance</strong>. </span><span class="sentence">Classifier types may be inherited from each other: the type inherited <em>from</em> is called the base type, while the type that inherits the base type is called the derived type. </span><span class="sentence">A class or object type is allowed to inherit from only one class type (called its <strong>direct superclass</strong>) and multiple interface types. </span><span class="sentence">Object types cannot be inherited from. </span><span class="sentence">As specified in the declaration section, if the superclass of a class or object type is not specified, it is assumed to be <code>kotlin.Any</code> as all the types are inherited from it. </span><span class="sentence">This means, among other things, that every class or object type has a direct superclass type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A class is called closed and is forbidden to be inherited from if it is declared not <code>open</code> or <code>abstract</code> (please note that classes are neither <code>open</code> nor <code>abstract</code> by default). </span><span class="sentence">A <code>data class</code> cannot be declared <code>open</code> or <code>abstract</code> and cannot be inherited from.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An interface type may be inherited from any number of other interface types (and only interface types) without any limitation.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Inheritance is the primary mechanism of introducing [subtyping relations][Subtyping] between user-defined types in Kotlin. </span><span class="sentence">When a classifier type <span class="math inline">\(A\)</span> is declared with base types <span class="math inline">\(B_1, \dots, B_i\)</span> it introduces subtyping relations <span class="math inline">\(A &lt;: B_1, \ldots, A &lt;: B_i\)</span>, which are then used in [overload resolution] and [type inference] mechanisms.</span></p>
</div>
<h4 id="sealed-classes">Sealed classes</h4>
<div class="paragraph">
<p><span class="sentence">A class may be declared <code>sealed</code>, making it special from the inheritance point-of-view:</span></p>
</div>
<ul>
<li><span class="sentence">A <code>sealed</code> class is implicitly <code>abstract</code> (and these two modifiers are exclusive);</span></li>
<li><span class="sentence">It can only be inherited from by class and object types declared in the same file (including class and object types declared as nested classes for this class, but not nested classes for other classes);</span></li>
<li><span class="sentence">It allows for [exhaustiveness checking of when expressions][When-expressions] for values of this type.</span></li>
</ul>
<h4 id="inheritance-from-built-in-types">Inheritance from built-in types</h4>
<div class="paragraph">
<p><span class="sentence">[Built-in types][Built-in types] follow the same rules user-defined types do. </span><span class="sentence">Most of them are closed class types and cannot be inherited from. </span><span class="sentence">[Function types][Function types] are treated as interfaces and can be inherited from as such.</span></p>
</div>
<h3 id="overriding">Overriding</h3>
<div class="paragraph">
<p><span class="sentence">A callable declaration (that is, a property or member function declaration) inside a classifier declaration is said to be <em>overridable</em> if:</span></p>
</div>
<ul>
<li><span class="sentence">Its visibility (and the visibility of its getter and/or setter) is not <code>private</code>;</span></li>
<li><span class="sentence">It is declared as <code>open</code>, <code>abstract</code> or <code>override</code> (interface methods and properties are implicitly <code>abstract</code>).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A callable declaration inside a classifier declaration <em>subsumes</em> a corresponding declaration of the base classifier type if:</span></p>
</div>
<ul>
<li><span class="sentence">Its return type is a subtype of the return type of the corresponding declaration;</span></li>
<li><span class="sentence">Its formal parameter types are supertypes of the types of corresponding parameters from the corresponding declaration;</span></li>
<li><span class="sentence">Its name is the same as the name of the corresponding declaration.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(visibility games)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If the declaration of the base classifier type is overridable and the declaration of the derived classifier type subsumes it and it has an <code>override</code> modifier, it is <code>overriding</code> the base declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If the base declaration is not overridable and/or the deriving declaration does not have an <code>override</code> modifier, it is not permitted and should result in a compile-time error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin does not have a concept of full shadowing of declarations.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Platforms may introduce additional cases of both <em>overridability</em> and <em>subsumption</em> of declarations, as well as limit the overriding mechanism due to internal representation limitations.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(â€¦)</span></p>
</div>
</div>
</body>
</html>
